# TypeScript .d.ts Generation Issue with Rolldown

## Overview

We're encountering a build failure when generating `.d.ts` (TypeScript declaration) files using `rolldown-plugin-dts`. The issue manifests as TypeScript error **TS2742**: "The inferred type cannot be named without a reference to [internal module]. This is likely not portable."

## The Error

```
[plugin rolldown-plugin-dts:generate]
RollupError: src/react/queries/collectible/market-lowest-listing.ts(42,17): 
error TS2742: The inferred type of 'lowestListingQueryOptions' cannot be named 
without a reference to '../../../../node_modules/@0xsequence/marketplace-api/dist/marketplace.gen-By8-WuFI'. 
This is likely not portable. A type annotation is necessary.
```

### Affected Functions

1. `lowestListingQueryOptions` - `sdk/src/react/queries/collectible/market-lowest-listing.ts:42`
2. `highestOfferQueryOptions` - `sdk/src/react/queries/collectible/market-highest-offer.ts:42`
3. `useCollectibleMarketLowestListing` - `sdk/src/react/hooks/collectible/market-lowest-listing.tsx:54`
4. `useCollectibleMarketHighestOffer` - `sdk/src/react/hooks/collectible/market-highest-offer.tsx:54`
5. `useMarketCardData` - `sdk/src/react/hooks/ui/card-data/market-card-data.tsx:37`

## Root Cause Analysis

### What is TS2742?

TypeScript error **TS2742** occurs when the compiler cannot generate a portable type definition (`.d.ts` file) because the inferred type depends on:

1. **Internal implementation details** that shouldn't be exposed in the public API
2. **Complex type transformations** using `Omit`, intersections, or mapped types
3. **References to types from dependencies** that may not be available to consumers

### Why Does This Happen?

TypeScript's declaration file generator uses a different algorithm than the type checker. While the type checker can infer complex types at compile time, the `.d.ts` generator must create **serializable, portable type definitions** that work without the original source code.

Reference: [TypeScript Issue #42873](https://github.com/microsoft/TypeScript/issues/42873)

## Our Specific Case

### The Type Dependency Chain

```
SDK Function (lowestListingQueryOptions)
  ↓ returns result of buildQueryOptions()
  ↓ which returns queryOptions() from @tanstack/react-query
  ↓ with generic parameter Promise<GetCollectibleLowestListingResponse['order']>
  ↓ where GetCollectibleLowestListingResponse is defined as:
  ↓ Omit<Gen.GetCollectibleLowestListingResponse, 'order'> & { order?: Order }
  ↓ where Order is defined as:
  ↓ Omit<GenOrder, 'priceCurrencyAddress'> & { priceCurrencyAddress: Address }
  ↓ GenOrder comes from @0xsequence/marketplace-api/dist/marketplace.gen.ts
```

### The Problem

When `rolldown-plugin-dts` tries to generate the `.d.ts` file for `lowestListingQueryOptions`, it needs to serialize the return type. However:

1. The return type is inferred from `buildQueryOptions()`
2. Which uses `queryOptions<TData>()` from TanStack Query
3. Where `TData` = `GetCollectibleLowestListingResponse['order']`
4. This type uses `Omit<GenOrder, ...> & { ... }` transformations
5. TypeScript's `.d.ts` generator **cannot serialize the Omit + intersection** without including a reference to the original `GenOrder` type
6. But `GenOrder` is in a separate package (`@0xsequence/marketplace-api`) with a **generated unique module identifier** (`marketplace.gen-By8-WuFI`)
7. Including this reference would make the `.d.ts` file non-portable (it references internal build artifacts)

### Why `Omit<T, K> & { K: NewType }` is Problematic

TypeScript's declaration emitter has trouble with this pattern because:

1. **It must preserve the relationship to the original type** - `Omit<GenOrder, 'priceCurrencyAddress'>` still references `GenOrder`
2. **It cannot inline all properties** - This would break incremental builds and type checking
3. **The original type might not be in scope** - `GenOrder` is in a different package
4. **Module resolution changes** - The unique identifier (`-By8-WuFI`) is generated by the bundler and isn't stable

## What Rolldown and OXC Are Doing

### Rolldown

[Rolldown](https://rolldown.rs/) is a Rust-based JavaScript bundler (similar to Rollup) being developed by the Vite team. It uses:

- **Oxc** (oxidation compiler) for parsing and transforming
- **Rollup-compatible plugin API**
- Fast native performance via Rust

In our build:
```typescript
// sdk/package.json - build script
"build": "tsdown"

// tsdown uses rolldown under the hood
// node_modules/tsdown/dist/index.js
```

### rolldown-plugin-dts

The `rolldown-plugin-dts` plugin generates TypeScript declaration files by:

1. Running TypeScript's compiler API in declaration mode (`tsc --declaration`)
2. Bundling the resulting `.d.ts` files
3. Applying transformations to make them portable

**The issue**: TypeScript's compiler API refuses to generate declarations for functions where the inferred type has non-portable references.

Reference: [rolldown-plugin-dts](https://github.com/sxzz/rolldown-plugin-dts)

### Why This Matters

The `.d.ts` files are what TypeScript uses for:
- Type checking in consuming projects
- IDE autocomplete and IntelliSense
- Type safety across package boundaries

If we can't generate portable `.d.ts` files, the SDK package is unusable.

## Solutions

### Option 1: Add Explicit Return Type Annotations (Recommended)

Instead of letting TypeScript infer the return type, we explicitly annotate it:

```typescript
// Before (inferred return type - FAILS)
export function lowestListingQueryOptions(params: LowestListingQueryOptions) {
  return buildQueryOptions(
    {
      getQueryKey: getLowestListingQueryKey,
      requiredParams: ['chainId', 'collectionAddress', 'tokenId', 'config'] as const,
      fetcher: fetchLowestListing,
    },
    params,
  );
}

// After (explicit return type - WORKS)
export function lowestListingQueryOptions(
  params: LowestListingQueryOptions
): ReturnType<typeof queryOptions<GetCollectibleLowestListingResponse['order']>> {
  return buildQueryOptions(
    {
      getQueryKey: getLowestListingQueryKey,
      requiredParams: ['chainId', 'collectionAddress', 'tokenId', 'config'] as const,
      fetcher: fetchLowestListing,
    },
    params,
  );
}
```

**Pros:**
- Maintains type safety with generated types
- Types update automatically when API changes
- Clear, explicit API surface
- No additional maintenance burden

**Cons:**
- Need to annotate ~5 functions
- Return type is verbose

### Option 2: Fully Redefine Types (Not Recommended)

Copy all properties from `GenOrder` into a new `Order` interface:

```typescript
// Instead of:
export interface Order extends Omit<GenOrder, 'priceCurrencyAddress'> {
  priceCurrencyAddress: Address;
}

// Do this:
export interface Order {
  orderId: string;
  marketplace: MarketplaceKind;
  side: OrderSide;
  status: OrderStatus;
  // ... 30+ more fields
  priceCurrencyAddress: Address; // ← Our normalized field
}
```

**Pros:**
- Breaks the type dependency chain
- .d.ts generator can serialize it

**Cons:**
- **NOT TYPE SAFE** - If API adds/removes/renames fields, we won't know
- Manual maintenance required for ~30+ properties
- No compile-time validation against API changes
- Defeats the purpose of using generated types

### Option 3: Export Helper Types from API Package

Export a re-usable type from the API package:

```typescript
// api/src/index.ts
export type { Order, CollectibleOrder } from './adapters/marketplace/types';

// Then in SDK queries, use the exported type directly
import type { Order } from '@0xsequence/marketplace-api';
```

**Issue**: This is what we're already doing! The problem is that `Order` itself uses `Omit<GenOrder, ...>` which creates the non-portable reference.

### Option 4: Type Assertion / Any Escape Hatch (Anti-pattern)

```typescript
export function lowestListingQueryOptions(params: LowestListingQueryOptions) {
  return buildQueryOptions(...) as any;
}
```

**DO NOT DO THIS** - Defeats the entire purpose of TypeScript.

## Recommended Solution

**Use Option 1**: Add explicit return type annotations.

The key insight is that we need to help the `.d.ts` generator by:

1. Explicitly stating what we're returning
2. Using types that are already exported from our API package
3. Avoiding inline `Omit` transformations in the return type itself

### Implementation

```typescript
// sdk/src/react/queries/collectible/market-lowest-listing.ts
import { queryOptions } from '@tanstack/react-query';
import type { GetCollectibleLowestListingResponse } from '@0xsequence/marketplace-api';

export function lowestListingQueryOptions(
  params: LowestListingQueryOptions
): ReturnType<typeof queryOptions<GetCollectibleLowestListingResponse['order'], Error, GetCollectibleLowestListingResponse['order'], QueryKey>> {
  return buildQueryOptions({ /* ... */ }, params);
}
```

### Why This Works

1. TypeScript doesn't need to **infer** the type (it's explicit)
2. The `.d.ts` generator can **serialize** `ReturnType<typeof queryOptions<...>>`
3. We reference `GetCollectibleLowestListingResponse` which is an **exported type** from our API package
4. Even though `GetCollectibleLowestListingResponse` uses `Omit` internally, we're not forcing the `.d.ts` generator to inline that complexity
5. The type remains **fully type-safe** - if the API changes, the type will error

## Additional Context

### TypeScript's Declaration Emit Limitations

From the TypeScript team:

> "The declaration emitter is designed to emit types that can be written down in TypeScript source. Complex inferred types that involve Omit, Pick, conditional types, or mapped types may not be representable in a portable way."

Source: [TypeScript Handbook - Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)

### Why Module Identifiers Change

The `-By8-WuFI` suffix in `marketplace.gen-By8-WuFI` is a **module identifier hash** generated by the bundler to avoid naming conflicts. It's not stable across builds, which is why TypeScript considers it non-portable.

### Related TypeScript Issues

- [TS2742: Type cannot be named without a reference](https://github.com/microsoft/TypeScript/issues/42873)
- [Declaration emit should not reference private types](https://github.com/microsoft/TypeScript/issues/9944)
- [Omit + intersection creates non-portable types](https://github.com/microsoft/TypeScript/issues/31501)

## Type Safety Verification

To ensure we maintain type safety with explicit annotations:

```typescript
// This will error if GetCollectibleLowestListingResponse['order'] changes
type VerifyFetcherReturnType = 
  ReturnType<typeof fetchLowestListing> extends Promise<GetCollectibleLowestListingResponse['order']>
    ? true
    : never;

// This will error if the API response shape changes
type VerifyAPIContract =
  GetCollectibleLowestListingResponse extends { order?: Order }
    ? true
    : never;
```

We can add these as compile-time checks in our types file.

## Conclusion

The issue stems from TypeScript's `.d.ts` generator being unable to serialize complex inferred types that involve `Omit` + intersections across package boundaries. 

**Solution**: Add explicit return type annotations to the 5 affected functions using `ReturnType<typeof queryOptions<...>>`. This maintains full type safety while allowing the `.d.ts` generator to create portable declarations.

The root cause is **not** a bug in our code, but a known limitation of TypeScript's declaration emitter when dealing with complex type transformations.
