{"version":3,"file":"utils.js","names":["MARKETPLACES: Record<string, Marketplace>","KIND_TO_MARKETPLACE: Partial<\n\tRecord<MarketplaceKind, keyof typeof MARKETPLACES>\n>"],"sources":["../src/utils/address.ts","../src/utils/cn.ts","../src/utils/collection.ts","../src/utils/getMarketplaceDetails.ts","../src/utils/price.ts"],"sourcesContent":["export const truncateMiddle = (\n\taddress: string,\n\tminPrefix = 20,\n\tminSuffix = 3,\n): string => {\n\tif (minPrefix + minSuffix >= 40) {\n\t\treturn address;\n\t}\n\treturn `${address.substring(0, 2 + minPrefix)}â€¦${address.substring(address.length - minSuffix)}`;\n};\n\nexport const truncateEnd = (text: string | undefined, truncateAt: number) => {\n\tif (!text) return '';\n\n\tlet finalText = text;\n\n\tif (text.length >= truncateAt) {\n\t\tfinalText = `${text.slice(0, truncateAt)}...`;\n\t}\n\n\treturn finalText;\n};\n\nexport const compareAddress = (a = '', b = '') => {\n\treturn a.toLowerCase() === b.toLowerCase();\n};\n","import { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}\n","import type { MarketCollection } from '@0xsequence/api-client';\nimport { compareAddress } from './address';\n\n/**\n * Finds a market collection matching both the collection address and chain ID.\n * Always use this instead of manually searching market.collections to avoid\n * multi-chain bugs where the same collection address exists on different chains.\n */\nexport const findMarketCollection = (\n\tcollections: MarketCollection[],\n\tcollectionAddress: string,\n\tchainId: string | number,\n): MarketCollection | undefined => {\n\treturn collections.find(\n\t\t(collection) =>\n\t\t\tcompareAddress(collection.itemsAddress, collectionAddress) &&\n\t\t\tNumber(collection.chainId) === Number(chainId),\n\t);\n};\n","import { MarketplaceKind } from '@0xsequence/api-client';\nimport type { Image } from '@0xsequence/design-system';\nimport type { ComponentType } from 'react';\nimport {\n\tAlienSwapLogo,\n\tBlurLogo,\n\tLooksRareLogo,\n\tMagicEdenLogo,\n\tMintifyLogo,\n\tOpenSeaLogo,\n\tSequenceLogo,\n\tX2y2Logo,\n} from '../react/ui/components/marketplace-logos';\n\ninterface Marketplace {\n\tlogo: ComponentType<React.ComponentProps<typeof Image>>;\n\tdisplayName: string;\n}\n\nconst MARKETPLACES: Record<string, Marketplace> = {\n\tsequence: {\n\t\tlogo: SequenceLogo,\n\t\tdisplayName: 'Sequence',\n\t},\n\topensea: {\n\t\tlogo: OpenSeaLogo,\n\t\tdisplayName: 'OpenSea',\n\t},\n\tmagiceden: {\n\t\tlogo: MagicEdenLogo,\n\t\tdisplayName: 'Magic Eden',\n\t},\n\tmintify: {\n\t\tlogo: MintifyLogo,\n\t\tdisplayName: 'Mintify',\n\t},\n\tlooksrare: {\n\t\tlogo: LooksRareLogo,\n\t\tdisplayName: 'Looks Rare',\n\t},\n\tx2y2: {\n\t\tlogo: X2y2Logo,\n\t\tdisplayName: 'X2Y2',\n\t},\n\tblur: {\n\t\tlogo: BlurLogo,\n\t\tdisplayName: 'Blur',\n\t},\n\talienswap: {\n\t\tlogo: AlienSwapLogo,\n\t\tdisplayName: 'AlienSwap',\n\t},\n} as const;\n\nconst KIND_TO_MARKETPLACE: Partial<\n\tRecord<MarketplaceKind, keyof typeof MARKETPLACES>\n> = {\n\t[MarketplaceKind.sequence_marketplace_v1]: 'sequence',\n\t[MarketplaceKind.sequence_marketplace_v2]: 'sequence',\n\t[MarketplaceKind.opensea]: 'opensea',\n\t[MarketplaceKind.mintify]: 'mintify',\n\t[MarketplaceKind.looks_rare]: 'looksrare',\n\t[MarketplaceKind.x2y2]: 'x2y2',\n\t[MarketplaceKind.blur]: 'blur',\n\t[MarketplaceKind.magic_eden]: 'magiceden',\n};\n\ntype MarketplaceDetailsProp = {\n\toriginName: string;\n\tkind: MarketplaceKind;\n};\n\n// TODO: add support for more marketplaces and improve detection of marketplace\nexport function getMarketplaceDetails({\n\toriginName,\n\tkind,\n}: MarketplaceDetailsProp) {\n\tif (\n\t\tkind === MarketplaceKind.sequence_marketplace_v1 ||\n\t\tkind === MarketplaceKind.sequence_marketplace_v2\n\t) {\n\t\treturn MARKETPLACES.sequence;\n\t}\n\n\tlet name = originName.toLowerCase();\n\n\ttry {\n\t\t//Check if the name can be parsed as a url\n\t\tnew URL(name);\n\t\t// if it can we are naively trying to extract the root domain\n\t\tname = getRootDomain(name) || name;\n\t} catch {}\n\n\tname = name.replace(/ /g, '');\n\n\tconst details = MARKETPLACES[name];\n\n\tif (details) {\n\t\treturn details;\n\t}\n\n\tif (KIND_TO_MARKETPLACE[kind]) {\n\t\treturn MARKETPLACES[KIND_TO_MARKETPLACE[kind]];\n\t}\n}\n\nfunction getRootDomain(url: string) {\n\tconst domain = url.replace(/^(https?:\\/\\/)?(www\\.)?/, '');\n\tconst parts = domain.split('.');\n\treturn parts[parts.length - 2] || parts[0];\n}\n","import * as dn from 'dnum';\nimport { formatUnits } from 'viem';\n\ntype CalculatePriceDifferencePercentageArgs = {\n\tinputPriceRaw: bigint;\n\tbasePriceRaw: bigint;\n\tdecimals: number;\n};\n\n/**\n * Calculates the percentage difference between two prices\n * @param args - Object containing input price, base price, and decimals\n * @returns The percentage difference as a string with 2 decimal places\n * @example\n * ```ts\n * const diff = calculatePriceDifferencePercentage({\n *   inputPriceRaw: 1000000n,\n *   basePriceRaw: 900000n,\n *   decimals: 6\n * }); // Returns \"11.11\"\n * ```\n */\nexport const calculatePriceDifferencePercentage = ({\n\tinputPriceRaw,\n\tbasePriceRaw,\n\tdecimals,\n}: CalculatePriceDifferencePercentageArgs) => {\n\tconst inputPrice = Number(formatUnits(inputPriceRaw, decimals));\n\tconst basePrice = Number(formatUnits(basePriceRaw, decimals));\n\tconst difference = inputPrice - basePrice;\n\tconst percentageDifference = (difference / basePrice) * 100;\n\n\treturn percentageDifference.toFixed(2);\n};\n\n/**\n * Formats a raw price amount with the specified number of decimal places\n * @param amount - The raw price amount as a bigint\n * @param decimals - Number of decimal places to format to\n * @returns Formatted price string with proper decimal and thousands separators\n * @example\n * ```ts\n * const formatted = formatPrice(1000000n, 6); // Returns \"1.000000\"\n * ```\n */\nexport const formatPrice = (amount: bigint, decimals: number): string => {\n\tconst formattedUnits = Number(formatUnits(amount, decimals));\n\treturn formattedUnits.toLocaleString('en-US', {\n\t\tminimumFractionDigits: 0,\n\t\tmaximumFractionDigits: decimals,\n\t});\n};\n\n/**\n * Calculates the final earnings amount after applying multiple fee percentages\n * @param amount - The raw amount as a bigint (e.g., from a blockchain transaction)\n * @param decimals - The number of decimal places for the currency (e.g., 18 for ETH, 6 for USDC)\n * @param fees - Array of fee percentages to apply (e.g., [2.5, 1.0] for 2.5% and 1% fees)\n * @returns Formatted string representing the final earnings after all fees are applied\n * @throws Will return '0' if there's an error in calculation\n * @example\n * ```ts\n * const earnings = calculateEarningsAfterFees(\n *   1000000000000000000n, // 1 ETH\n *   18,                   // ETH decimals\n *   [2.5, 1.0]           // 2.5% and 1% fees\n * ); // Returns \"0.96525\" (1 ETH after 2.5% and 1% fees)\n * ```\n */\nexport const calculateEarningsAfterFees = (\n\tamount: bigint,\n\tdecimals: number,\n\tfees: number[],\n): string => {\n\ttry {\n\t\t// formatUnits already returns a string, no need for Number conversion\n\t\tconst decimalAmount = formatUnits(amount, decimals);\n\t\tlet earnings = dn.from(decimalAmount, decimals);\n\n\t\tfor (const fee of fees) {\n\t\t\tif (fee > 0) {\n\t\t\t\t// dnum accepts numbers directly via Numberish type\n\t\t\t\tconst feeMultiplier = dn.from(1 - fee / 100, decimals);\n\t\t\t\tearnings = dn.multiply(earnings, feeMultiplier);\n\t\t\t}\n\t\t}\n\n\t\treturn dn.format(earnings, {\n\t\t\tdigits: decimals,\n\t\t\ttrailingZeros: false,\n\t\t\tlocale: 'en-US',\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('Error calculating earnings after fees:', error);\n\t\treturn '0';\n\t}\n};\n\n/**\n * Formats a price amount with fee applied\n * @param amount - The raw price amount as a bigint\n * @param decimals - Number of decimal places for the currency\n * @param feePercentage - Fee percentage to apply (e.g., 3.5 for 3.5%)\n * @returns Formatted price string with fee applied and proper decimal/thousands separators\n * @example\n * ```ts\n * const priceWithFee = formatPriceWithFee(1000000n, 6, 3.5); // Returns \"1.035\"\n * ```\n */\nexport const formatPriceWithFee = (\n\tamount: bigint,\n\tdecimals: number,\n\tfeePercentage: number,\n): string => {\n\ttry {\n\t\t// formatUnits already returns a string, no need for Number conversion\n\t\tconst decimalAmount = formatUnits(amount, decimals);\n\t\tconst price = dn.from(decimalAmount, decimals);\n\t\t// dnum accepts numbers directly via Numberish type\n\t\tconst feeMultiplier = dn.from(1 + feePercentage / 100, decimals);\n\t\tconst totalPrice = dn.multiply(price, feeMultiplier);\n\n\t\treturn dn.format(totalPrice, {\n\t\t\tdigits: decimals,\n\t\t\ttrailingZeros: false,\n\t\t\tlocale: 'en-US',\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('Error formatting price with fee:', error);\n\t\treturn '0';\n\t}\n};\n\nexport const calculateTotalOfferCost = (\n\tofferAmountRaw: bigint,\n\tdecimals: number,\n\troyaltyPercentage = 0,\n): bigint => {\n\ttry {\n\t\tconst dnumAmount = [offerAmountRaw, decimals] as dn.Dnum;\n\t\tlet totalCost = dn.from(dnumAmount);\n\n\t\tif (royaltyPercentage > 0) {\n\t\t\t// dnum accepts numbers directly via Numberish type\n\t\t\tconst royaltyFee = dn.multiply(\n\t\t\t\ttotalCost,\n\t\t\t\tdn.from(royaltyPercentage / 100, decimals),\n\t\t\t);\n\t\t\ttotalCost = dn.add(totalCost, royaltyFee);\n\t\t}\n\n\t\tconst totalCostString = dn.format(totalCost, {\n\t\t\tdigits: decimals,\n\t\t\ttrailingZeros: true,\n\t\t});\n\n\t\tconst cleanAmount = totalCostString.replace(/,/g, '');\n\n\t\treturn BigInt(Math.round(Number(cleanAmount) * 10 ** decimals));\n\t} catch (error) {\n\t\tconsole.error('Error calculating total offer cost:', error);\n\t\treturn offerAmountRaw;\n\t}\n};\n\n/**\n * Validates if a price value meets OpenSea's decimal constraints for offers\n * OpenSea allows maximum 4 decimal places for offers and minimum 0.0001\n * @param value - The price value as a string\n * @returns Object containing validation result and error message\n * @example\n * ```ts\n * const result = validateOpenseaOfferDecimals('0.12345');\n * // Returns { isValid: false, errorMessage: \"Offer amount must be at least 0.0001\" }\n * ```\n */\nexport const validateOpenseaOfferDecimals = (\n\tvalue: string,\n): { isValid: boolean; errorMessage?: string } => {\n\tif (!value || value === '0') return { isValid: true };\n\n\tconst [_, decimals = ''] = value.split('.');\n\tif (decimals.length > 4) {\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\terrorMessage: 'Offer amount must be at least 0.0001',\n\t\t};\n\t}\n\n\treturn { isValid: true };\n};\n"],"mappings":"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"}