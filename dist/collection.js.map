{"version":3,"file":"collection.js","names":["chunks: T[][]","promises: Promise<ContractInfo[]>[]"],"sources":["../src/react/queries/collection/queryKeys.ts","../src/react/queries/collection/balance-details.ts","../src/react/queries/collection/list.ts","../src/react/queries/collection/market-detail.ts","../src/react/queries/collection/market-filtered-count.ts","../src/react/queries/collection/market-floor.ts","../src/react/queries/collection/market-items.ts","../src/react/queries/collection/market-items-count.ts","../src/react/queries/collection/market-items-paginated.ts","../src/react/queries/collection/metadata.ts"],"sourcesContent":["import { serializeBigInts } from '../../_internal/utils';\n\n/**\n * Creates a type-safe query key for collection domain with automatic bigint serialization\n *\n * @param operation - The specific operation (e.g., 'balance-details', 'metadata')\n * @param params - The query parameters (will be automatically serialized)\n * @returns A serialized query key safe for React Query\n */\nexport function createCollectionQueryKey<T>(operation: string, params: T) {\n\treturn ['collection', operation, serializeBigInts(params)] as const;\n}\n","import type {\n\tChainId,\n\tGetTokenBalancesDetailsRequest,\n\tIndexer,\n\tTokenBalancesFilter,\n} from '@0xsequence/api-client';\nimport {\n\tbuildQueryOptions,\n\tgetIndexerClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectionQueryKey } from './queryKeys';\n\nexport type CollectionBalanceFilter = TokenBalancesFilter;\n\nexport type FetchCollectionBalanceDetailsParams =\n\tGetTokenBalancesDetailsRequest & {\n\t\tchainId: ChainId;\n\t};\n\nexport type CollectionBalanceDetailsQueryOptions =\n\tSdkQueryParams<FetchCollectionBalanceDetailsParams>;\n\n/**\n * Fetches detailed balance information for multiple accounts from the Indexer API\n */\nexport async function fetchCollectionBalanceDetails(\n\tparams: WithRequired<\n\t\tCollectionBalanceDetailsQueryOptions,\n\t\t'chainId' | 'filter' | 'config'\n\t>,\n): Promise<Indexer.GetTokenBalancesDetailsResponse> {\n\tconst { chainId, filter, config } = params;\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tconst promises = filter.accountAddresses.map((accountAddress) =>\n\t\tindexerClient.getTokenBalancesDetails({\n\t\t\tfilter: {\n\t\t\t\taccountAddresses: [accountAddress],\n\t\t\t\tcontractWhitelist: filter.contractWhitelist,\n\t\t\t\tomitNativeBalances: filter.omitNativeBalances,\n\t\t\t},\n\t\t}),\n\t);\n\n\tconst responses = await Promise.all(promises);\n\tconst mergedResponse =\n\t\tresponses.reduce<Indexer.GetTokenBalancesDetailsResponse>(\n\t\t\t(acc, curr) => {\n\t\t\t\tif (!curr) return acc;\n\t\t\t\treturn {\n\t\t\t\t\tpage: curr.page,\n\t\t\t\t\tnativeBalances: [\n\t\t\t\t\t\t...(acc.nativeBalances || []),\n\t\t\t\t\t\t...(curr.nativeBalances || []),\n\t\t\t\t\t],\n\t\t\t\t\tbalances: [...(acc.balances || []), ...(curr.balances || [])],\n\t\t\t\t};\n\t\t\t},\n\t\t\t{\n\t\t\t\tpage: { page: 0, pageSize: 0, more: false },\n\t\t\t\tnativeBalances: [],\n\t\t\t\tbalances: [],\n\t\t\t},\n\t\t);\n\n\tif (!mergedResponse) {\n\t\tthrow new Error('Failed to fetch collection balance details');\n\t}\n\n\treturn mergedResponse;\n}\n\nexport function getCollectionBalanceDetailsQueryKey(\n\tparams: CollectionBalanceDetailsQueryOptions,\n) {\n\tconst { chainId, filter } = params;\n\n\treturn createCollectionQueryKey('balance-details', { chainId, filter });\n}\n\nexport function collectionBalanceDetailsQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCollectionBalanceDetailsQueryOptions,\n\t\t\t'chainId' | 'filter' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCollectionBalanceDetailsQueryKey,\n\t\t\trequiredParams: ['chainId', 'filter', 'config'] as const,\n\t\t\tfetcher: fetchCollectionBalanceDetails,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.filter?.accountAddresses && p.filter.accountAddresses.length > 0,\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { ContractInfo } from '@0xsequence/api-client';\nimport { queryOptions, skipToken } from '@tanstack/react-query';\nimport type {\n\tMarketCollection,\n\tMarketplaceConfig,\n\tShopCollection,\n} from '../../../types';\nimport { compareAddress } from '../../../utils';\nimport {\n\tbuildQueryOptions,\n\tgetMetadataClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectionQueryKey } from './queryKeys';\n\nfunction getAllCollections(marketplaceConfig: MarketplaceConfig) {\n\treturn [\n\t\t...marketplaceConfig.market.collections,\n\t\t...marketplaceConfig.shop.collections,\n\t];\n}\n\nfunction filterCollectionsByType(\n\tcollections: Array<MarketCollection | ShopCollection>,\n\tcollectionType?: 'market' | 'shop',\n) {\n\tif (!collectionType) {\n\t\treturn collections;\n\t}\n\treturn collections.filter(\n\t\t(c) => c.marketplaceCollectionType === collectionType,\n\t);\n}\n\nfunction groupCollectionsByChain(\n\tcollections: Array<MarketCollection | ShopCollection>,\n) {\n\treturn collections.reduce<Record<string, string[]>>((acc, curr) => {\n\t\tconst { chainId, itemsAddress } = curr;\n\t\tif (!acc[chainId]) {\n\t\t\tacc[chainId] = [];\n\t\t}\n\t\tacc[chainId].push(itemsAddress);\n\t\treturn acc;\n\t}, {});\n}\n\nconst MAX_ADDRESSES_PER_BATCH = 15;\n\nfunction chunkArray<T>(array: T[], size: number): T[][] {\n\tconst chunks: T[][] = [];\n\tfor (let i = 0; i < array.length; i += size) {\n\t\tchunks.push(array.slice(i, i + size));\n\t}\n\treturn chunks;\n}\n\nexport type FetchListCollectionsParams = {\n\tcollectionType?: 'market' | 'shop';\n\tmarketplaceConfig: MarketplaceConfig;\n};\n\nexport type ListCollectionsQueryOptions =\n\tSdkQueryParams<FetchListCollectionsParams>;\n\n/**\n * Fetches collections from the metadata API with marketplace config filtering\n */\nexport async function fetchListCollections(\n\tparams: WithRequired<\n\t\tListCollectionsQueryOptions,\n\t\t'marketplaceConfig' | 'config'\n\t>,\n) {\n\tconst { collectionType, marketplaceConfig, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tlet collections = getAllCollections(marketplaceConfig);\n\n\tif (!collections?.length) {\n\t\treturn [];\n\t}\n\n\tcollections = filterCollectionsByType(collections, collectionType);\n\n\tconst collectionsByChain = groupCollectionsByChain(collections);\n\n\tconst promises: Promise<ContractInfo[]>[] = [];\n\n\tfor (const [chainId, addresses] of Object.entries(collectionsByChain)) {\n\t\tconst addressChunks = chunkArray(addresses, MAX_ADDRESSES_PER_BATCH);\n\n\t\tfor (const chunk of addressChunks) {\n\t\t\tpromises.push(\n\t\t\t\tmetadataClient\n\t\t\t\t\t.getContractInfoBatch({\n\t\t\t\t\t\tchainId: Number(chainId),\n\t\t\t\t\t\tcontractAddresses: chunk,\n\t\t\t\t\t})\n\t\t\t\t\t.then((resp) => Object.values(resp.contractInfoMap)),\n\t\t\t);\n\t\t}\n\t}\n\n\tconst settled = await Promise.allSettled(promises);\n\n\t// If all promises failed, throw the first error\n\tif (settled.every((result) => result.status === 'rejected')) {\n\t\tconst firstError = settled[0];\n\t\tthrow firstError.reason;\n\t}\n\n\tconst results = settled\n\t\t.filter(\n\t\t\t(r): r is PromiseFulfilledResult<ContractInfo[]> =>\n\t\t\t\tr.status === 'fulfilled',\n\t\t)\n\t\t.flatMap((r) => r.value);\n\n\tconst collectionsWithMetadata = collections\n\t\t.map((collection) => {\n\t\t\tconst metadata = results.find((result) =>\n\t\t\t\tcompareAddress(result.address, collection.itemsAddress),\n\t\t\t);\n\t\t\treturn { collection, metadata };\n\t\t})\n\t\t.filter(\n\t\t\t(\n\t\t\t\titem,\n\t\t\t): item is {\n\t\t\t\tcollection: MarketCollection | ShopCollection;\n\t\t\t\tmetadata: ContractInfo;\n\t\t\t} => item.metadata !== undefined,\n\t\t)\n\t\t.map(({ collection, metadata }) => ({\n\t\t\t...collection,\n\t\t\t...metadata,\n\t\t}));\n\n\treturn collectionsWithMetadata;\n}\n\nexport function getListCollectionsQueryKey(\n\tparams: ListCollectionsQueryOptions,\n) {\n\tconst queryKeyParams = {\n\t\tcollectionType: params.collectionType,\n\t\tmarketplaceConfig: params.marketplaceConfig,\n\t} as const;\n\n\treturn createCollectionQueryKey('list', queryKeyParams);\n}\n\nexport function listCollectionsQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<ListCollectionsQueryOptions, 'marketplaceConfig' | 'config'>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListCollectionsQueryKey,\n\t\t\trequiredParams: ['marketplaceConfig', 'config'] as const,\n\t\t\tfetcher: fetchListCollections,\n\t\t},\n\t\tparams,\n\t);\n}\n\n// Keep old function for backward compatibility during migration\nexport const listCollectionsOptions = ({\n\tcollectionType,\n\tmarketplaceConfig,\n\tconfig,\n\tquery,\n}: ListCollectionsQueryOptions) => {\n\treturn queryOptions({\n\t\tqueryKey: [\n\t\t\t'collection',\n\t\t\t'list',\n\t\t\t{ collectionType, marketplaceConfig, config },\n\t\t],\n\t\tqueryFn:\n\t\t\tmarketplaceConfig && config\n\t\t\t\t? () =>\n\t\t\t\t\t\tfetchListCollections({\n\t\t\t\t\t\t\tmarketplaceConfig,\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tcollectionType,\n\t\t\t\t\t\t})\n\t\t\t\t: skipToken,\n\t\t...query,\n\t});\n};\n","import type { GetCollectionDetailRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type MarketCollectionDetailQueryOptions =\n\tSdkQueryParams<GetCollectionDetailRequest>;\n\n/**\n * Fetches collection details from the marketplace API\n */\nexport async function fetchMarketCollectionDetail(\n\tparams: WithRequired<\n\t\tMarketCollectionDetailQueryOptions,\n\t\t'collectionAddress' | 'chainId' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst result = await marketplaceClient.getCollectionDetail(apiParams);\n\treturn result.collection;\n}\n\nexport function getCollectionMarketDetailQueryKey(\n\tparams: MarketCollectionDetailQueryOptions,\n) {\n\treturn [\n\t\t'collection',\n\t\t'market-detail',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t},\n\t] as const;\n}\n\nexport function collectionMarketDetailQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tMarketCollectionDetailQueryOptions,\n\t\t\t'collectionAddress' | 'chainId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCollectionMarketDetailQueryKey,\n\t\t\trequiredParams: ['collectionAddress', 'chainId', 'config'] as const,\n\t\t\tfetcher: fetchMarketCollectionDetail,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { GetCountOfFilteredOrdersRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchGetCountOfFilteredOrdersParams =\n\tGetCountOfFilteredOrdersRequest;\n\nexport type GetCountOfFilteredOrdersQueryOptions =\n\tSdkQueryParams<FetchGetCountOfFilteredOrdersParams>;\n\nexport async function fetchGetCountOfFilteredOrders(\n\tparams: WithRequired<\n\t\tGetCountOfFilteredOrdersQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst client = getMarketplaceClient(config);\n\tconst result = await client.getCountOfFilteredOrders(apiParams);\n\treturn result.count;\n}\n\nexport function getCountOfFilteredOrdersQueryKey(\n\tparams: GetCountOfFilteredOrdersQueryOptions,\n) {\n\treturn [\n\t\t'collection',\n\t\t'market-filtered-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tside: params.side,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function getCountOfFilteredOrdersQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tGetCountOfFilteredOrdersQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCountOfFilteredOrdersQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'config',\n\t\t\t\t'side',\n\t\t\t] as const,\n\t\t\tfetcher: fetchGetCountOfFilteredOrders,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\ttype GetFloorOrderRequest,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FloorOrderQueryOptions = SdkQueryParams<GetFloorOrderRequest>;\n\n/**\n * Fetches the floor order for a collection from the marketplace API\n */\nexport async function fetchFloorOrder(\n\tparams: WithRequired<\n\t\tFloorOrderQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst result = await marketplaceClient.getFloorOrder(apiParams);\n\treturn result.collectible;\n}\n\nexport function getFloorOrderQueryKey(params: FloorOrderQueryOptions) {\n\treturn [\n\t\t'collection',\n\t\t'market-floor',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function floorOrderQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tFloorOrderQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getFloorOrderQueryKey,\n\t\t\trequiredParams: ['chainId', 'collectionAddress', 'config'] as const,\n\t\t\tfetcher: fetchFloorOrder,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import { isAddress } from 'viem';\nimport type { Page } from '../../../types';\nimport type {\n\tListOrdersWithCollectiblesRequest,\n\tListOrdersWithCollectiblesResponse,\n\tWithOptionalParams,\n} from '../../_internal';\nimport {\n\tbuildInfiniteQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectionQueryKey } from './queryKeys';\n\nexport type ListItemsOrdersForCollectionQueryOptions =\n\tSdkInfiniteQueryParams<ListOrdersWithCollectiblesRequest>;\n\nexport async function fetchListItemsOrdersForCollection(\n\tparams: WithRequired<\n\t\tListItemsOrdersForCollectionQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n\tpage: Page,\n): Promise<ListOrdersWithCollectiblesResponse> {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\treturn await marketplaceClient.listOrdersWithCollectibles({\n\t\t...apiParams,\n\t\tpage,\n\t});\n}\n\nexport function getListItemsOrdersForCollectionQueryKey(\n\tparams: ListItemsOrdersForCollectionQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcollectionAddress: params.collectionAddress,\n\t\tside: params.side,\n\t\tfilter: params.filter,\n\t};\n\n\treturn createCollectionQueryKey('market-items', apiArgs);\n}\n\nexport function listItemsOrdersForCollectionQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListItemsOrdersForCollectionQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildInfiniteQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListItemsOrdersForCollectionQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'side',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListItemsOrdersForCollection,\n\t\t\tgetPageInfo: (response) => response.page,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { GetCountOfAllOrdersRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchCountItemsOrdersForCollectionParams =\n\tGetCountOfAllOrdersRequest;\n\nexport type CountItemsOrdersForCollectionQueryOptions =\n\tSdkQueryParams<FetchCountItemsOrdersForCollectionParams>;\n\n/**\n * Fetches count of orders for a collection from the marketplace API\n */\nexport async function fetchCountItemsOrdersForCollection(\n\tparams: WithRequired<\n\t\tCountItemsOrdersForCollectionQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst client = getMarketplaceClient(config);\n\tconst result = await client.getCountOfAllOrders(apiParams);\n\treturn result.count;\n}\n\nexport function getCountItemsOrdersForCollectionQueryKey(\n\tparams: CountItemsOrdersForCollectionQueryOptions,\n) {\n\treturn [\n\t\t'collection',\n\t\t'market-items-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tside: params.side,\n\t\t},\n\t] as const;\n}\n\nexport function countItemsOrdersForCollectionQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCountItemsOrdersForCollectionQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCountItemsOrdersForCollectionQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'config',\n\t\t\t\t'side',\n\t\t\t] as const,\n\t\t\tfetcher: fetchCountItemsOrdersForCollection,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import { isAddress } from 'viem';\nimport type {\n\tListOrdersWithCollectiblesRequest,\n\tListOrdersWithCollectiblesResponse,\n\tWithOptionalParams,\n} from '../../_internal';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchListItemsOrdersForCollectionPaginatedParams = Omit<\n\tListOrdersWithCollectiblesRequest,\n\t'page'\n> & {\n\tpage?: number;\n\tpageSize?: number;\n};\n\nexport type ListItemsOrdersForCollectionPaginatedQueryOptions =\n\tSdkQueryParams<FetchListItemsOrdersForCollectionPaginatedParams>;\n\n/**\n * Fetches a list of items orders for a collection with pagination support from the Marketplace API\n */\nexport async function fetchListItemsOrdersForCollectionPaginated(\n\tparams: WithRequired<\n\t\tListItemsOrdersForCollectionPaginatedQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n): Promise<ListOrdersWithCollectiblesResponse> {\n\tconst {\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tconfig,\n\t\tpage = 1,\n\t\tpageSize = 30,\n\t\t...additionalApiParams\n\t} = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\treturn await marketplaceClient.listOrdersWithCollectibles({\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tpage: {\n\t\t\tpage,\n\t\t\tpageSize,\n\t\t},\n\t\t...additionalApiParams,\n\t});\n}\n\nexport function getListItemsOrdersForCollectionPaginatedQueryKey(\n\tparams: ListItemsOrdersForCollectionPaginatedQueryOptions,\n) {\n\treturn ['order', 'collection-items-paginated', params] as const;\n}\n\nexport function listItemsOrdersForCollectionPaginatedQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListItemsOrdersForCollectionPaginatedQueryOptions,\n\t\t\t'collectionAddress' | 'chainId' | 'config' | 'side'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListItemsOrdersForCollectionPaginatedQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'collectionAddress',\n\t\t\t\t'chainId',\n\t\t\t\t'config',\n\t\t\t\t'side',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListItemsOrdersForCollectionPaginated,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { GetContractInfoSdkArgs } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMetadataClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectionQueryKey } from './queryKeys';\n\nexport type FetchCollectionParams = GetContractInfoSdkArgs;\n\nexport type CollectionQueryOptions = SdkQueryParams<FetchCollectionParams>;\n\n/**\n * Fetches collection information from the metadata API\n */\nexport async function fetchCollection(\n\tparams: WithRequired<\n\t\tCollectionQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n) {\n\tconst { chainId, collectionAddress, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\t// API wrapper handles collectionAddress â†’ contractAddress transformation\n\tconst result = await metadataClient.getContractInfo({\n\t\tchainId,\n\t\tcollectionAddress,\n\t});\n\treturn result.contractInfo;\n}\n\nexport function getCollectionQueryKey(params: CollectionQueryOptions) {\n\treturn createCollectionQueryKey('metadata', {\n\t\tchainId: params.chainId,\n\t\tcontractAddress: params.collectionAddress,\n\t});\n}\n\nexport function collectionQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCollectionQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCollectionQueryKey,\n\t\t\trequiredParams: ['chainId', 'collectionAddress', 'config'] as const,\n\t\t\tfetcher: fetchCollection,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n"],"mappings":"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"}