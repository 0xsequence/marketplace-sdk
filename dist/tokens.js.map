{"version":3,"file":"tokens.js","names":["apiArgs: GetTokenSuppliesArgs"],"sources":["../src/react/queries/tokens/getTokenRanges.ts","../src/react/queries/tokens/listBalances.ts","../src/react/queries/tokens/listTokenMetadata.ts","../src/react/queries/tokens/searchTokenMetadata.ts","../src/react/queries/tokens/tokenSupplies.ts"],"sourcesContent":["import type { GetTokenIDRangesReturn } from '@0xsequence/indexer';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { SdkConfig } from '../../../types';\nimport {\n\tgetIndexerClient,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../../_internal';\nimport type { StandardQueryOptions } from '../../types/query';\n\nexport interface FetchGetTokenRangesParams {\n\tchainId: number;\n\tcollectionAddress: Address;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches token ID ranges for a collection from the Indexer API\n */\nexport async function fetchGetTokenRanges(\n\tparams: FetchGetTokenRangesParams,\n): Promise<GetTokenIDRangesReturn> {\n\tconst { chainId, collectionAddress, config } = params;\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tconst response = await indexerClient.getTokenIDRanges({\n\t\tcontractAddress: collectionAddress,\n\t});\n\n\tif (!response) {\n\t\tthrow new Error('Failed to fetch token ranges');\n\t}\n\n\treturn response;\n}\n\nexport type GetTokenRangesQueryOptions =\n\tValuesOptional<FetchGetTokenRangesParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function getTokenRangesQueryKey(params: GetTokenRangesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId!,\n\t\tcontractAddress: params.collectionAddress!,\n\t};\n\n\treturn [...tokenKeys.ranges, apiArgs] as const;\n}\n\nexport function getTokenRangesQueryOptions(params: GetTokenRangesQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: getTokenRangesQueryKey(params),\n\t\tqueryFn: () =>\n\t\t\tfetchGetTokenRanges({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { GetTokenBalancesReturn, Page } from '@0xsequence/indexer';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address, Hex } from 'viem';\nimport type { SdkConfig } from '../../../types';\nimport { balanceQueries, getIndexerClient } from '../../_internal';\n\nexport type UseListBalancesArgs = {\n\tchainId: number;\n\taccountAddress?: Address;\n\tcontractAddress?: Address;\n\ttokenId?: string;\n\tincludeMetadata?: boolean;\n\tmetadataOptions?: {\n\t\tverifiedOnly?: boolean;\n\t\tunverifiedOnly?: boolean;\n\t\tincludeContracts?: Hex[];\n\t};\n\tincludeCollectionTokens?: boolean;\n\tpage?: Page;\n\t//TODO: More options\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n};\n\nexport async function fetchBalances(\n\targs: UseListBalancesArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<GetTokenBalancesReturn> {\n\tconst indexerClient = getIndexerClient(args.chainId, config);\n\treturn indexerClient.getTokenBalances({\n\t\t...args,\n\t\ttokenID: args.tokenId,\n\t\tpage: page,\n\t});\n}\n\nexport function getListBalancesQueryKey(args: UseListBalancesArgs) {\n\tconst apiArgs = {\n\t\tchainId: args.chainId,\n\t\taccountAddress: args.accountAddress,\n\t\tcontractAddress: args.contractAddress,\n\t\ttokenID: args.tokenId,\n\t\tincludeMetadata: args.includeMetadata,\n\t\tmetadataOptions: args.metadataOptions,\n\t\tincludeCollectionTokens: args.includeCollectionTokens,\n\t};\n\n\treturn [...balanceQueries.lists, apiArgs] as const;\n}\n\n/**\n * Creates a tanstack infinite query options object for the balances query\n *\n * @param args - The query arguments\n * @param config - SDK configuration\n * @returns Query options configuration\n */\nexport function listBalancesOptions(\n\targs: UseListBalancesArgs,\n\tconfig: SdkConfig,\n) {\n\treturn infiniteQueryOptions({\n\t\t...args.query,\n\t\tqueryKey: getListBalancesQueryKey(args),\n\t\tqueryFn: ({ pageParam }) => fetchBalances(args, config, pageParam),\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) => lastPage.page.after,\n\t});\n}\n","import type { GetTokenMetadataArgs } from '@0xsequence/metadata';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../../types';\nimport {\n\tgetMetadataClient,\n\ttype QueryKeyArgs,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../../_internal';\nimport type { StandardQueryOptions } from '../../types/query';\n\nexport interface FetchListTokenMetadataParams {\n\tchainId: number;\n\tcontractAddress: string;\n\ttokenIds: string[];\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches token metadata from the metadata API\n */\nexport async function fetchListTokenMetadata(\n\tparams: FetchListTokenMetadataParams,\n) {\n\tconst { chainId, contractAddress, tokenIds, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst response = await metadataClient.getTokenMetadata({\n\t\tchainID: chainId.toString(),\n\t\tcontractAddress: contractAddress,\n\t\ttokenIDs: tokenIds,\n\t});\n\n\treturn response.tokenMetadata;\n}\n\nexport type ListTokenMetadataQueryOptions =\n\tValuesOptional<FetchListTokenMetadataParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function getListTokenMetadataQueryKey(\n\tparams: ListTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainID: String(params.chainId),\n\t\tcontractAddress: params.contractAddress,\n\t\ttokenIDs: params.tokenIds,\n\t} satisfies QueryKeyArgs<GetTokenMetadataArgs>;\n\n\treturn [...tokenKeys.metadata, apiArgs] as const;\n}\n\nexport function listTokenMetadataQueryOptions(\n\tparams: ListTokenMetadataQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.contractAddress &&\n\t\t\tparams.tokenIds?.length &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: getListTokenMetadataQueryKey(params),\n\t\tqueryFn: () =>\n\t\t\tfetchListTokenMetadata({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcontractAddress: params.contractAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\ttokenIds: params.tokenIds!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type {\n\tFilter,\n\tPage,\n\tSearchTokenMetadataArgs,\n\tSearchTokenMetadataReturn,\n} from '@0xsequence/metadata';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../../types';\nimport {\n\tgetMetadataClient,\n\ttype QueryKeyArgs,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../../_internal';\nimport type { StandardQueryOptions } from '../../types/query';\n\nexport interface FetchSearchTokenMetadataParams {\n\tchainId: number;\n\tcollectionAddress: string;\n\tfilter?: Filter;\n\tpage?: Page;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches token metadata from the metadata API using search filters\n */\nexport async function fetchSearchTokenMetadata(\n\tparams: FetchSearchTokenMetadataParams,\n): Promise<SearchTokenMetadataReturn> {\n\tconst { chainId, collectionAddress, filter, page, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst response = await metadataClient.searchTokenMetadata({\n\t\tchainID: chainId.toString(),\n\t\tcontractAddress: collectionAddress,\n\t\tfilter: filter ?? {},\n\t\tpage,\n\t});\n\n\treturn {\n\t\ttokenMetadata: response.tokenMetadata,\n\t\tpage: response.page,\n\t};\n}\n\nexport type SearchTokenMetadataQueryOptions =\n\tValuesOptional<FetchSearchTokenMetadataParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function getSearchTokenMetadataQueryKey(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainID: String(params.chainId!),\n\t\tcontractAddress: params.collectionAddress!,\n\t\tfilter: params.filter,\n\t} satisfies QueryKeyArgs<Omit<SearchTokenMetadataArgs, 'page'>>;\n\n\treturn [...tokenKeys.metadata, 'search', apiArgs] as const;\n}\n\nexport function searchTokenMetadataQueryOptions(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam = { page: 1, pageSize: 30 };\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getSearchTokenMetadataQueryKey(params),\n\t\tqueryFn: ({ pageParam = initialPageParam }) =>\n\t\t\tfetchSearchTokenMetadata({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tfilter: params.filter!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t\tpage: pageParam,\n\t\t\t}),\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) => {\n\t\t\tif (!lastPage.page?.more) return undefined;\n\t\t\treturn {\n\t\t\t\tpage: (lastPage.page.page || 1) + 1,\n\t\t\t\tpageSize: lastPage.page.pageSize || 20,\n\t\t\t};\n\t\t},\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { GetTokenSuppliesArgs, Page } from '@0xsequence/indexer';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../../types';\nimport {\n\tgetIndexerClient,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../../_internal';\nimport type { StandardInfiniteQueryOptions } from '../../types/query';\n\nexport interface FetchTokenSuppliesParams\n\textends Omit<GetTokenSuppliesArgs, 'contractAddress'> {\n\tchainId: number;\n\tcollectionAddress: string;\n\tconfig: SdkConfig;\n\tpage?: Page;\n}\n\n/**\n * Fetches token supplies with support for indexer API\n */\nexport async function fetchTokenSupplies(params: FetchTokenSuppliesParams) {\n\tconst { chainId, collectionAddress, config, ...rest } = params;\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tconst apiArgs: GetTokenSuppliesArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\t...rest,\n\t};\n\n\tconst result = await indexerClient.getTokenSupplies(apiArgs);\n\treturn result;\n}\n\nexport type TokenSuppliesQueryOptions =\n\tValuesOptional<FetchTokenSuppliesParams> & {\n\t\tquery?: StandardInfiniteQueryOptions;\n\t};\n\nexport function getTokenSuppliesQueryKey(params: TokenSuppliesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId!,\n\t\tcontractAddress: params.collectionAddress!,\n\t\tincludeMetadata: params.includeMetadata,\n\t\tmetadataOptions: params.metadataOptions,\n\t};\n\n\treturn [...tokenKeys.supplies, apiArgs] as const;\n}\n\nexport function tokenSuppliesQueryOptions(params: TokenSuppliesQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam = { page: 1, pageSize: 30 } as Page;\n\n\tconst queryFn = async ({ pageParam = initialPageParam }) =>\n\t\tfetchTokenSupplies({\n\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\tchainId: params.chainId!,\n\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\tconfig: params.config!,\n\t\t\tincludeMetadata: params.includeMetadata,\n\t\t\tmetadataOptions: params.metadataOptions,\n\t\t\tpage: pageParam,\n\t\t});\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getTokenSuppliesQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n"],"mappings":"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"}