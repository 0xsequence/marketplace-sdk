{"version":3,"file":"utils2.js","names":[],"sources":["../src/react/utils/normalize-attributes.ts","../src/react/utils/normalize-properties.ts","../src/react/utils/waitForTransactionReceipt.ts"],"sourcesContent":["import type { TokenMetadata } from '../../../../api/src/adapters/marketplace';\n\nexport type StandardizedAttribute = {\n\tname: string;\n\tvalue: string;\n\tdisplay_type?: string | null | undefined;\n};\n\ntype StandardizedAttributes = Record<string, StandardizedAttribute>;\n\ntype AttributeCandidate = {\n\tname?: unknown;\n\tvalue?: unknown;\n\ttrait_type?: unknown;\n\tdisplay_type?: unknown;\n};\n\nfunction isValidAttributePair(candidate: AttributeCandidate): candidate is\n\t| { name: string; value: string | number; display_type?: string | null }\n\t| {\n\t\t\ttrait_type: string;\n\t\t\tvalue: string | number;\n\t\t\tdisplay_type?: string | null;\n\t  } {\n\treturn (\n\t\t(typeof candidate.name === 'string' ||\n\t\t\ttypeof candidate.trait_type === 'string') &&\n\t\t(typeof candidate.value === 'string' ||\n\t\t\ttypeof candidate.value === 'number') &&\n\t\t(candidate.display_type === undefined ||\n\t\t\tcandidate.display_type === null ||\n\t\t\ttypeof candidate.display_type === 'string')\n\t);\n}\n\n/**\n * Processes token metadata attributes into a standardized format\n * Handles both array-based attributes (OpenSea standard) and object-based attributes\n * @param attributes - Token attributes from metadata\n * @returns Object with standardized attributes containing name, value, and optional display_type\n */\nexport function processAttributes(\n\tattributes: TokenMetadata['attributes'],\n): StandardizedAttributes {\n\t// Handle array-based attributes (e.g., OpenSea standard)\n\tif (Array.isArray(attributes)) {\n\t\treturn Object.fromEntries(\n\t\t\tattributes\n\t\t\t\t// Filter out non-object attributes\n\t\t\t\t.filter(\n\t\t\t\t\t(attr): attr is AttributeCandidate =>\n\t\t\t\t\t\tattr !== null && typeof attr === 'object',\n\t\t\t\t)\n\t\t\t\t// Ensure attributes have valid name/value pairs\n\t\t\t\t.filter(isValidAttributePair)\n\t\t\t\t// Convert to [name, StandardizedAttribute] pairs\n\t\t\t\t.map((attr) => {\n\t\t\t\t\tconst name = 'name' in attr ? attr.name : attr.trait_type;\n\t\t\t\t\treturn [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tvalue: String(attr.value),\n\t\t\t\t\t\t\tdisplay_type: attr.display_type,\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t}),\n\t\t);\n\t}\n\n\t// Handle object-based attributes\n\tif (attributes && typeof attributes === 'object') {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(attributes).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue:\n\t\t\t\t\t\ttypeof value === 'object' && value !== null\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: String(value),\n\t\t\t\t\tdisplay_type: undefined,\n\t\t\t\t},\n\t\t\t]),\n\t\t);\n\t}\n\n\treturn {};\n}\n","import type { TokenMetadata } from '../../../../api/src/adapters/marketplace';\n\nexport type StandardizedProperty = {\n\tname: string;\n\tvalue: string;\n};\ntype StandardizedProperties = Record<string, StandardizedProperty>;\n\n/**\n * Processes token metadata properties into a standardized format\n * @param properties - Token properties from metadata\n * @returns Object with standardized properties containing name and value\n */\nexport function processProperties(\n\tproperties: TokenMetadata['properties'],\n): StandardizedProperties {\n\t// If properties is invalid or missing, return empty object\n\tif (\n\t\t!properties ||\n\t\ttypeof properties !== 'object' ||\n\t\tArray.isArray(properties) ||\n\t\tObject.keys(properties).length === 0\n\t) {\n\t\treturn {};\n\t}\n\n\t// Process properties into standardized format\n\treturn Object.fromEntries(\n\t\tObject.entries(properties).map(([key, value]) => [\n\t\t\tkey,\n\t\t\t{\n\t\t\t\tname: key,\n\t\t\t\tvalue:\n\t\t\t\t\ttypeof value === 'object' && value !== null\n\t\t\t\t\t\t? // Handle nested objects with .value property or convert to JSON\n\t\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\t\tconst nestedValue = (value as { value?: unknown }).value;\n\t\t\t\t\t\t\t\tif (nestedValue !== undefined) {\n\t\t\t\t\t\t\t\t\tif (typeof nestedValue === 'object' && nestedValue !== null) {\n\t\t\t\t\t\t\t\t\t\treturn JSON.stringify(nestedValue);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\ttypeof nestedValue === 'string' ||\n\t\t\t\t\t\t\t\t\t\ttypeof nestedValue === 'number' ||\n\t\t\t\t\t\t\t\t\t\ttypeof nestedValue === 'boolean'\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn String(nestedValue);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Handle other primitive types (bigint, symbol, etc.)\n\t\t\t\t\t\t\t\t\treturn JSON.stringify(nestedValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t: value !== null && value !== undefined\n\t\t\t\t\t\t\t? String(value)\n\t\t\t\t\t\t\t: '',\n\t\t\t},\n\t\t]),\n\t);\n}\n","import type { Indexer } from '@0xsequence/api-client';\nimport { type Hex, TransactionReceiptNotFoundError } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport { getIndexerClient } from '../_internal/api';\n\nconst MAX_RETRIES = 3;\nconst MAX_BLOCK_WAIT = 30;\n\nexport const waitForTransactionReceipt = async ({\n\ttxHash,\n\tchainId,\n\tsdkConfig,\n\tmaxBlockWait = MAX_BLOCK_WAIT,\n}: {\n\ttxHash: Hex;\n\tchainId: number;\n\tsdkConfig: SdkConfig;\n\tmaxBlockWait?: number;\n}): Promise<Indexer.TransactionReceipt> => {\n\tconst indexer = getIndexerClient(chainId, sdkConfig);\n\tlet retries = 0;\n\n\twhile (retries < MAX_RETRIES) {\n\t\ttry {\n\t\t\tconst result = await indexer.fetchTransactionReceipt({\n\t\t\t\ttxnHash: txHash,\n\t\t\t\tmaxBlockWait,\n\t\t\t});\n\t\t\treturn result.receipt;\n\t\t} catch (error) {\n\t\t\tretries++;\n\t\t\tconsole.error(\n\t\t\t\t`Failed to fetch transaction receipt (attempt ${retries}/${MAX_RETRIES}):`,\n\t\t\t\terror,\n\t\t\t);\n\t\t\tif (retries >= MAX_RETRIES) {\n\t\t\t\tthrow TransactionReceiptNotFoundError;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow TransactionReceiptNotFoundError;\n};\n"],"mappings":";;;;AAiBA,SAAS,qBAAqB,WAMzB;AACJ,SACE,OAAO,UAAU,SAAS,YAC1B,OAAO,UAAU,eAAe,cAChC,OAAO,UAAU,UAAU,YAC3B,OAAO,UAAU,UAAU,cAC3B,UAAU,iBAAiB,UAC3B,UAAU,iBAAiB,QAC3B,OAAO,UAAU,iBAAiB;;;;;;;;AAUrC,SAAgB,kBACf,YACyB;AAEzB,KAAI,MAAM,QAAQ,WAAW,CAC5B,QAAO,OAAO,YACb,WAEE,QACC,SACA,SAAS,QAAQ,OAAO,SAAS,SAClC,CAEA,OAAO,qBAAqB,CAE5B,KAAK,SAAS;EACd,MAAM,OAAO,UAAU,OAAO,KAAK,OAAO,KAAK;AAC/C,SAAO,CACN,MACA;GACC;GACA,OAAO,OAAO,KAAK,MAAM;GACzB,cAAc,KAAK;GACnB,CACD;GACA,CACH;AAIF,KAAI,cAAc,OAAO,eAAe,SACvC,QAAO,OAAO,YACb,OAAO,QAAQ,WAAW,CAAC,KAAK,CAAC,KAAK,WAAW,CAChD,KACA;EACC,MAAM;EACN,OACC,OAAO,UAAU,YAAY,UAAU,OACpC,KAAK,UAAU,MAAM,GACrB,OAAO,MAAM;EACjB,cAAc;EACd,CACD,CAAC,CACF;AAGF,QAAO,EAAE;;;;;;;;;;AC1EV,SAAgB,kBACf,YACyB;AAEzB,KACC,CAAC,cACD,OAAO,eAAe,YACtB,MAAM,QAAQ,WAAW,IACzB,OAAO,KAAK,WAAW,CAAC,WAAW,EAEnC,QAAO,EAAE;AAIV,QAAO,OAAO,YACb,OAAO,QAAQ,WAAW,CAAC,KAAK,CAAC,KAAK,WAAW,CAChD,KACA;EACC,MAAM;EACN,OACC,OAAO,UAAU,YAAY,UAAU,cAE9B;GACN,MAAM,cAAe,MAA8B;AACnD,OAAI,gBAAgB,QAAW;AAC9B,QAAI,OAAO,gBAAgB,YAAY,gBAAgB,KACtD,QAAO,KAAK,UAAU,YAAY;AAEnC,QACC,OAAO,gBAAgB,YACvB,OAAO,gBAAgB,YACvB,OAAO,gBAAgB,UAEvB,QAAO,OAAO,YAAY;AAG3B,WAAO,KAAK,UAAU,YAAY;;AAEnC,UAAO,KAAK,UAAU,MAAM;MACzB,GACH,UAAU,QAAQ,UAAU,SAC3B,OAAO,MAAM,GACb;EACL,CACD,CAAC,CACF;;;;;ACrDF,MAAM,cAAc;AACpB,MAAM,iBAAiB;AAEvB,MAAa,4BAA4B,OAAO,EAC/C,QACA,SACA,WACA,eAAe,qBAM2B;CAC1C,MAAM,UAAU,iBAAiB,SAAS,UAAU;CACpD,IAAI,UAAU;AAEd,QAAO,UAAU,YAChB,KAAI;AAKH,UAJe,MAAM,QAAQ,wBAAwB;GACpD,SAAS;GACT;GACA,CAAC,EACY;UACN,OAAO;AACf;AACA,UAAQ,MACP,gDAAgD,QAAQ,GAAG,YAAY,KACvE,MACA;AACD,MAAI,WAAW,YACd,OAAM;;AAKT,OAAM"}