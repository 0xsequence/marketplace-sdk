{"version":3,"file":"inventory.js","names":[],"sources":["../src/react/queries/inventory/inventory.ts"],"sourcesContent":["import type {\n\tChainId,\n\tGetUserCollectionBalancesRequest,\n\tIndexerTokenMetadata,\n\tIndexerTokenBalance as TokenBalance,\n} from '@0xsequence/api-client';\nimport { ContractType, MetadataStatus } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport type { Page } from '../../../types';\nimport { findMarketCollection } from '../../../utils';\nimport {\n\tbuildQueryOptions,\n\tgetQueryClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { tokenBalancesOptions } from '../collectible/token-balances';\nimport { fetchMarketplaceConfig } from '../marketplace/config';\n\nexport type FetchInventoryParams = GetUserCollectionBalancesRequest & {\n\tchainId: ChainId;\n\tincludeNonTradable?: boolean;\n\tpage?: number;\n\tpageSize?: number;\n};\n\nexport type CollectibleMetadata = Pick<\n\tIndexerTokenMetadata,\n\t| 'tokenId'\n\t| 'attributes'\n\t| 'image'\n\t| 'name'\n\t| 'description'\n\t| 'video'\n\t| 'audio'\n> & {\n\tstatus: MetadataStatus;\n};\n\nexport type CollectibleWithBalance = Pick<TokenBalance, 'contractInfo'> & {\n\tmetadata: CollectibleMetadata;\n\tbalance: string;\n\tcontractType: ContractType.ERC1155 | ContractType.ERC721;\n};\n\nexport type CollectiblesResponse = {\n\tcollectibles: CollectibleWithBalance[];\n\tpage: Page;\n\tisTradable: boolean;\n};\n\n/**\n * Validates if a contract type is a valid collectible type (ERC721 or ERC1155)\n */\nfunction isCollectibleContractType(\n\tcontractType: string,\n): contractType is ContractType.ERC721 | ContractType.ERC1155 {\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- Intentional type guard comparing string with enum\n\treturn (\n\t\tcontractType === ContractType.ERC721 ||\n\t\tcontractType === ContractType.ERC1155\n\t);\n}\n\n/**\n * Transforms an Indexer token balance into a collectible with metadata\n * @throws Error if token is not a valid collectible type (ERC721/ERC1155)\n */\nfunction collectibleFromTokenBalance(\n\ttoken: TokenBalance,\n): CollectibleWithBalance {\n\treturn {\n\t\tmetadata: {\n\t\t\ttokenId: token.tokenId ?? 0n,\n\t\t\tattributes: token.tokenMetadata?.attributes ?? [],\n\t\t\timage: token.tokenMetadata?.image,\n\t\t\tname: token.tokenMetadata?.name ?? '',\n\t\t\tdescription: token.tokenMetadata?.description,\n\t\t\tvideo: token.tokenMetadata?.video,\n\t\t\taudio: token.tokenMetadata?.audio,\n\t\t\tstatus: MetadataStatus.AVAILABLE,\n\t\t},\n\t\tcontractInfo: token.contractInfo,\n\t\tcontractType: token.contractType as\n\t\t\t| ContractType.ERC721\n\t\t\t| ContractType.ERC1155,\n\t\tbalance: token.balance.toString(),\n\t};\n}\n\nasync function fetchIndexerTokens(\n\tparams: WithRequired<\n\t\tInventoryQueryOptions,\n\t\t'chainId' | 'userAddress' | 'collectionAddress' | 'config'\n\t>,\n): Promise<{ collectibles: CollectibleWithBalance[] }> {\n\tconst { chainId, userAddress, collectionAddress, config } = params;\n\tconst queryClient = getQueryClient();\n\tconst balances = await queryClient.fetchQuery(\n\t\ttokenBalancesOptions({\n\t\t\tcollectionAddress,\n\t\t\tuserAddress,\n\t\t\tchainId,\n\t\t\tincludeMetadata: true,\n\t\t\tconfig,\n\t\t}),\n\t);\n\n\tconst collectibles = balances\n\t\t.filter((balance) => isCollectibleContractType(balance.contractType))\n\t\t.map((balance) => collectibleFromTokenBalance(balance));\n\n\treturn {\n\t\tcollectibles,\n\t};\n}\n\nexport type InventoryQueryOptions = SdkQueryParams<\n\tFetchInventoryParams,\n\t{\n\t\tenabled?: boolean;\n\t}\n>;\n\n/**\n * @deprecated Use InventoryQueryOptions instead\n */\nexport type UseInventoryArgs = Omit<InventoryQueryOptions, 'config'> & {\n\tconfig?: InventoryQueryOptions['config'];\n};\n\nexport async function fetchInventory(\n\tparams: WithRequired<\n\t\tInventoryQueryOptions,\n\t\t'userAddress' | 'collectionAddress' | 'chainId' | 'config'\n\t>,\n): Promise<CollectiblesResponse> {\n\tconst {\n\t\tuserAddress,\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tconfig,\n\t\tpage = 1,\n\t\tpageSize = 30,\n\t} = params;\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\n\tconst marketCollections = marketplaceConfig?.market.collections || [];\n\n\tconst isMarketCollection = !!findMarketCollection(\n\t\tmarketCollections,\n\t\tcollectionAddress,\n\t\tchainId,\n\t);\n\n\t// Determine if this collection is tradable (market collection vs shop collection)\n\tconst isTradable = isMarketCollection;\n\n\t// Fetch collectibles from indexer\n\tconst { collectibles } = await fetchIndexerTokens({\n\t\tchainId,\n\t\tuserAddress,\n\t\tcollectionAddress,\n\t\tconfig,\n\t});\n\n\treturn {\n\t\tcollectibles,\n\t\tpage: {\n\t\t\tpage,\n\t\t\tpageSize,\n\t\t},\n\t\tisTradable,\n\t};\n}\n\nexport function getInventoryQueryKey(params: InventoryQueryOptions) {\n\treturn [\n\t\t'inventory',\n\t\tparams.userAddress,\n\t\tparams.collectionAddress,\n\t\tparams.chainId,\n\t\tparams.page ?? 1,\n\t\tparams.pageSize ?? 30,\n\t] as const;\n}\n\nexport function inventoryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tInventoryQueryOptions,\n\t\t\t'userAddress' | 'collectionAddress' | 'chainId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getInventoryQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'userAddress',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'chainId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchInventory,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n"],"mappings":";;;;;;;;;;;;AAuDA,SAAS,0BACR,cAC6D;AAE7D,QACC,iBAAiB,aAAa,UAC9B,iBAAiB,aAAa;;;;;;AAQhC,SAAS,4BACR,OACyB;AACzB,QAAO;EACN,UAAU;GACT,SAAS,MAAM,WAAW;GAC1B,YAAY,MAAM,eAAe,cAAc,EAAE;GACjD,OAAO,MAAM,eAAe;GAC5B,MAAM,MAAM,eAAe,QAAQ;GACnC,aAAa,MAAM,eAAe;GAClC,OAAO,MAAM,eAAe;GAC5B,OAAO,MAAM,eAAe;GAC5B,QAAQ,eAAe;GACvB;EACD,cAAc,MAAM;EACpB,cAAc,MAAM;EAGpB,SAAS,MAAM,QAAQ,UAAU;EACjC;;AAGF,eAAe,mBACd,QAIsD;CACtD,MAAM,EAAE,SAAS,aAAa,mBAAmB,WAAW;AAgB5D,QAAO,EACN,eAfgB,MADG,gBAAgB,CACD,WAClC,qBAAqB;EACpB;EACA;EACA;EACA,iBAAiB;EACjB;EACA,CAAC,CACF,EAGC,QAAQ,YAAY,0BAA0B,QAAQ,aAAa,CAAC,CACpE,KAAK,YAAY,4BAA4B,QAAQ,CAAC,EAIvD;;AAiBF,eAAsB,eACrB,QAIgC;CAChC,MAAM,EACL,aACA,mBACA,SACA,QACA,OAAO,GACP,WAAW,OACR;CAYJ,MAAM,aAPqB,CAAC,CAAC,sBAJH,MAAM,uBAAuB,EAAE,QAAQ,CAAC,GAErB,OAAO,eAAe,EAAE,EAIpE,mBACA,QACA;CAMD,MAAM,EAAE,iBAAiB,MAAM,mBAAmB;EACjD;EACA;EACA;EACA;EACA,CAAC;AAEF,QAAO;EACN;EACA,MAAM;GACL;GACA;GACA;EACD;EACA;;AAGF,SAAgB,qBAAqB,QAA+B;AACnE,QAAO;EACN;EACA,OAAO;EACP,OAAO;EACP,OAAO;EACP,OAAO,QAAQ;EACf,OAAO,YAAY;EACnB;;AAGF,SAAgB,iBACf,QAMC;AACD,QAAO,kBACN;EACC,aAAa;EACb,gBAAgB;GACf;GACA;GACA;GACA;GACA;EACD,SAAS;EACT,mBAAmB,MAClB,CAAC,CAAC,EAAE,qBAAqB,UAAU,EAAE,kBAAkB;EACxD,EACD,OACA"}