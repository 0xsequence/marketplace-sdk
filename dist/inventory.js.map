{"version":3,"file":"inventory.js","names":[],"sources":["../src/react/queries/inventory/inventory.ts"],"sourcesContent":["import type { ContractInfo, TokenBalance } from '@0xsequence/indexer';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { Page, SdkConfig } from '../../../types';\nimport { compareAddress } from '../../../utils';\nimport {\n\ttype ContractType,\n\tgetQueryClient,\n\tMetadataStatus,\n} from '../../_internal';\nimport { tokenBalancesOptions } from '../collectibles/tokenBalances';\nimport { fetchMarketplaceConfig } from '../market/marketplaceConfig';\n\nexport interface UseInventoryArgs {\n\taccountAddress: Address;\n\tcollectionAddress: Address;\n\tchainId: number;\n\tincludeNonTradable?: boolean;\n\tquery?: {\n\t\tenabled?: boolean;\n\t\tpage?: number;\n\t\tpageSize?: number;\n\t};\n}\n\ntype GetInventoryArgs = Omit<UseInventoryArgs, 'query'>;\n\ninterface CollectibleWithBalance {\n\tmetadata: {\n\t\ttokenId: string;\n\t\tattributes: Array<any>;\n\t\timage?: string;\n\t\tname: string;\n\t\tdescription?: string;\n\t\tvideo?: string;\n\t\taudio?: string;\n\t\tstatus: MetadataStatus;\n\t};\n\tbalance: string;\n\tcontractInfo?: ContractInfo;\n\tcontractType: ContractType.ERC1155 | ContractType.ERC721;\n}\n\nexport interface CollectiblesResponse {\n\tcollectibles: CollectibleWithBalance[];\n\tpage: Page;\n\tisTradable: boolean;\n}\n\nfunction collectibleFromTokenBalance(\n\ttoken: TokenBalance,\n): CollectibleWithBalance {\n\treturn {\n\t\tmetadata: {\n\t\t\ttokenId: token.tokenID ?? '',\n\t\t\tattributes: token.tokenMetadata?.attributes ?? [],\n\t\t\timage: token.tokenMetadata?.image,\n\t\t\tname: token.tokenMetadata?.name ?? '',\n\t\t\tdescription: token.tokenMetadata?.description,\n\t\t\tvideo: token.tokenMetadata?.video,\n\t\t\taudio: token.tokenMetadata?.audio,\n\t\t\tstatus: MetadataStatus.AVAILABLE,\n\t\t},\n\t\tcontractInfo: token.contractInfo,\n\t\tcontractType: token.contractType as unknown as\n\t\t\t| ContractType.ERC1155\n\t\t\t| ContractType.ERC721,\n\t\tbalance: token.balance,\n\t};\n}\n\nasync function fetchIndexerTokens(\n\tchainId: number,\n\taccountAddress: Address,\n\tcollectionAddress: Address,\n\tconfig: SdkConfig,\n): Promise<{ collectibles: CollectibleWithBalance[] }> {\n\tconst queryClient = getQueryClient();\n\tconst balances = await queryClient.fetchQuery(\n\t\ttokenBalancesOptions(\n\t\t\t{\n\t\t\t\tcollectionAddress,\n\t\t\t\tuserAddress: accountAddress,\n\t\t\t\tchainId,\n\t\t\t\tincludeMetadata: true,\n\t\t\t},\n\t\t\tconfig,\n\t\t),\n\t);\n\n\tconst collectibles = balances.map((balance) =>\n\t\tcollectibleFromTokenBalance(balance),\n\t);\n\n\treturn {\n\t\tcollectibles,\n\t};\n}\n\nexport async function fetchInventory(\n\targs: GetInventoryArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<CollectiblesResponse> {\n\tconst { accountAddress, collectionAddress, chainId } = args;\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\n\tconst marketCollections = marketplaceConfig?.market.collections || [];\n\n\tconst isMarketCollection = marketCollections.some((collection) =>\n\t\tcompareAddress(collection.itemsAddress, collectionAddress),\n\t);\n\n\t// Determine if this collection is tradable (market collection vs shop collection)\n\tconst isTradable = isMarketCollection;\n\n\t// Fetch collectibles from indexer\n\tconst { collectibles } = await fetchIndexerTokens(\n\t\tchainId,\n\t\taccountAddress,\n\t\tcollectionAddress,\n\t\tconfig,\n\t);\n\n\treturn {\n\t\tcollectibles,\n\t\tpage: {\n\t\t\tpage: page.page,\n\t\t\tpageSize: page.pageSize,\n\t\t},\n\t\tisTradable,\n\t};\n}\n\nexport function inventoryOptions(args: UseInventoryArgs, config: SdkConfig) {\n\tconst enabledQuery = args.query?.enabled ?? true;\n\tconst enabled =\n\t\tenabledQuery && !!args.accountAddress && !!args.collectionAddress;\n\n\treturn queryOptions({\n\t\tqueryKey: [\n\t\t\t'inventory',\n\t\t\targs.accountAddress,\n\t\t\targs.collectionAddress,\n\t\t\targs.chainId,\n\t\t\targs.query?.page ?? 1,\n\t\t\targs.query?.pageSize ?? 30,\n\t\t],\n\t\tqueryFn: () =>\n\t\t\tfetchInventory(\n\t\t\t\t{\n\t\t\t\t\t...args,\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t\t{\n\t\t\t\t\tpage: args.query?.page ?? 1,\n\t\t\t\t\tpageSize: args.query?.pageSize ?? 30,\n\t\t\t\t},\n\t\t\t),\n\t\tenabled,\n\t});\n}\n"],"mappings":";;;;;;;;AAiDA,SAAS,4BACR,OACyB;AACzB,QAAO;EACN,UAAU;GACT,SAAS,MAAM,WAAW;GAC1B,YAAY,MAAM,eAAe,cAAc,EAAE;GACjD,OAAO,MAAM,eAAe;GAC5B,MAAM,MAAM,eAAe,QAAQ;GACnC,aAAa,MAAM,eAAe;GAClC,OAAO,MAAM,eAAe;GAC5B,OAAO,MAAM,eAAe;GAC5B,QAAQ,eAAe;GACvB;EACD,cAAc,MAAM;EACpB,cAAc,MAAM;EAGpB,SAAS,MAAM;EACf;;AAGF,eAAe,mBACd,SACA,gBACA,mBACA,QACsD;AAkBtD,QAAO,EACN,eAjBgB,MADG,gBAAgB,CACD,WAClC,qBACC;EACC;EACA,aAAa;EACb;EACA,iBAAiB;EACjB,EACD,OACA,CACD,EAE6B,KAAK,YAClC,4BAA4B,QAAQ,CACpC,EAIA;;AAGF,eAAsB,eACrB,MACA,QACA,MACgC;CAChC,MAAM,EAAE,gBAAgB,mBAAmB,YAAY;CAUvD,MAAM,eAToB,MAAM,uBAAuB,EAAE,QAAQ,CAAC,GAErB,OAAO,eAAe,EAAE,EAExB,MAAM,eAClD,eAAe,WAAW,cAAc,kBAAkB,CAC1D;CAMD,MAAM,EAAE,iBAAiB,MAAM,mBAC9B,SACA,gBACA,mBACA,OACA;AAED,QAAO;EACN;EACA,MAAM;GACL,MAAM,KAAK;GACX,UAAU,KAAK;GACf;EACD;EACA;;AAGF,SAAgB,iBAAiB,MAAwB,QAAmB;CAE3E,MAAM,WADe,KAAK,OAAO,WAAW,SAE3B,CAAC,CAAC,KAAK,kBAAkB,CAAC,CAAC,KAAK;AAEjD,QAAO,aAAa;EACnB,UAAU;GACT;GACA,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK,OAAO,QAAQ;GACpB,KAAK,OAAO,YAAY;GACxB;EACD,eACC,eACC,EACC,GAAG,MACH,EACD,QACA;GACC,MAAM,KAAK,OAAO,QAAQ;GAC1B,UAAU,KAAK,OAAO,YAAY;GAClC,CACD;EACF;EACA,CAAC"}