{"version":3,"file":"_internal.js","names":[],"sources":["../src/react/_internal/get-provider.ts","../src/react/_internal/query-builder.ts","../src/react/_internal/types.ts"],"sourcesContent":["export const PROVIDER_ID = 'sdk-provider';\n\nexport function getProviderEl() {\n\tif (!globalThis.document) return null;\n\treturn document.getElementById(PROVIDER_ID);\n}\n","import {\n\tinfiniteQueryOptions,\n\ttype QueryKey,\n\tqueryOptions,\n} from '@tanstack/react-query';\nimport type { Page, SdkConfig } from '../../types';\nimport type {\n\tStandardInfiniteQueryOptions,\n\tStandardQueryOptions,\n} from '../types/query';\n\nexport interface BaseQueryParams {\n\tconfig: SdkConfig;\n\tquery?: StandardQueryOptions;\n}\n\nexport interface BaseInfiniteQueryParams {\n\tconfig: SdkConfig;\n\tquery?: StandardInfiniteQueryOptions;\n}\n\nexport type RequiredKeys<T> = {\n\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t[K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n/**\n * Validates that a readonly tuple contains ALL required keys from a type\n * This ensures developers don't forget to list any required parameters\n *\n * How it works:\n * - Checks if every RequiredKey<TParams> exists in the provided tuple\n * - Returns the tuple type if valid, or 'never' if keys are missing\n * - Must be used with 'as const' for proper type inference\n *\n * Example:\n * type Keys = RequiredKeys<{a: string, b: number, c?: boolean}>; // 'a' | 'b'\n * type Valid = EnsureAllRequiredKeys<Params, ['a', 'b']>; // ✅ OK - returns ['a', 'b']\n * type Invalid = EnsureAllRequiredKeys<Params, ['a']>; // ❌ Error - returns 'never'\n */\nexport type EnsureAllRequiredKeys<\n\tTParams,\n\tTKeys extends ReadonlyArray<RequiredKeys<TParams>>,\n> = RequiredKeys<TParams> extends TKeys[number] ? TKeys : never;\n\nexport interface QueryBuilderConfig<TParams extends BaseQueryParams, TData> {\n\tgetQueryKey: (params: WithOptionalParams<TParams>) => QueryKey;\n\t/**\n\t * Type-safe: Must include ALL required keys from TParams\n\t * Example: ['chainId', 'collectionAddress', 'tokenId', 'config']\n\t */\n\trequiredParams: EnsureAllRequiredKeys<\n\t\tTParams,\n\t\tReadonlyArray<RequiredKeys<TParams>>\n\t>;\n\tfetcher: (params: TParams) => Promise<TData>;\n\t/**\n\t * Optional custom validation beyond truthiness checks\n\t * Example: (params) => (params.orders?.length ?? 0) > 0\n\t */\n\tcustomValidation?: (params: WithOptionalParams<TParams>) => boolean;\n}\n\nexport interface InfiniteQueryBuilderConfig<\n\tTParams extends BaseInfiniteQueryParams,\n\tTResponse,\n> {\n\tgetQueryKey: (params: WithOptionalInfiniteParams<TParams>) => QueryKey;\n\t/**\n\t * Type-safe: Must include ALL required keys from TParams\n\t * Example: ['chainId', 'collectionAddress', 'side', 'config']\n\t */\n\trequiredParams: EnsureAllRequiredKeys<\n\t\tTParams,\n\t\tReadonlyArray<RequiredKeys<TParams>>\n\t>;\n\tfetcher: (params: TParams, page: Page) => Promise<TResponse>;\n\tgetPageInfo: (response: TResponse) => Page | undefined;\n\t/**\n\t * Optional custom validation beyond truthiness checks\n\t * Example: (params) => (params.orders?.length ?? 0) > 0\n\t */\n\tcustomValidation?: (params: WithOptionalInfiniteParams<TParams>) => boolean;\n}\n\nexport type WithOptionalParams<T extends BaseQueryParams> = {\n\t[K in keyof T]?: T[K];\n} & Pick<T, 'config'> &\n\tPartial<Pick<T, 'query'>>;\n\nexport type WithOptionalInfiniteParams<T extends BaseInfiniteQueryParams> = {\n\t[K in keyof T]?: T[K];\n} & Pick<T, 'config'> &\n\tPartial<Pick<T, 'query'>>;\n\nexport function requiredParamsFor<TParams>() {\n\treturn <const TKeys extends ReadonlyArray<RequiredKeys<TParams>>>(\n\t\tkeys: TKeys & (RequiredKeys<TParams> extends TKeys[number] ? TKeys : never),\n\t): TKeys => keys;\n}\n\n/**\n * Type Safety:\n * - requiredParams must include ALL required fields from TParams\n * - TypeScript validates this at compile time\n */\nexport function buildQueryOptions<\n\tTParams extends BaseQueryParams,\n\tTData,\n\tconst TKeys extends ReadonlyArray<RequiredKeys<TParams>>,\n>(\n\tconfig: {\n\t\tgetQueryKey: (params: WithOptionalParams<TParams>) => QueryKey;\n\t\trequiredParams: TKeys &\n\t\t\t(RequiredKeys<TParams> extends TKeys[number] ? TKeys : never);\n\t\tfetcher: (params: TParams) => Promise<TData>;\n\t\tcustomValidation?: (params: WithOptionalParams<TParams>) => boolean;\n\t},\n\tparams: WithOptionalParams<TParams>,\n) {\n\t// Check if all required params are present\n\tconst requiredParamsValid = config.requiredParams.every(\n\t\t(key) => key in params && params[key] !== undefined,\n\t);\n\n\t// Run custom validation if provided\n\tconst customValid = config.customValidation\n\t\t? config.customValidation(params)\n\t\t: true;\n\n\tconst enabled = Boolean(\n\t\trequiredParamsValid &&\n\t\t\tcustomValid &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: config.getQueryKey(params),\n\t\tqueryFn: () => {\n\t\t\t// TypeScript knows params are valid here because enabled=true only if all required params exist\n\t\t\treturn config.fetcher(params as TParams);\n\t\t},\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n\n/**\n * Type Safety:\n * - requiredParams must include ALL required fields from TParams\n * - TypeScript validates this at compile time\n */\nexport function buildInfiniteQueryOptions<\n\tTParams extends BaseInfiniteQueryParams,\n\tTResponse,\n\tconst TKeys extends ReadonlyArray<RequiredKeys<TParams>>,\n>(\n\tconfig: {\n\t\tgetQueryKey: (params: WithOptionalInfiniteParams<TParams>) => QueryKey;\n\t\trequiredParams: TKeys &\n\t\t\t(RequiredKeys<TParams> extends TKeys[number] ? TKeys : never);\n\t\tfetcher: (params: TParams, page: Page) => Promise<TResponse>;\n\t\tgetPageInfo: (response: TResponse) => Page | undefined;\n\t\tcustomValidation?: (params: WithOptionalInfiniteParams<TParams>) => boolean;\n\t},\n\tparams: WithOptionalInfiniteParams<TParams>,\n) {\n\t// Check if all required params are present\n\tconst requiredParamsValid = config.requiredParams.every(\n\t\t(key) => key in params && params[key] !== undefined,\n\t);\n\n\t// Run custom validation if provided\n\tconst customValid = config.customValidation\n\t\t? config.customValidation(params)\n\t\t: true;\n\n\tconst enabled = Boolean(\n\t\trequiredParamsValid &&\n\t\t\tcustomValid &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: config.getQueryKey(params),\n\t\tqueryFn: async ({ pageParam }) => {\n\t\t\treturn config.fetcher(params as TParams, pageParam);\n\t\t},\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) => {\n\t\t\tconst pageInfo = config.getPageInfo(lastPage);\n\t\t\treturn pageInfo?.more ? pageInfo : undefined;\n\t\t},\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type {\n\tContractType,\n\tCreateReq,\n\tMarketplaceKind,\n} from '@0xsequence/api-client';\nimport type { Hex } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport type {\n\tStandardInfiniteQueryOptions,\n\tStandardQueryOptions,\n} from '../types/query';\n\nexport interface QueryArg {\n\tenabled?: boolean;\n}\n\nexport type CollectableId = string | number;\n\nexport type CollectionType = ContractType.ERC1155 | ContractType.ERC721;\n\nexport interface Transaction {\n\tto: Hex;\n\tdata?: Hex;\n\tvalue?: bigint;\n}\n\ntype TransactionStep = {\n\texist: boolean;\n\tisExecuting: boolean;\n\texecute: () => Promise<void>;\n};\n\nexport type TransactionSteps = {\n\tapproval: TransactionStep;\n\ttransaction: TransactionStep;\n};\n\nexport enum TransactionType {\n\tBUY = 'BUY',\n\tSELL = 'SELL',\n\tLISTING = 'LISTING',\n\tOFFER = 'OFFER',\n\tTRANSFER = 'TRANSFER',\n\tCANCEL = 'CANCEL',\n}\n\nexport interface BuyInput {\n\torderId: string;\n\tmarketplace: MarketplaceKind;\n\tquantity: string;\n}\n\nexport interface SellInput {\n\torderId: string;\n\tmarketplace: MarketplaceKind;\n\tquantity?: string;\n}\n\nexport interface ListingInput {\n\tcontractType: ContractType;\n\tlisting: CreateReq;\n}\n\nexport interface OfferInput {\n\tcontractType: ContractType;\n\toffer: CreateReq;\n}\n\nexport interface CancelInput {\n\torderId: string;\n\tmarketplace: MarketplaceKind;\n}\n\nexport type ValuesOptional<T> = {\n\t[K in keyof T]: T[K] | undefined;\n};\n\n/**\n * Makes all properties in T required (removes optionality)\n * Note: Different from RequiredKeys in query-builder.ts which extracts required key names\n */\nexport type AllRequired<T> = {\n\t[K in keyof T]-?: T[K];\n};\n\nexport type QueryKeyArgs<T> = {\n\t[K in keyof AllRequired<T>]: T[K] | undefined;\n};\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\n/**\n * Extracts only API-relevant fields from query params, excluding SDK config and query options\n * Converts optional properties (prop?: T) to explicit union types (prop: T | undefined)\n */\nexport type ApiArgs<T> = ValuesOptional<Omit<T, 'config' | 'query'>>;\n\n/**\n * Wraps API request types with SDK-specific requirements\n * - Adds config and query fields\n * - Makes all fields optional including config (hooks use useConfig() as default)\n * - Works with standard queries\n */\nexport type SdkQueryParams<TApiRequest, TQuery = StandardQueryOptions> = {\n\t[K in keyof TApiRequest]?: TApiRequest[K];\n} & {\n\tconfig?: SdkConfig;\n\tquery?: TQuery;\n};\n\n/**\n * Wraps API request types with SDK-specific requirements for infinite queries\n * - Adds config and query fields\n * - Makes all fields optional including config (hooks use useConfig() as default)\n */\nexport type SdkInfiniteQueryParams<TApiRequest> = SdkQueryParams<\n\tTApiRequest,\n\tStandardInfiniteQueryOptions\n>;\n\n/**\n * Makes specified keys required in an object type\n * Used in fetchers to ensure required params exist\n */\nexport type WithRequired<T, K extends keyof T = keyof T> = T & {\n\t[P in K]-?: T[P];\n};\n"],"mappings":";;;;AAAA,MAAa,cAAc;AAE3B,SAAgB,gBAAgB;AAC/B,KAAI,CAAC,WAAW,SAAU,QAAO;AACjC,QAAO,SAAS,eAAe,YAAY;;;;;AC2F5C,SAAgB,oBAA6B;AAC5C,SACC,SACW;;;;;;;AAQb,SAAgB,kBAKf,QAOA,QACC;CAED,MAAM,sBAAsB,OAAO,eAAe,OAChD,QAAQ,OAAO,UAAU,OAAO,SAAS,OAC1C;CAGD,MAAM,cAAc,OAAO,mBACxB,OAAO,iBAAiB,OAAO,GAC/B;CAEH,MAAM,UAAU,QACf,uBACC,eACA,OAAO,WACN,OAAO,OAAO,WAAW,MAC3B;AAED,QAAO,aAAa;EACnB,UAAU,OAAO,YAAY,OAAO;EACpC,eAAe;AAEd,UAAO,OAAO,QAAQ,OAAkB;;EAEzC,GAAG,OAAO;EACV;EACA,CAAC;;;;;;;AAQH,SAAgB,0BAKf,QAQA,QACC;CAED,MAAM,sBAAsB,OAAO,eAAe,OAChD,QAAQ,OAAO,UAAU,OAAO,SAAS,OAC1C;CAGD,MAAM,cAAc,OAAO,mBACxB,OAAO,iBAAiB,OAAO,GAC/B;CAEH,MAAM,UAAU,QACf,uBACC,eACA,OAAO,WACN,OAAO,OAAO,WAAW,MAC3B;AAED,QAAO,qBAAqB;EAC3B,UAAU,OAAO,YAAY,OAAO;EACpC,SAAS,OAAO,EAAE,gBAAgB;AACjC,UAAO,OAAO,QAAQ,QAAmB,UAAU;;EAEpD,kBAAkB;GAAE,MAAM;GAAG,UAAU;GAAI;EAC3C,mBAAmB,aAAa;GAC/B,MAAM,WAAW,OAAO,YAAY,SAAS;AAC7C,UAAO,UAAU,OAAO,WAAW;;EAEpC,GAAG,OAAO;EACV;EACA,CAAC;;;;;AChKH,IAAY,8DAAL;AACN;AACA;AACA;AACA;AACA;AACA"}