{"version":3,"file":"token2.js","names":["initialPageParam: IndexerPage"],"sources":["../src/react/queries/token/queryKeys.ts","../src/react/queries/token/balances.ts","../src/react/queries/token/metadata.ts","../src/react/queries/token/metadata-search.ts","../src/react/queries/token/supplies.ts","../src/react/queries/token/ranges.ts"],"sourcesContent":["import { serializeBigInts } from '../../_internal/utils';\n\n/**\n * Creates a type-safe query key for token domain with automatic bigint serialization\n *\n * @param operation - The specific operation (e.g., 'balances', 'metadata', 'ranges')\n * @param params - The query parameters (will be automatically serialized)\n * @returns A serialized query key safe for React Query\n */\nexport function createTokenQueryKey<T>(operation: string, params: T) {\n\treturn ['token', operation, serializeBigInts(params)] as const;\n}\n","import type {\n\tGetTokenBalancesSdkRequest,\n\tIndexerPage,\n} from '@0xsequence/api-client';\nimport {\n\tbuildInfiniteQueryOptions,\n\tgetIndexerClient,\n\ttype Optional,\n\ttype SdkQueryParams,\n\ttype WithOptionalInfiniteParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport type FetchBalancesParams = GetTokenBalancesSdkRequest & {\n\tincludeCollectionTokens?: boolean;\n};\n\nexport type ListBalancesQueryOptions = SdkQueryParams<FetchBalancesParams>;\n\n/**\n * Balances query params with accountAddress as required, contractAddress is optional\n */\nexport type UseListBalancesParams = Optional<\n\tListBalancesQueryOptions,\n\t'config' | 'contractAddress'\n> &\n\tRequired<Pick<ListBalancesQueryOptions, 'accountAddress'>>;\n\nexport async function fetchBalances(\n\tparams: WithRequired<\n\t\tListBalancesQueryOptions,\n\t\t'chainId' | 'accountAddress' | 'config'\n\t>,\n\tpage: IndexerPage,\n) {\n\tconst {\n\t\tchainId,\n\t\taccountAddress,\n\t\tcontractAddress,\n\t\ttokenId,\n\t\tincludeMetadata,\n\t\tmetadataOptions,\n\t\tconfig,\n\t} = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\treturn indexerClient.getTokenBalances({\n\t\taccountAddress,\n\t\tcontractAddress,\n\t\ttokenId,\n\t\tincludeMetadata,\n\t\tmetadataOptions,\n\t\tpage: {\n\t\t\tpage: page.page,\n\t\t\tpageSize: page.pageSize,\n\t\t\tmore: page.more ?? false,\n\t\t},\n\t});\n}\n\nexport function getListBalancesQueryKey(params: ListBalancesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\taccountAddress: params.accountAddress,\n\t\tcontractAddress: params.contractAddress,\n\t\ttokenId: params.tokenId,\n\t\tincludeMetadata: params.includeMetadata,\n\t\tmetadataOptions: params.metadataOptions,\n\t\tincludeCollectionTokens: params.includeCollectionTokens,\n\t};\n\n\treturn createTokenQueryKey('balances', apiArgs);\n}\n\n/**\n * Creates a tanstack infinite query options object for the balances query\n *\n * @param params - The query parameters including config\n * @returns Query options configuration\n */\nexport function listBalancesOptions(\n\tparams: WithOptionalInfiniteParams<\n\t\tWithRequired<\n\t\t\tListBalancesQueryOptions,\n\t\t\t'chainId' | 'accountAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildInfiniteQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListBalancesQueryKey,\n\t\t\trequiredParams: ['chainId', 'accountAddress', 'config'] as const,\n\t\t\tfetcher: fetchBalances,\n\t\t\tgetPageInfo: (response) => {\n\t\t\t\tif (!response.page) return undefined;\n\t\t\t\treturn {\n\t\t\t\t\tpage: response.page.page ?? 1,\n\t\t\t\t\tpageSize: response.page.pageSize ?? 30,\n\t\t\t\t\tmore: response.page.more ?? false,\n\t\t\t\t};\n\t\t\t},\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.chainId && p.chainId > 0 && !!p.accountAddress,\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tGetTokenMetadataSdkArgs,\n\tTokenMetadata,\n} from '@0xsequence/api-client';\nimport {\n\tbuildQueryOptions,\n\tgetMetadataClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport type FetchListTokenMetadataParams = GetTokenMetadataSdkArgs;\n\nexport type ListTokenMetadataQueryOptions =\n\tSdkQueryParams<FetchListTokenMetadataParams>;\n\n/**\n * Fetches token metadata from the metadata API\n */\nexport async function fetchListTokenMetadata(\n\tparams: WithRequired<\n\t\tListTokenMetadataQueryOptions,\n\t\t'chainId' | 'contractAddress' | 'tokenIds' | 'config'\n\t>,\n): Promise<TokenMetadata[]> {\n\tconst { config, contractAddress, chainId, tokenIds } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst apiArgs = {\n\t\tchainId,\n\t\ttokenIds,\n\t\tcontractAddress,\n\t};\n\n\tconst response = await metadataClient.getTokenMetadata(apiArgs);\n\treturn response.tokenMetadata;\n}\n\nexport function getListTokenMetadataQueryKey(\n\tparams: ListTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcontractAddress: params.contractAddress,\n\t\ttokenIds: params.tokenIds,\n\t};\n\n\treturn createTokenQueryKey('metadata', apiArgs);\n}\n\nexport function listTokenMetadataQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListTokenMetadataQueryOptions,\n\t\t\t'chainId' | 'contractAddress' | 'tokenIds' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListTokenMetadataQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'contractAddress',\n\t\t\t\t'tokenIds',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListTokenMetadata,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.chainId &&\n\t\t\t\tp.chainId > 0 &&\n\t\t\t\t!!p.tokenIds &&\n\t\t\t\tp.tokenIds.length > 0 &&\n\t\t\t\t!!p.contractAddress,\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tSearchTokenMetadataReturn,\n\tSearchTokenMetadataSdkArgs,\n} from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport {\n\tgetMetadataClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport type FetchSearchTokenMetadataParams = SearchTokenMetadataSdkArgs;\n\nexport type SearchTokenMetadataQueryOptions =\n\tSdkInfiniteQueryParams<FetchSearchTokenMetadataParams>;\n\n/**\n * Fetches token metadata from the metadata API using search filters\n */\nexport async function fetchSearchTokenMetadata(\n\tparams: WithRequired<\n\t\tSearchTokenMetadataQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n): Promise<SearchTokenMetadataReturn> {\n\tconst { chainId, collectionAddress, filter, page, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst response = await metadataClient.searchTokenMetadata({\n\t\tchainId,\n\t\tcollectionAddress,\n\t\tfilter: filter ?? {},\n\t\tpage,\n\t});\n\n\treturn {\n\t\ttokenMetadata: response.tokenMetadata,\n\t\tpage: response.page,\n\t};\n}\n\nexport function getSearchTokenMetadataQueryKey(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId ?? 0,\n\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\tfilter: params.filter,\n\t};\n\n\treturn createTokenQueryKey('metadata-search', apiArgs);\n}\n\nexport function searchTokenMetadataQueryOptions(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam = { page: 1, pageSize: 30 };\n\n\tconst queryFn = ({ pageParam = initialPageParam }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tSearchTokenMetadataQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>;\n\t\treturn fetchSearchTokenMetadata({\n\t\t\tchainId: requiredParams.chainId,\n\t\t\tcollectionAddress: requiredParams.collectionAddress,\n\t\t\tfilter: params.filter,\n\t\t\tconfig: requiredParams.config,\n\t\t\tpage: pageParam,\n\t\t});\n\t};\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getSearchTokenMetadataQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) => {\n\t\t\tif (!lastPage.page?.more) return undefined;\n\t\t\treturn {\n\t\t\t\tpage: (lastPage.page.page || 1) + 1,\n\t\t\t\tpageSize: lastPage.page.pageSize || 20,\n\t\t\t};\n\t\t},\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type {\n\tAddress,\n\tGetTokenSuppliesRequest,\n\tIndexerPage,\n} from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport {\n\tgetIndexerClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport type FetchTokenSuppliesParams = Omit<\n\tGetTokenSuppliesRequest,\n\t'contractAddress' | 'collectionAddress'\n> & {\n\tchainId: number;\n\tcollectionAddress: Address;\n\tpage?: IndexerPage;\n};\n\nexport type TokenSuppliesQueryOptions =\n\tSdkInfiniteQueryParams<FetchTokenSuppliesParams>;\n\n/**\n * Fetches token supplies with support for indexer API\n */\nexport async function fetchTokenSupplies(\n\tparams: WithRequired<\n\t\tTokenSuppliesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n) {\n\tconst { chainId, config, ...apiParams } = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\tconst result = await indexerClient.getTokenSupplies(apiParams);\n\treturn result;\n}\n\nexport function getTokenSuppliesQueryKey(params: TokenSuppliesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId ?? 0,\n\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\tincludeMetadata: params.includeMetadata,\n\t\tmetadataOptions: params.metadataOptions,\n\t};\n\n\treturn createTokenQueryKey('supplies', apiArgs);\n}\n\nexport function tokenSuppliesQueryOptions(params: TokenSuppliesQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam: IndexerPage = { page: 1, pageSize: 30, more: false };\n\n\tconst queryFn = async ({ pageParam = initialPageParam }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tTokenSuppliesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>;\n\t\treturn fetchTokenSupplies({\n\t\t\tchainId: requiredParams.chainId,\n\t\t\tcollectionAddress: requiredParams.collectionAddress,\n\t\t\tconfig: requiredParams.config,\n\t\t\tincludeMetadata: params.includeMetadata,\n\t\t\tmetadataOptions: params.metadataOptions,\n\t\t\tpage: pageParam,\n\t\t});\n\t};\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getTokenSuppliesQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type {\n\tAddress,\n\tGetTokenIDRangesRequest,\n\tGetTokenIDRangesResponse,\n} from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetIndexerClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport type FetchGetTokenRangesParams = Extract<\n\tGetTokenIDRangesRequest,\n\t{ collectionAddress: Address }\n> & { chainId: number };\n\nexport type GetTokenRangesQueryOptions =\n\tSdkQueryParams<FetchGetTokenRangesParams>;\n\n/**\n * Fetches token ID ranges for a collection from the Indexer API\n */\nexport async function fetchGetTokenRanges(\n\tparams: WithRequired<\n\t\tGetTokenRangesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n): Promise<GetTokenIDRangesResponse> {\n\tconst { chainId, collectionAddress, config } = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\tconst response = await indexerClient.getTokenIDRanges({ collectionAddress });\n\n\tif (!response) {\n\t\tthrow new Error('Failed to fetch token ranges');\n\t}\n\n\treturn response;\n}\n\nexport function getTokenRangesQueryKey(params: GetTokenRangesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcollectionAddress: params.collectionAddress,\n\t};\n\n\treturn createTokenQueryKey('ranges', apiArgs);\n}\n\nexport function getTokenRangesQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tGetTokenRangesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getTokenRangesQueryKey,\n\t\t\trequiredParams: ['chainId', 'collectionAddress', 'config'],\n\t\t\tfetcher: fetchGetTokenRanges,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.chainId &&\n\t\t\t\tp.chainId > 0 &&\n\t\t\t\t!!p.collectionAddress &&\n\t\t\t\tisAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n"],"mappings":";;;;;;;;;;;;;AASA,SAAgB,oBAAuB,WAAmB,QAAW;AACpE,QAAO;EAAC;EAAS;EAAW,iBAAiB,OAAO;EAAC;;;;;ACmBtD,eAAsB,cACrB,QAIA,MACC;CACD,MAAM,EACL,SACA,gBACA,iBACA,SACA,iBACA,iBACA,WACG;AAEJ,QADsB,iBAAiB,SAAS,OAAO,CAClC,iBAAiB;EACrC;EACA;EACA;EACA;EACA;EACA,MAAM;GACL,MAAM,KAAK;GACX,UAAU,KAAK;GACf,MAAM,KAAK,QAAQ;GACnB;EACD,CAAC;;AAGH,SAAgB,wBAAwB,QAAkC;AAWzE,QAAO,oBAAoB,YAVX;EACf,SAAS,OAAO;EAChB,gBAAgB,OAAO;EACvB,iBAAiB,OAAO;EACxB,SAAS,OAAO;EAChB,iBAAiB,OAAO;EACxB,iBAAiB,OAAO;EACxB,yBAAyB,OAAO;EAChC,CAE8C;;;;;;;;AAShD,SAAgB,oBACf,QAMC;AACD,QAAO,0BACN;EACC,aAAa;EACb,gBAAgB;GAAC;GAAW;GAAkB;GAAS;EACvD,SAAS;EACT,cAAc,aAAa;AAC1B,OAAI,CAAC,SAAS,KAAM,QAAO;AAC3B,UAAO;IACN,MAAM,SAAS,KAAK,QAAQ;IAC5B,UAAU,SAAS,KAAK,YAAY;IACpC,MAAM,SAAS,KAAK,QAAQ;IAC5B;;EAEF,mBAAmB,MAClB,CAAC,CAAC,EAAE,WAAW,EAAE,UAAU,KAAK,CAAC,CAAC,EAAE;EACrC,EACD,OACA;;;;;;;;ACpFF,eAAsB,uBACrB,QAI2B;CAC3B,MAAM,EAAE,QAAQ,iBAAiB,SAAS,aAAa;CACvD,MAAM,iBAAiB,kBAAkB,OAAO;CAEhD,MAAM,UAAU;EACf;EACA;EACA;EACA;AAGD,SADiB,MAAM,eAAe,iBAAiB,QAAQ,EAC/C;;AAGjB,SAAgB,6BACf,QACC;AAOD,QAAO,oBAAoB,YANX;EACf,SAAS,OAAO;EAChB,iBAAiB,OAAO;EACxB,UAAU,OAAO;EACjB,CAE8C;;AAGhD,SAAgB,8BACf,QAMC;AACD,QAAO,kBACN;EACC,aAAa;EACb,gBAAgB;GACf;GACA;GACA;GACA;GACA;EACD,SAAS;EACT,mBAAmB,MAClB,CAAC,CAAC,EAAE,WACJ,EAAE,UAAU,KACZ,CAAC,CAAC,EAAE,YACJ,EAAE,SAAS,SAAS,KACpB,CAAC,CAAC,EAAE;EACL,EACD,OACA;;;;;;;;AC1DF,eAAsB,yBACrB,QAIqC;CACrC,MAAM,EAAE,SAAS,mBAAmB,QAAQ,MAAM,WAAW;CAG7D,MAAM,WAAW,MAFM,kBAAkB,OAAO,CAEV,oBAAoB;EACzD;EACA;EACA,QAAQ,UAAU,EAAE;EACpB;EACA,CAAC;AAEF,QAAO;EACN,eAAe,SAAS;EACxB,MAAM,SAAS;EACf;;AAGF,SAAgB,+BACf,QACC;AAOD,QAAO,oBAAoB,mBANX;EACf,SAAS,OAAO,WAAW;EAC3B,mBAAmB,OAAO,qBAAqB;EAC/C,QAAQ,OAAO;EACf,CAEqD;;AAGvD,SAAgB,gCACf,QACC;CACD,MAAM,UAAU,QACf,OAAO,WACN,OAAO,qBACP,OAAO,WACN,OAAO,OAAO,WAAW,MAC3B;CAED,MAAM,mBAAmB;EAAE,MAAM;EAAG,UAAU;EAAI;CAElD,MAAM,WAAW,EAAE,YAAY,uBAAuB;EACrD,MAAM,iBAAiB;AAIvB,SAAO,yBAAyB;GAC/B,SAAS,eAAe;GACxB,mBAAmB,eAAe;GAClC,QAAQ,OAAO;GACf,QAAQ,eAAe;GACvB,MAAM;GACN,CAAC;;AAGH,QAAO,qBAAqB;EAC3B,UAAU,+BAA+B,OAAO;EAChD;EACA;EACA,mBAAmB,aAAa;AAC/B,OAAI,CAAC,SAAS,MAAM,KAAM,QAAO;AACjC,UAAO;IACN,OAAO,SAAS,KAAK,QAAQ,KAAK;IAClC,UAAU,SAAS,KAAK,YAAY;IACpC;;EAEF,GAAG,OAAO;EACV;EACA,CAAC;;;;;;;;ACjEH,eAAsB,mBACrB,QAIC;CACD,MAAM,EAAE,SAAS,QAAQ,GAAG,cAAc;AAG1C,QADe,MADO,iBAAiB,SAAS,OAAO,CACpB,iBAAiB,UAAU;;AAI/D,SAAgB,yBAAyB,QAAmC;AAQ3E,QAAO,oBAAoB,YAPX;EACf,SAAS,OAAO,WAAW;EAC3B,mBAAmB,OAAO,qBAAqB;EAC/C,iBAAiB,OAAO;EACxB,iBAAiB,OAAO;EACxB,CAE8C;;AAGhD,SAAgB,0BAA0B,QAAmC;CAC5E,MAAM,UAAU,QACf,OAAO,WACN,OAAO,qBACP,OAAO,WACN,OAAO,OAAO,WAAW,MAC3B;CAED,MAAMA,mBAAgC;EAAE,MAAM;EAAG,UAAU;EAAI,MAAM;EAAO;CAE5E,MAAM,UAAU,OAAO,EAAE,YAAY,uBAAuB;EAC3D,MAAM,iBAAiB;AAIvB,SAAO,mBAAmB;GACzB,SAAS,eAAe;GACxB,mBAAmB,eAAe;GAClC,QAAQ,eAAe;GACvB,iBAAiB,OAAO;GACxB,iBAAiB,OAAO;GACxB,MAAM;GACN,CAAC;;AAGH,QAAO,qBAAqB;EAC3B,UAAU,yBAAyB,OAAO;EAC1C;EACA;EACA,mBAAmB,aAClB,SAAS,MAAM,OAAO,SAAS,OAAO;EACvC,GAAG,OAAO;EACV;EACA,CAAC;;;;;;;;AC1DH,eAAsB,oBACrB,QAIoC;CACpC,MAAM,EAAE,SAAS,mBAAmB,WAAW;CAE/C,MAAM,WAAW,MADK,iBAAiB,SAAS,OAAO,CAClB,iBAAiB,EAAE,mBAAmB,CAAC;AAE5E,KAAI,CAAC,SACJ,OAAM,IAAI,MAAM,+BAA+B;AAGhD,QAAO;;AAGR,SAAgB,uBAAuB,QAAoC;AAM1E,QAAO,oBAAoB,UALX;EACf,SAAS,OAAO;EAChB,mBAAmB,OAAO;EAC1B,CAE4C;;AAG9C,SAAgB,2BACf,QAMC;AACD,QAAO,kBACN;EACC,aAAa;EACb,gBAAgB;GAAC;GAAW;GAAqB;GAAS;EAC1D,SAAS;EACT,mBAAmB,MAClB,CAAC,CAAC,EAAE,WACJ,EAAE,UAAU,KACZ,CAAC,CAAC,EAAE,qBACJ,UAAU,EAAE,kBAAkB;EAC/B,EACD,OACA"}