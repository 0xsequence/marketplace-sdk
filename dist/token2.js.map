{"version":3,"file":"token2.js","names":["apiArgs: GetTokenMetadataArgs","initialPageParam: Indexer.Page"],"sources":["../src/react/queries/token/queryKeys.ts","../src/react/queries/token/balances.ts","../src/react/queries/token/metadata.ts","../src/react/queries/token/metadata-search.ts","../src/react/queries/token/supplies.ts","../src/react/queries/token/ranges.ts"],"sourcesContent":["import { serializeBigInts } from '../../_internal/utils';\n\n/**\n * Creates a type-safe query key for token domain with automatic bigint serialization\n *\n * @param operation - The specific operation (e.g., 'balances', 'metadata', 'ranges')\n * @param params - The query parameters (will be automatically serialized)\n * @returns A serialized query key safe for React Query\n */\nexport function createTokenQueryKey<T>(operation: string, params: T) {\n\treturn ['token', operation, serializeBigInts(params)] as const;\n}\n","import type { Indexer } from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address, Hex } from 'viem';\nimport {\n\tgetIndexerClient,\n\ttype SdkQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport interface FetchBalancesParams {\n\tchainId: number;\n\taccountAddress?: Address;\n\tcontractAddress?: Address;\n\ttokenId?: bigint;\n\tincludeMetadata?: boolean;\n\tmetadataOptions?: {\n\t\tverifiedOnly?: boolean;\n\t\tunverifiedOnly?: boolean;\n\t\tincludeContracts?: Hex[];\n\t};\n\tincludeCollectionTokens?: boolean;\n\tpage?: Indexer.Page;\n}\n\nexport type ListBalancesQueryOptions = SdkQueryParams<FetchBalancesParams>;\n\n/**\n * @deprecated Use ListBalancesQueryOptions instead\n */\nexport type UseListBalancesArgs = Omit<ListBalancesQueryOptions, 'config'> & {\n\tconfig?: ListBalancesQueryOptions['config'];\n};\n\nexport async function fetchBalances(\n\tparams: WithRequired<\n\t\tListBalancesQueryOptions,\n\t\t'chainId' | 'accountAddress' | 'config'\n\t>,\n\tpage: Indexer.Page,\n) {\n\tconst {\n\t\tchainId,\n\t\taccountAddress,\n\t\tcontractAddress,\n\t\ttokenId,\n\t\tincludeMetadata,\n\t\tmetadataOptions,\n\t\tconfig,\n\t} = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\treturn indexerClient.getTokenBalances({\n\t\taccountAddress,\n\t\tcontractAddress,\n\t\ttokenId,\n\t\tincludeMetadata,\n\t\tmetadataOptions,\n\t\tpage,\n\t});\n}\n\nexport function getListBalancesQueryKey(params: ListBalancesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\taccountAddress: params.accountAddress,\n\t\tcontractAddress: params.contractAddress,\n\t\ttokenId: params.tokenId,\n\t\tincludeMetadata: params.includeMetadata,\n\t\tmetadataOptions: params.metadataOptions,\n\t\tincludeCollectionTokens: params.includeCollectionTokens,\n\t};\n\n\treturn createTokenQueryKey('balances', apiArgs);\n}\n\n/**\n * Creates a tanstack infinite query options object for the balances query\n *\n * @param params - The query parameters including config\n * @returns Query options configuration\n */\nexport function listBalancesOptions(params: ListBalancesQueryOptions) {\n\tconst enabled =\n\t\t!!params.chainId && !!params.accountAddress && !!params.config;\n\n\tconst queryFn = ({ pageParam }: { pageParam: Indexer.Page }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tListBalancesQueryOptions,\n\t\t\t'chainId' | 'accountAddress' | 'config'\n\t\t>;\n\t\treturn fetchBalances(\n\t\t\t{\n\t\t\t\t...params,\n\t\t\t\tchainId: requiredParams.chainId,\n\t\t\t\taccountAddress: requiredParams.accountAddress,\n\t\t\t\tconfig: requiredParams.config,\n\t\t\t},\n\t\t\tpageParam,\n\t\t);\n\t};\n\n\treturn infiniteQueryOptions({\n\t\t...params.query,\n\t\tenabled: (params.query?.enabled ?? true) && enabled,\n\t\tqueryKey: getListBalancesQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam: { page: 1, pageSize: 30, more: false },\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more\n\t\t\t\t? {\n\t\t\t\t\t\tpage: lastPage.page.page + 1,\n\t\t\t\t\t\tpageSize: lastPage.page.pageSize,\n\t\t\t\t\t\tmore: true,\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t});\n}\n","import type { GetTokenMetadataArgs } from '@0xsequence/api-client';\nimport type { Address } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMetadataClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport interface FetchListTokenMetadataParams {\n\tchainId: number;\n\tcontractAddress: Address;\n\ttokenIds: bigint[];\n}\n\nexport type ListTokenMetadataQueryOptions =\n\tSdkQueryParams<FetchListTokenMetadataParams>;\n\n/**\n * Fetches token metadata from the metadata API\n */\nexport async function fetchListTokenMetadata(\n\tparams: WithRequired<\n\t\tListTokenMetadataQueryOptions,\n\t\t'chainId' | 'contractAddress' | 'tokenIds' | 'config'\n\t>,\n) {\n\tconst { config, contractAddress, chainId, tokenIds } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst apiArgs: GetTokenMetadataArgs = {\n\t\tchainId,\n\t\ttokenIds,\n\t\tcontractAddress,\n\t};\n\n\tconst response = await metadataClient.getTokenMetadata(apiArgs);\n\treturn response.tokenMetadata;\n}\n\nexport function getListTokenMetadataQueryKey(\n\tparams: ListTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcontractAddress: params.contractAddress,\n\t\ttokenIds: params.tokenIds,\n\t};\n\n\treturn createTokenQueryKey('metadata', apiArgs);\n}\n\nexport function listTokenMetadataQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListTokenMetadataQueryOptions,\n\t\t\t'chainId' | 'contractAddress' | 'tokenIds' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListTokenMetadataQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'contractAddress',\n\t\t\t\t'tokenIds',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListTokenMetadata,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.chainId &&\n\t\t\t\tp.chainId > 0 &&\n\t\t\t\t!!p.tokenIds &&\n\t\t\t\tp.tokenIds.length > 0 &&\n\t\t\t\t!!p.contractAddress,\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tFilter,\n\tPage,\n\tSearchTokenMetadataReturn,\n} from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport {\n\tgetMetadataClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport interface FetchSearchTokenMetadataParams {\n\tchainId: number;\n\tcollectionAddress: Address;\n\tfilter?: Filter;\n\tpage?: Page;\n}\n\nexport type SearchTokenMetadataQueryOptions =\n\tSdkInfiniteQueryParams<FetchSearchTokenMetadataParams>;\n\n/**\n * Fetches token metadata from the metadata API using search filters\n */\nexport async function fetchSearchTokenMetadata(\n\tparams: WithRequired<\n\t\tSearchTokenMetadataQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n): Promise<SearchTokenMetadataReturn> {\n\tconst { chainId, collectionAddress, filter, page, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst response = await metadataClient.searchTokenMetadata({\n\t\tchainId,\n\t\tcollectionAddress,\n\t\tfilter: filter ?? {},\n\t\tpage,\n\t});\n\n\treturn {\n\t\ttokenMetadata: response.tokenMetadata,\n\t\tpage: response.page,\n\t};\n}\n\nexport function getSearchTokenMetadataQueryKey(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId ?? 0,\n\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\tfilter: params.filter,\n\t};\n\n\treturn createTokenQueryKey('metadata-search', apiArgs);\n}\n\nexport function searchTokenMetadataQueryOptions(\n\tparams: SearchTokenMetadataQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam = { page: 1, pageSize: 30 };\n\n\tconst queryFn = ({ pageParam = initialPageParam }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tSearchTokenMetadataQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>;\n\t\treturn fetchSearchTokenMetadata({\n\t\t\tchainId: requiredParams.chainId,\n\t\t\tcollectionAddress: requiredParams.collectionAddress,\n\t\t\tfilter: params.filter,\n\t\t\tconfig: requiredParams.config,\n\t\t\tpage: pageParam,\n\t\t});\n\t};\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getSearchTokenMetadataQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) => {\n\t\t\tif (!lastPage.page?.more) return undefined;\n\t\t\treturn {\n\t\t\t\tpage: (lastPage.page.page || 1) + 1,\n\t\t\t\tpageSize: lastPage.page.pageSize || 20,\n\t\t\t};\n\t\t},\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { Indexer } from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport {\n\tgetIndexerClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport interface FetchTokenSuppliesParams\n\textends Omit<\n\t\tIndexer.GetTokenSuppliesRequest,\n\t\t'contractAddress' | 'collectionAddress'\n\t> {\n\tchainId: number;\n\tcollectionAddress: Address;\n\tpage?: Indexer.Page;\n}\n\nexport type TokenSuppliesQueryOptions =\n\tSdkInfiniteQueryParams<FetchTokenSuppliesParams>;\n\n/**\n * Fetches token supplies with support for indexer API\n */\nexport async function fetchTokenSupplies(\n\tparams: WithRequired<\n\t\tTokenSuppliesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n) {\n\tconst { chainId, config, ...apiParams } = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\tconst result = await indexerClient.getTokenSupplies(apiParams);\n\treturn result;\n}\n\nexport function getTokenSuppliesQueryKey(params: TokenSuppliesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId ?? 0,\n\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\tincludeMetadata: params.includeMetadata,\n\t\tmetadataOptions: params.metadataOptions,\n\t};\n\n\treturn createTokenQueryKey('supplies', apiArgs);\n}\n\nexport function tokenSuppliesQueryOptions(params: TokenSuppliesQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\tconst initialPageParam: Indexer.Page = { page: 1, pageSize: 30, more: false };\n\n\tconst queryFn = async ({ pageParam = initialPageParam }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tTokenSuppliesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>;\n\t\treturn fetchTokenSupplies({\n\t\t\tchainId: requiredParams.chainId,\n\t\t\tcollectionAddress: requiredParams.collectionAddress,\n\t\t\tconfig: requiredParams.config,\n\t\t\tincludeMetadata: params.includeMetadata,\n\t\t\tmetadataOptions: params.metadataOptions,\n\t\t\tpage: pageParam,\n\t\t});\n\t};\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getTokenSuppliesQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { Indexer } from '@0xsequence/api-client';\nimport type { Address } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetIndexerClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createTokenQueryKey } from './queryKeys';\n\nexport interface FetchGetTokenRangesParams {\n\tchainId: number;\n\tcollectionAddress: Address;\n}\n\nexport type GetTokenRangesQueryOptions =\n\tSdkQueryParams<FetchGetTokenRangesParams>;\n\n/**\n * Fetches token ID ranges for a collection from the Indexer API\n */\nexport async function fetchGetTokenRanges(\n\tparams: WithRequired<\n\t\tGetTokenRangesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n): Promise<Indexer.GetTokenIDRangesResponse> {\n\tconst { chainId, collectionAddress, config } = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\tconst response = await indexerClient.getTokenIDRanges({ collectionAddress });\n\n\tif (!response) {\n\t\tthrow new Error('Failed to fetch token ranges');\n\t}\n\n\treturn response;\n}\n\nexport function getTokenRangesQueryKey(params: GetTokenRangesQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcollectionAddress: params.collectionAddress,\n\t};\n\n\treturn createTokenQueryKey('ranges', apiArgs);\n}\n\nexport function getTokenRangesQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tGetTokenRangesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getTokenRangesQueryKey,\n\t\t\trequiredParams: ['chainId', 'collectionAddress', 'config'],\n\t\t\tfetcher: fetchGetTokenRanges,\n\t\t\tcustomValidation: (p) => !!p.chainId && p.chainId > 0,\n\t\t},\n\t\tparams,\n\t);\n}\n"],"mappings":"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"}