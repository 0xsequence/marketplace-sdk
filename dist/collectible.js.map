{"version":3,"file":"collectible.js","names":["apiArgs: GetCountOfFilteredCollectiblesRequest","apiArgs","apiArgs: GetCountOfAllCollectiblesRequest","apiArgs: GetTokenMetadataArgs","initialPage: PageParam"],"sources":["../src/react/queries/collectible/balance.ts","../src/react/queries/collectible/market-count.ts","../src/react/queries/collectible/market-highest-offer.ts","../src/react/utils/normalizePriceFilters.ts","../src/react/queries/collectible/market-list.ts","../src/react/queries/collectible/market-list-paginated.ts","../src/react/queries/collectible/market-listings.ts","../src/react/queries/collectible/market-listings-count.ts","../src/react/queries/collectible/market-lowest-listing.ts","../src/react/queries/collectible/market-offers.ts","../src/react/queries/collectible/market-offers-count.ts","../src/react/queries/collectible/metadata.ts","../src/react/queries/collectible/primary-sale-item.ts","../src/react/queries/collectible/primary-sale-items.ts","../src/react/queries/collectible/primary-sale-items-count.ts"],"sourcesContent":["import type { GetBalanceOfCollectibleRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetIndexerClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectibleQueryKey } from './queryKeys';\n\nexport type FetchBalanceOfCollectibleParams = GetBalanceOfCollectibleRequest;\n\nexport type BalanceOfCollectibleQueryOptions =\n\tSdkQueryParams<FetchBalanceOfCollectibleParams>;\n\n/**\n * Fetches the balance of a specific collectible for a user\n *\n * @param params - Parameters for the API call\n * @returns The balance data\n */\nexport async function fetchBalanceOfCollectible(\n\tparams: WithRequired<\n\t\tBalanceOfCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'userAddress' | 'config'\n\t>,\n) {\n\tconst {\n\t\tchainId,\n\t\tuserAddress,\n\t\tcollectionAddress,\n\t\ttokenId,\n\t\tincludeMetadata,\n\t\tconfig,\n\t} = params;\n\tconst indexerClient = getIndexerClient(chainId, config);\n\tconst shouldIncludeMetadata = includeMetadata ?? false;\n\treturn indexerClient\n\t\t.getTokenBalances({\n\t\t\taccountAddress: userAddress,\n\t\t\tcontractAddress: collectionAddress,\n\t\t\ttokenId,\n\t\t\tincludeMetadata: shouldIncludeMetadata,\n\t\t\t...(shouldIncludeMetadata && {\n\t\t\t\tmetadataOptions: {\n\t\t\t\t\tverifiedOnly: true,\n\t\t\t\t},\n\t\t\t}),\n\t\t})\n\t\t.then((res) => res.balances[0] || null);\n}\n\n/**\n * Query key structure: [resource, operation, params]\n * @example ['collectible', 'balance', { chainId, accountAddress, contractAddress, tokenID }]\n */\nexport function getBalanceOfCollectibleQueryKey(\n\tparams: BalanceOfCollectibleQueryOptions,\n) {\n\tconst shouldIncludeMetadata = params.includeMetadata ?? false;\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\taccountAddress: params.userAddress,\n\t\tcontractAddress: params.collectionAddress,\n\t\ttokenId: params.tokenId,\n\t\tincludeMetadata: shouldIncludeMetadata,\n\t\t...(shouldIncludeMetadata && {\n\t\t\tmetadataOptions: {\n\t\t\t\tverifiedOnly: true,\n\t\t\t},\n\t\t}),\n\t};\n\n\treturn createCollectibleQueryKey('balance', apiArgs);\n}\n\n/**\n * Creates a tanstack query options object for the balance query\n *\n * @param params - The query parameters\n * @returns Query options configuration\n */\nexport function balanceOfCollectibleOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tBalanceOfCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'userAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getBalanceOfCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'userAddress',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'chainId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchBalanceOfCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress &&\n\t\t\t\tisAddress(p.collectionAddress) &&\n\t\t\t\tp.tokenId !== undefined &&\n\t\t\t\tp.tokenId >= 0n &&\n\t\t\t\t!!p.userAddress &&\n\t\t\t\tisAddress(p.userAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tGetCountOfAllCollectiblesRequest,\n\tGetCountOfFilteredCollectiblesRequest,\n} from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchCountOfCollectablesParams = GetCountOfAllCollectiblesRequest &\n\tPartial<Pick<GetCountOfFilteredCollectiblesRequest, 'filter' | 'side'>>;\n\nexport type CountOfCollectablesQueryOptions =\n\tSdkQueryParams<FetchCountOfCollectablesParams>;\n\n/**\n * Fetches count of collectibles from the marketplace API\n */\nexport async function fetchCountOfCollectables(\n\tparams: WithRequired<\n\t\tCountOfCollectablesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'config'\n\t>,\n) {\n\tconst { collectionAddress, chainId, config, filter, side } = params;\n\n\tconst client = getMarketplaceClient(config);\n\n\tif (filter && side) {\n\t\tconst apiArgs: GetCountOfFilteredCollectiblesRequest = {\n\t\t\tcollectionAddress,\n\t\t\tchainId,\n\t\t\tfilter,\n\t\t\tside,\n\t\t};\n\n\t\tconst result = await client.getCountOfFilteredCollectibles(apiArgs);\n\t\treturn result.count;\n\t}\n\n\tconst apiArgs: GetCountOfAllCollectiblesRequest = {\n\t\tcollectionAddress,\n\t\tchainId,\n\t};\n\n\tconst result = await client.getCountOfAllCollectibles(apiArgs);\n\treturn result.count;\n}\n\n/**\n * Query key structure: [resource, operation, params]\n * @example ['collectible', 'market-count', { chainId, contractAddress, filter?, side? }]\n */\nexport function getCountOfCollectablesQueryKey(\n\tparams: CountOfCollectablesQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tfilter: params.filter,\n\t\t\tside: params.side,\n\t\t},\n\t] as const;\n}\n\nexport function countOfCollectablesQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCountOfCollectablesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCountOfCollectablesQueryKey,\n\t\t\trequiredParams: ['chainId', 'collectionAddress', 'config'] as const,\n\t\t\tfetcher: fetchCountOfCollectables,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { Order } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\ttype GetHighestPriceOfferForCollectibleRequest,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type HighestOfferQueryOptions =\n\tSdkQueryParams<GetHighestPriceOfferForCollectibleRequest>;\n\nexport async function fetchHighestOffer(\n\tparams: WithRequired<\n\t\tHighestOfferQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<Order | null> {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst result =\n\t\tawait marketplaceClient.getHighestPriceOfferForCollectible(apiParams);\n\t// TanStack Query v5 requires non-undefined return values\n\treturn result.order ?? null;\n}\n\nexport function getHighestOfferQueryKey(params: HighestOfferQueryOptions) {\n\treturn [\n\t\t'collectible',\n\t\t'market-highest-offer',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function highestOfferQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tHighestOfferQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n): ReturnType<\n\ttypeof buildQueryOptions<\n\t\tWithRequired<\n\t\t\tHighestOfferQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>,\n\t\tOrder | null,\n\t\treadonly ['chainId', 'collectionAddress', 'tokenId', 'config']\n\t>\n> {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getHighestOfferQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchHighestOffer,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { PriceFilter } from '../ssr';\n\ntype PriceLike = {\n\tcontractAddress: string;\n\tmin?: string | bigint;\n\tmax?: string | bigint;\n};\n\nfunction normalizePriceFilters(\n\tfilters?: PriceLike[],\n): PriceFilter[] | undefined {\n\tif (!filters) return undefined;\n\n\treturn filters.map(({ contractAddress, min, max }) => ({\n\t\tcontractAddress,\n\t\t...(min !== undefined && {\n\t\t\tmin: typeof min === 'bigint' ? min : BigInt(min),\n\t\t}),\n\t\t...(max !== undefined && {\n\t\t\tmax: typeof max === 'bigint' ? max : BigInt(max),\n\t\t}),\n\t}));\n}\n\nexport { normalizePriceFilters };\n","import { isAddress } from 'viem';\nimport type { Page } from '../../../types';\nimport type { CardType } from '../../../types/types';\nimport { findMarketCollection } from '../../../utils';\nimport type {\n\tListCollectiblesRequest,\n\tListCollectiblesResponse,\n} from '../../_internal';\nimport {\n\tbuildInfiniteQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { normalizePriceFilters } from '../../utils/normalizePriceFilters';\nimport { fetchMarketplaceConfig } from '../marketplace/config';\n\nexport type ListCollectiblesQueryOptions = SdkInfiniteQueryParams<\n\tListCollectiblesRequest & {\n\t\tcardType?: CardType;\n\t\tenabled?: boolean;\n\t}\n>;\n\n/**\n * Fetches a list of collectibles with pagination support from the Marketplace API\n */\nexport async function fetchListCollectibles(\n\tparams: WithRequired<\n\t\tListCollectiblesQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n\tpage: Page,\n): Promise<ListCollectiblesResponse> {\n\tconst { chainId, collectionAddress, config, filter, ...additionalApiParams } =\n\t\tparams;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\tconst isMarketCollection = !!findMarketCollection(\n\t\tmarketplaceConfig?.market.collections ?? [],\n\t\tcollectionAddress,\n\t\tchainId,\n\t);\n\n\t// If it's not a market collection, return an empty list. those collections are not compatible with the ListCollectibles endpoint.\n\tif (params.enabled === false || !isMarketCollection) {\n\t\treturn {\n\t\t\tcollectibles: [],\n\t\t\tpage: {\n\t\t\t\tpage: 1,\n\t\t\t\tpageSize: 30,\n\t\t\t\tmore: false,\n\t\t\t},\n\t\t};\n\t}\n\n\t// Transform price filters from strings to BigInt for API\n\tconst transformedFilter = filter\n\t\t? {\n\t\t\t\t...filter,\n\t\t\t\tprices: normalizePriceFilters(filter.prices),\n\t\t\t}\n\t\t: undefined;\n\n\treturn await marketplaceClient.listCollectibles({\n\t\tchainId,\n\t\tcollectionAddress,\n\t\tpage,\n\t\tfilter: transformedFilter,\n\t\t...additionalApiParams,\n\t});\n}\n\n/**\n * Query key structure: [resource, operation, params]\n * @example ['collectible', 'market-list', { chainId, contractAddress, side, filter }]\n */\nexport function getListCollectiblesQueryKey(\n\tparams: ListCollectiblesQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-list',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tside: params.side,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function listCollectiblesQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListCollectiblesQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildInfiniteQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListCollectiblesQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'side',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListCollectibles,\n\t\t\tgetPageInfo: (response) => response.page,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import { isAddress } from 'viem';\nimport type {\n\tListCollectiblesRequest,\n\tListCollectiblesResponse,\n} from '../../_internal';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { normalizePriceFilters } from '../../utils/normalizePriceFilters';\n\nexport type FetchListCollectiblesPaginatedParams = Omit<\n\tListCollectiblesRequest,\n\t'page'\n> & {\n\tpage?: number;\n\tpageSize?: number;\n};\n\nexport type ListCollectiblesPaginatedQueryOptions =\n\tSdkQueryParams<FetchListCollectiblesPaginatedParams>;\n\n/**\n * Fetches a list of collectibles with pagination support from the Marketplace API\n */\nexport async function fetchListCollectiblesPaginated(\n\tparams: WithRequired<\n\t\tListCollectiblesPaginatedQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'side' | 'config'\n\t>,\n): Promise<ListCollectiblesResponse> {\n\tconst {\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tconfig,\n\t\tpage = 1,\n\t\tpageSize = 30,\n\t\tfilter,\n\t\t...additionalApiParams\n\t} = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\t// Transform price filters from strings to BigInt for API\n\tconst transformedFilter = filter\n\t\t? {\n\t\t\t\t...filter,\n\t\t\t\tprices: normalizePriceFilters(filter.prices),\n\t\t\t}\n\t\t: undefined;\n\n\treturn await marketplaceClient.listCollectibles({\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tpage: {\n\t\t\tpage,\n\t\t\tpageSize,\n\t\t},\n\t\tfilter: transformedFilter,\n\t\t...additionalApiParams,\n\t});\n}\n\n/**\n * Query key structure: [resource, operation, params]\n * @example ['collectible', 'market-list-paginated', { chainId, contractAddress, side, filter, page }]\n */\nexport function getListCollectiblesPaginatedQueryKey(\n\tparams: ListCollectiblesPaginatedQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-list-paginated',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\tside: params.side,\n\t\t\tfilter: params.filter,\n\t\t\tpage: params.page,\n\t\t\tpageSize: params.pageSize,\n\t\t},\n\t] as const;\n}\n\nexport function listCollectiblesPaginatedQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListCollectiblesPaginatedQueryOptions,\n\t\t\t'collectionAddress' | 'chainId' | 'side' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListCollectiblesPaginatedQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'collectionAddress',\n\t\t\t\t'chainId',\n\t\t\t\t'side',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListCollectiblesPaginated,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tListCollectibleListingsResponse,\n\tListListingsForCollectibleRequest,\n} from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type ListListingsForCollectibleQueryOptions =\n\tSdkQueryParams<ListListingsForCollectibleRequest>;\n\n/**\n * Fetches listings for a specific collectible from the Marketplace API\n */\nexport async function fetchListListingsForCollectible(\n\tparams: WithRequired<\n\t\tListListingsForCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<ListCollectibleListingsResponse> {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\treturn await marketplaceClient.listListingsForCollectible(apiParams);\n}\n\nexport function getListListingsForCollectibleQueryKey(\n\tparams: ListListingsForCollectibleQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-listings',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t\tpage: params.page,\n\t\t},\n\t] as const;\n}\n\nexport function listListingsForCollectibleQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListListingsForCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListListingsForCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListListingsForCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { GetCountOfListingsForCollectibleRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchCountListingsForCollectibleParams =\n\tGetCountOfListingsForCollectibleRequest;\n\nexport type CountListingsForCollectibleQueryOptions =\n\tSdkQueryParams<FetchCountListingsForCollectibleParams>;\n\n/**\n * Fetches count of listings for a collectible from the marketplace API\n */\nexport async function fetchCountListingsForCollectible(\n\tparams: WithRequired<\n\t\tCountListingsForCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst client = getMarketplaceClient(config);\n\tconst result = await client.getCountOfListingsForCollectible(apiParams);\n\treturn result.count;\n}\n\nexport function getCountListingsForCollectibleQueryKey(\n\tparams: CountListingsForCollectibleQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-listings-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function countListingsForCollectibleQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCountListingsForCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCountListingsForCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchCountListingsForCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { Order } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\ttype GetLowestPriceListingForCollectibleRequest,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type LowestListingQueryOptions =\n\tSdkQueryParams<GetLowestPriceListingForCollectibleRequest>;\n\nexport async function fetchLowestListing(\n\tparams: WithRequired<\n\t\tLowestListingQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<Order | null> {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst result =\n\t\tawait marketplaceClient.getLowestPriceListingForCollectible(apiParams);\n\t// TanStack Query v5 requires non-undefined return values\n\treturn result.order ?? null;\n}\n\nexport function getLowestListingQueryKey(params: LowestListingQueryOptions) {\n\treturn [\n\t\t'collectible',\n\t\t'market-lowest-listing',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function lowestListingQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tLowestListingQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n): ReturnType<\n\ttypeof buildQueryOptions<\n\t\tWithRequired<\n\t\t\tLowestListingQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>,\n\t\tOrder | null,\n\t\treadonly ['chainId', 'collectionAddress', 'tokenId', 'config']\n\t>\n> {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getLowestListingQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchLowestListing,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import { isAddress } from 'viem';\nimport type {\n\tListCollectibleOffersResponse,\n\tListOffersForCollectibleRequest,\n\tPage,\n\tSortBy,\n\tWithOptionalParams,\n} from '../../_internal';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type ListOffersForCollectibleQueryOptions = SdkQueryParams<\n\tListOffersForCollectibleRequest & {\n\t\tsort?: Array<SortBy>;\n\t}\n>;\n\n/**\n * Fetches offers for a specific collectible from the Marketplace API\n */\nexport async function fetchListOffersForCollectible(\n\tparams: WithRequired<\n\t\tListOffersForCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<ListCollectibleOffersResponse> {\n\tconst { config, sort, page, ...additionalApiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst effectiveSort =\n\t\tsort || (page && 'sort' in page ? page.sort : undefined);\n\n\treturn await marketplaceClient.listOffersForCollectible({\n\t\t...additionalApiParams,\n\t\tpage:\n\t\t\tpage || effectiveSort\n\t\t\t\t? ({\n\t\t\t\t\t\tpage: page?.page ?? 1,\n\t\t\t\t\t\tpageSize: page?.pageSize ?? 20,\n\t\t\t\t\t\t...(page?.more && { more: page.more }),\n\t\t\t\t\t\t...(effectiveSort && { sort: effectiveSort }),\n\t\t\t\t\t} as Page)\n\t\t\t\t: undefined,\n\t});\n}\n\nexport function getListOffersForCollectibleQueryKey(\n\tparams: ListOffersForCollectibleQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-offers',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t\tpage: params.page,\n\t\t},\n\t] as const;\n}\n\nexport function listOffersForCollectibleQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tListOffersForCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getListOffersForCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchListOffersForCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type { GetCountOfOffersForCollectibleRequest } from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchCountOffersForCollectibleParams =\n\tGetCountOfOffersForCollectibleRequest;\n\nexport type CountOffersForCollectibleQueryOptions =\n\tSdkQueryParams<FetchCountOffersForCollectibleParams>;\n\n/**\n * Fetches count of offers for a collectible from the marketplace API\n */\nexport async function fetchCountOffersForCollectible(\n\tparams: WithRequired<\n\t\tCountOffersForCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n) {\n\tconst { config, ...apiParams } = params;\n\tconst client = getMarketplaceClient(config);\n\tconst result = await client.getCountOfOffersForCollectible(apiParams);\n\treturn result.count;\n}\n\nexport function getCountOffersForCollectibleQueryKey(\n\tparams: CountOffersForCollectibleQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'market-offers-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tcollectionAddress: params.collectionAddress ?? '',\n\t\t\ttokenId: params.tokenId ?? 0n,\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport function countOffersForCollectibleQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCountOffersForCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCountOffersForCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchCountOffersForCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.collectionAddress && isAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tGetSingleTokenMetadataArgs,\n\tGetTokenMetadataArgs,\n\tTokenMetadata,\n} from '@0xsequence/api-client';\nimport { isAddress } from 'viem';\nimport {\n\tbuildQueryOptions,\n\tgetMetadataClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectibleQueryKey } from './queryKeys';\n\nexport type FetchCollectibleParams = GetSingleTokenMetadataArgs;\n\nexport type CollectibleQueryOptions = SdkQueryParams<FetchCollectibleParams>;\n\n/**\n * Fetches collectible metadata from the metadata API\n */\nexport async function fetchCollectible(\n\tparams: WithRequired<\n\t\tCollectibleQueryOptions,\n\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<TokenMetadata | undefined> {\n\tconst { tokenId, chainId, collectionAddress, config } = params;\n\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst apiArgs: GetTokenMetadataArgs = {\n\t\tchainId,\n\t\tcontractAddress: collectionAddress,\n\t\ttokenIds: [tokenId],\n\t};\n\n\tconst result = await metadataClient.getTokenMetadata(apiArgs);\n\t// TanStack Query v5 requires non-undefined return values\n\treturn result.tokenMetadata[0] ?? null;\n}\n\n/**\n * Query key structure: [resource, operation, params]\n * @example ['collectible', 'metadata', { chainId, contractAddress, tokenIds }]\n */\nexport function getCollectibleQueryKey(params: CollectibleQueryOptions) {\n\tconst apiArgs = {\n\t\tchainId: params.chainId,\n\t\tcontractAddress: params.collectionAddress,\n\t\ttokenIds: params.tokenId !== undefined ? [params.tokenId] : [],\n\t};\n\n\treturn createCollectibleQueryKey('metadata', apiArgs);\n}\n\nexport function collectibleQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tCollectibleQueryOptions,\n\t\t\t'chainId' | 'collectionAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getCollectibleQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'collectionAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchCollectible,\n\t\t\tcustomValidation: (p) =>\n\t\t\t\t!!p.chainId &&\n\t\t\t\tp.chainId > 0 &&\n\t\t\t\t!!p.collectionAddress &&\n\t\t\t\tisAddress(p.collectionAddress),\n\t\t},\n\t\tparams,\n\t);\n}\n","import type {\n\tCollectiblePrimarySaleItem,\n\tGetPrimarySaleItemRequest,\n\tGetPrimarySaleItemResponse,\n\tTokenId,\n} from '@0xsequence/api-client';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\nimport { createCollectibleQueryKey } from './queryKeys';\n\nexport type FetchPrimarySaleItemParams = Omit<\n\tGetPrimarySaleItemRequest,\n\t'tokenId'\n> & {\n\ttokenId: TokenId | string;\n};\n\nexport type PrimarySaleItemQueryOptions =\n\tSdkQueryParams<FetchPrimarySaleItemParams>;\n\n/**\n * Fetches a single primary sale item from the marketplace API\n */\nexport async function fetchPrimarySaleItem(\n\tparams: WithRequired<\n\t\tPrimarySaleItemQueryOptions,\n\t\t'chainId' | 'primarySaleContractAddress' | 'tokenId' | 'config'\n\t>,\n): Promise<GetPrimarySaleItemResponse> {\n\tconst { chainId, primarySaleContractAddress, tokenId, config } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\treturn marketplaceClient.getPrimarySaleItem({\n\t\tchainId,\n\t\tprimarySaleContractAddress,\n\t\ttokenId: BigInt(tokenId),\n\t});\n}\n\nexport function getPrimarySaleItemQueryKey(\n\tparams: PrimarySaleItemQueryOptions,\n) {\n\treturn createCollectibleQueryKey('primary-sale-item', {\n\t\tchainId: params.chainId ?? 0,\n\t\tprimarySaleContractAddress: params.primarySaleContractAddress ?? '',\n\t\ttokenId: params.tokenId?.toString() ?? '',\n\t});\n}\n\nexport function primarySaleItemQueryOptions(\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tPrimarySaleItemQueryOptions,\n\t\t\t'chainId' | 'primarySaleContractAddress' | 'tokenId' | 'config'\n\t\t>\n\t>,\n) {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getPrimarySaleItemQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'chainId',\n\t\t\t\t'primarySaleContractAddress',\n\t\t\t\t'tokenId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchPrimarySaleItem,\n\t\t},\n\t\tparams,\n\t);\n}\n\nexport type { CollectiblePrimarySaleItem, GetPrimarySaleItemResponse };\n","import type {\n\tListPrimarySaleItemsRequest,\n\tListPrimarySaleItemsResponse,\n} from '@0xsequence/api-client';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport {\n\tgetMarketplaceClient,\n\ttype SdkInfiniteQueryParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchPrimarySaleItemsParams = ListPrimarySaleItemsRequest;\n\nexport type ListPrimarySaleItemsQueryOptions =\n\tSdkInfiniteQueryParams<FetchPrimarySaleItemsParams>;\n\n/**\n * Fetches primary sale items from the marketplace API\n */\nexport async function fetchPrimarySaleItems(\n\tparams: WithRequired<\n\t\tListPrimarySaleItemsQueryOptions,\n\t\t'chainId' | 'primarySaleContractAddress' | 'config'\n\t>,\n): Promise<ListPrimarySaleItemsResponse> {\n\tconst { chainId, primarySaleContractAddress, filter, page, config } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\treturn marketplaceClient.listPrimarySaleItems({\n\t\tchainId,\n\t\tprimarySaleContractAddress,\n\t\tfilter,\n\t\tpage,\n\t});\n}\n\nexport function getPrimarySaleItemsQueryKey(\n\tparams: ListPrimarySaleItemsQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'primary-sale-items',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tprimarySaleContractAddress: params.primarySaleContractAddress ?? '',\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport const primarySaleItemsQueryOptions = (\n\tparams: ListPrimarySaleItemsQueryOptions,\n) => {\n\tconst enabled = Boolean(\n\t\tparams.primarySaleContractAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\ttype PageParam = { page: number; pageSize: number };\n\tconst initialPage: PageParam = params.page || { page: 1, pageSize: 30 };\n\n\tconst queryFn = async ({ pageParam }: { pageParam: PageParam }) => {\n\t\tconst requiredParams = params as WithRequired<\n\t\t\tListPrimarySaleItemsQueryOptions,\n\t\t\t'chainId' | 'primarySaleContractAddress' | 'config'\n\t\t>;\n\t\treturn fetchPrimarySaleItems({\n\t\t\tchainId: requiredParams.chainId,\n\t\t\tprimarySaleContractAddress: requiredParams.primarySaleContractAddress,\n\t\t\tfilter: params.filter,\n\t\t\tpage: pageParam,\n\t\t\tconfig: requiredParams.config,\n\t\t});\n\t};\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: getPrimarySaleItemsQueryKey(params),\n\t\tqueryFn,\n\t\tinitialPageParam: initialPage,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more\n\t\t\t\t? {\n\t\t\t\t\t\tpage: lastPage.page.page + 1,\n\t\t\t\t\t\tpageSize: lastPage.page.pageSize,\n\t\t\t\t\t\tmore: true,\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t...params.query,\n\t\tenabled,\n\t});\n};\n\nexport type { ListPrimarySaleItemsRequest, ListPrimarySaleItemsResponse };\n","import type {\n\tGetCountOfPrimarySaleItemsRequest,\n\tGetCountOfPrimarySaleItemsResponse,\n} from '@0xsequence/api-client';\nimport {\n\tbuildQueryOptions,\n\tgetMarketplaceClient,\n\ttype SdkQueryParams,\n\ttype WithOptionalParams,\n\ttype WithRequired,\n} from '../../_internal';\n\nexport type FetchPrimarySaleItemsCountParams =\n\tGetCountOfPrimarySaleItemsRequest;\n\nexport type PrimarySaleItemsCountQueryOptions =\n\tSdkQueryParams<FetchPrimarySaleItemsCountParams>;\n\n/**\n * Fetches the count of primary sale items from the marketplace API\n */\nexport async function fetchPrimarySaleItemsCount(\n\tparams: WithRequired<\n\t\tPrimarySaleItemsCountQueryOptions,\n\t\t'chainId' | 'primarySaleContractAddress' | 'config'\n\t>,\n): Promise<GetCountOfPrimarySaleItemsResponse> {\n\tconst { config, ...apiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\treturn marketplaceClient.getCountOfPrimarySaleItems(apiParams);\n}\n\nexport function getPrimarySaleItemsCountQueryKey(\n\tparams: PrimarySaleItemsCountQueryOptions,\n) {\n\treturn [\n\t\t'collectible',\n\t\t'primary-sale-items-count',\n\t\t{\n\t\t\tchainId: params.chainId ?? 0,\n\t\t\tprimarySaleContractAddress: params.primarySaleContractAddress ?? '',\n\t\t\tfilter: params.filter,\n\t\t},\n\t] as const;\n}\n\nexport const primarySaleItemsCountQueryOptions = (\n\tparams: WithOptionalParams<\n\t\tWithRequired<\n\t\t\tPrimarySaleItemsCountQueryOptions,\n\t\t\t'primarySaleContractAddress' | 'chainId' | 'config'\n\t\t>\n\t>,\n) => {\n\treturn buildQueryOptions(\n\t\t{\n\t\t\tgetQueryKey: getPrimarySaleItemsCountQueryKey,\n\t\t\trequiredParams: [\n\t\t\t\t'primarySaleContractAddress',\n\t\t\t\t'chainId',\n\t\t\t\t'config',\n\t\t\t] as const,\n\t\t\tfetcher: fetchPrimarySaleItemsCount,\n\t\t},\n\t\tparams,\n\t);\n};\n"],"mappings":"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"}