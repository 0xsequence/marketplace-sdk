{"version":3,"file":"inventory--t6Zu55O.js","names":["token: TokenBalance","chainId: number","accountAddress: Address","collectionAddress: Address","config: SdkConfig","args: GetInventoryArgs","page: Page","args: UseInventoryArgs"],"sources":["../src/react/queries/inventory/inventory.ts"],"sourcesContent":["import type { ContractInfo, TokenBalance } from '@0xsequence/indexer';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { Page, SdkConfig } from '../../../types';\nimport { compareAddress } from '../../../utils';\nimport {\n\ttype ContractType,\n\tgetQueryClient,\n\tMetadataStatus,\n} from '../../_internal';\nimport { tokenBalancesOptions } from '../collectibles/tokenBalances';\nimport { fetchMarketplaceConfig } from '../market/marketplaceConfig';\n\nexport interface UseInventoryArgs {\n\taccountAddress: Address;\n\tcollectionAddress: Address;\n\tchainId: number;\n\tincludeNonTradable?: boolean;\n\tquery?: {\n\t\tenabled?: boolean;\n\t\tpage?: number;\n\t\tpageSize?: number;\n\t};\n}\n\ntype GetInventoryArgs = Omit<UseInventoryArgs, 'query'>;\n\ninterface CollectibleWithBalance {\n\tmetadata: {\n\t\ttokenId: string;\n\t\tattributes: Array<any>;\n\t\timage?: string;\n\t\tname: string;\n\t\tdescription?: string;\n\t\tvideo?: string;\n\t\taudio?: string;\n\t\tstatus: MetadataStatus;\n\t};\n\tbalance: string;\n\tcontractInfo?: ContractInfo;\n\tcontractType: ContractType.ERC1155 | ContractType.ERC721;\n}\n\nexport interface CollectiblesResponse {\n\tcollectibles: CollectibleWithBalance[];\n\tpage: Page;\n\tisTradable: boolean;\n}\n\nfunction collectibleFromTokenBalance(\n\ttoken: TokenBalance,\n): CollectibleWithBalance {\n\treturn {\n\t\tmetadata: {\n\t\t\ttokenId: token.tokenID ?? '',\n\t\t\tattributes: token.tokenMetadata?.attributes ?? [],\n\t\t\timage: token.tokenMetadata?.image,\n\t\t\tname: token.tokenMetadata?.name ?? '',\n\t\t\tdescription: token.tokenMetadata?.description,\n\t\t\tvideo: token.tokenMetadata?.video,\n\t\t\taudio: token.tokenMetadata?.audio,\n\t\t\tstatus: MetadataStatus.AVAILABLE,\n\t\t},\n\t\tcontractInfo: token.contractInfo,\n\t\tcontractType: token.contractType as unknown as\n\t\t\t| ContractType.ERC1155\n\t\t\t| ContractType.ERC721,\n\t\tbalance: token.balance,\n\t};\n}\n\nasync function fetchIndexerTokens(\n\tchainId: number,\n\taccountAddress: Address,\n\tcollectionAddress: Address,\n\tconfig: SdkConfig,\n): Promise<{ collectibles: CollectibleWithBalance[] }> {\n\tconst queryClient = getQueryClient();\n\tconst balances = await queryClient.fetchQuery(\n\t\ttokenBalancesOptions(\n\t\t\t{\n\t\t\t\tcollectionAddress,\n\t\t\t\tuserAddress: accountAddress,\n\t\t\t\tchainId,\n\t\t\t\tincludeMetadata: true,\n\t\t\t},\n\t\t\tconfig,\n\t\t),\n\t);\n\n\tconst collectibles = balances.map((balance) =>\n\t\tcollectibleFromTokenBalance(balance),\n\t);\n\n\treturn {\n\t\tcollectibles,\n\t};\n}\n\nexport async function fetchInventory(\n\targs: GetInventoryArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<CollectiblesResponse> {\n\tconst { accountAddress, collectionAddress, chainId } = args;\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\n\tconst marketCollections = marketplaceConfig?.market.collections || [];\n\n\tconst isMarketCollection = marketCollections.some((collection) =>\n\t\tcompareAddress(collection.itemsAddress, collectionAddress),\n\t);\n\n\t// Determine if this collection is tradable (market collection vs shop collection)\n\tconst isTradable = isMarketCollection;\n\n\t// Fetch collectibles from indexer\n\tconst { collectibles } = await fetchIndexerTokens(\n\t\tchainId,\n\t\taccountAddress,\n\t\tcollectionAddress,\n\t\tconfig,\n\t);\n\n\treturn {\n\t\tcollectibles,\n\t\tpage: {\n\t\t\tpage: page.page,\n\t\t\tpageSize: page.pageSize,\n\t\t},\n\t\tisTradable,\n\t};\n}\n\nexport function inventoryOptions(args: UseInventoryArgs, config: SdkConfig) {\n\tconst enabledQuery = args.query?.enabled ?? true;\n\tconst enabled =\n\t\tenabledQuery && !!args.accountAddress && !!args.collectionAddress;\n\n\treturn queryOptions({\n\t\tqueryKey: [\n\t\t\t'inventory',\n\t\t\targs.accountAddress,\n\t\t\targs.collectionAddress,\n\t\t\targs.chainId,\n\t\t\targs.query?.page ?? 1,\n\t\t\targs.query?.pageSize ?? 30,\n\t\t],\n\t\tqueryFn: () =>\n\t\t\tfetchInventory(\n\t\t\t\t{\n\t\t\t\t\t...args,\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t\t{\n\t\t\t\t\tpage: args.query?.page ?? 1,\n\t\t\t\t\tpageSize: args.query?.pageSize ?? 30,\n\t\t\t\t},\n\t\t\t),\n\t\tenabled,\n\t});\n}\n"],"mappings":";;;;;;;;AAiDA,SAAS,4BACRA,OACyB;AACzB,QAAO;EACN,UAAU;GACT,SAAS,MAAM,WAAW;GAC1B,YAAY,MAAM,eAAe,cAAc,CAAE;GACjD,OAAO,MAAM,eAAe;GAC5B,MAAM,MAAM,eAAe,QAAQ;GACnC,aAAa,MAAM,eAAe;GAClC,OAAO,MAAM,eAAe;GAC5B,OAAO,MAAM,eAAe;GAC5B,QAAQ,eAAe;EACvB;EACD,cAAc,MAAM;EACpB,cAAc,MAAM;EAGpB,SAAS,MAAM;CACf;AACD;AAED,eAAe,mBACdC,SACAC,gBACAC,mBACAC,QACsD;CACtD,MAAM,cAAc,gBAAgB;CACpC,MAAM,WAAW,MAAM,YAAY,WAClC,qBACC;EACC;EACA,aAAa;EACb;EACA,iBAAiB;CACjB,GACD,OACA,CACD;CAED,MAAM,eAAe,SAAS,IAAI,CAAC,YAClC,4BAA4B,QAAQ,CACpC;AAED,QAAO,EACN,aACA;AACD;AAED,eAAsB,eACrBC,MACAD,QACAE,MACgC;CAChC,MAAM,EAAE,gBAAgB,mBAAmB,SAAS,GAAG;CACvD,MAAM,oBAAoB,MAAM,uBAAuB,EAAE,OAAQ,EAAC;CAElE,MAAM,oBAAoB,mBAAmB,OAAO,eAAe,CAAE;CAErE,MAAM,qBAAqB,kBAAkB,KAAK,CAAC,eAClD,eAAe,WAAW,cAAc,kBAAkB,CAC1D;CAGD,MAAM,aAAa;CAGnB,MAAM,EAAE,cAAc,GAAG,MAAM,mBAC9B,SACA,gBACA,mBACA,OACA;AAED,QAAO;EACN;EACA,MAAM;GACL,MAAM,KAAK;GACX,UAAU,KAAK;EACf;EACD;CACA;AACD;AAED,SAAgB,iBAAiBC,MAAwBH,QAAmB;CAC3E,MAAM,eAAe,KAAK,OAAO,WAAW;CAC5C,MAAM,UACL,kBAAkB,KAAK,oBAAoB,KAAK;AAEjD,QAAO,aAAa;EACnB,UAAU;GACT;GACA,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK,OAAO,QAAQ;GACpB,KAAK,OAAO,YAAY;EACxB;EACD,SAAS,MACR,eACC,EACC,GAAG,KACH,GACD,QACA;GACC,MAAM,KAAK,OAAO,QAAQ;GAC1B,UAAU,KAAK,OAAO,YAAY;EAClC,EACD;EACF;CACA,EAAC;AACF"}