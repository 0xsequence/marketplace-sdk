/* eslint-disable */
// marketplace-api v0-25.11.10+051e186 4e2360c7b6314298aa3190c291646b7f0356c723
// --
// Code generated by Webrpc-gen@v0.31.1 with github.com/webrpc/gen-typescript@v0.23.1 generator. DO NOT EDIT.
//
// webrpc-gen -schema=./schema/schema.ridl -target=github.com/webrpc/gen-typescript@v0.23.1 -client -out=./clients/new-marketplace.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v0-25.11.10+051e186"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "4e2360c7b6314298aa3190c291646b7f0356c723"

//
// Client interface
//

export interface AdminClient {
  createCollection(req: CreateCollectionRequest, headers?: object, signal?: AbortSignal): Promise<CreateCollectionResponse>

  getCollection(req: GetCollectionRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionResponse>

  updateCollection(req: UpdateCollectionRequest, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionResponse>

  listCollections(req: ListCollectionsRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectionsResponse>

  deleteCollection(req: DeleteCollectionRequest, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionResponse>

  /**
   * determine what should happen here
   */
  syncCollection(req: SyncCollectionRequest, headers?: object, signal?: AbortSignal): Promise<SyncCollectionResponse>

  createPrimarySaleContract(req: CreatePrimarySaleContractRequest, headers?: object, signal?: AbortSignal): Promise<CreatePrimarySaleContractResponse>

  deletePrimarySaleContract(req: DeletePrimarySaleContractRequest, headers?: object, signal?: AbortSignal): Promise<DeletePrimarySaleContractResponse>

  createCurrency(req: CreateCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<CreateCurrencyResponse>

  createCurrencies(req: CreateCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<CreateCurrenciesResponse>

  updateCurrency(req: UpdateCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<UpdateCurrencyResponse>

  listCurrencies(req: ListCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesResponse>

  deleteCurrency(req: DeleteCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<DeleteCurrencyResponse>

  /**
   * This for manual adding of non minted ERC1155 tokens, it's used for purposes of Shop.
   */
  addCollectibles(req: AddCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<AddCollectiblesResponse>
}
export interface MarketplaceClient {
  listCurrencies(req: ListCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesResponse>

  getCollectionDetail(req: GetCollectionDetailRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionDetailResponse>

  getCollectionActiveListingsCurrencies(req: GetCollectionActiveListingsCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionActiveListingsCurrenciesResponse>

  getCollectionActiveOffersCurrencies(req: GetCollectionActiveOffersCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionActiveOffersCurrenciesResponse>

  getCollectible(req: GetCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleResponse>

  getLowestPriceOfferForCollectible(req: GetLowestPriceOfferForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetLowestPriceOfferForCollectibleResponse>

  getHighestPriceOfferForCollectible(req: GetHighestPriceOfferForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetHighestPriceOfferForCollectibleResponse>

  getLowestPriceListingForCollectible(req: GetLowestPriceListingForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetLowestPriceListingForCollectibleResponse>

  getHighestPriceListingForCollectible(req: GetHighestPriceListingForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetHighestPriceListingForCollectibleResponse>

  listListingsForCollectible(req: ListListingsForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<ListListingsForCollectibleResponse>

  listOffersForCollectible(req: ListOffersForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<ListOffersForCollectibleResponse>

  listOrdersWithCollectibles(req: ListOrdersWithCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<ListOrdersWithCollectiblesResponse>

  getCountOfAllOrders(req: GetCountOfAllOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfAllOrdersResponse>

  getCountOfFilteredOrders(req: GetCountOfFilteredOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfFilteredOrdersResponse>

  listListings(req: ListListingsRequest, headers?: object, signal?: AbortSignal): Promise<ListListingsResponse>

  listOffers(req: ListOffersRequest, headers?: object, signal?: AbortSignal): Promise<ListOffersResponse>

  getCountOfListingsForCollectible(req: GetCountOfListingsForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfListingsForCollectibleResponse>

  getCountOfOffersForCollectible(req: GetCountOfOffersForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfOffersForCollectibleResponse>

  /**
   * @deprecated Please use GetLowestPriceOfferForCollectible instead.
   */
  getCollectibleLowestOffer(req: GetCollectibleLowestOfferRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleLowestOfferResponse>

  /**
   * @deprecated Please use GetHighestPriceOfferForCollectible instead.
   */
  getCollectibleHighestOffer(req: GetCollectibleHighestOfferRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleHighestOfferResponse>

  /**
   * @deprecated Please use GetLowestPriceListingForCollectible instead.
   */
  getCollectibleLowestListing(req: GetCollectibleLowestListingRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleLowestListingResponse>

  /**
   * @deprecated Please use GetHighestPriceListingForCollectible instead.
   */
  getCollectibleHighestListing(req: GetCollectibleHighestListingRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleHighestListingResponse>

  /**
   * @deprecated Please use ListListingsForCollectible instead.
   */
  listCollectibleListings(req: ListCollectibleListingsRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleListingsResponse>

  /**
   * @deprecated Please use ListOffersForCollectible instead.
   */
  listCollectibleOffers(req: ListCollectibleOffersRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleOffersResponse>

  /**
   * checkout process
   */
  generateBuyTransaction(req: GenerateBuyTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateBuyTransactionResponse>

  generateSellTransaction(req: GenerateSellTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateSellTransactionResponse>

  generateListingTransaction(req: GenerateListingTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateListingTransactionResponse>

  generateOfferTransaction(req: GenerateOfferTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateOfferTransactionResponse>

  generateCancelTransaction(req: GenerateCancelTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateCancelTransactionResponse>

  /**
   * only used in a case of external transactions ( when we create off-chain transactions ) for instance opensea market, use only ExecuteInput params and leave other root inputs empty, they are depracated and kept only for backward compatibility
   */
  execute(req: ExecuteRequest, headers?: object, signal?: AbortSignal): Promise<ExecuteResponse>

  /**
   * list of collectibles with best order for each collectible, by default this only returns collectibles with an order
   */
  listCollectibles(req: ListCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesResponse>

  getCountOfAllCollectibles(req: GetCountOfAllCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfAllCollectiblesResponse>

  getCountOfFilteredCollectibles(req: GetCountOfFilteredCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfFilteredCollectiblesResponse>

  getFloorOrder(req: GetFloorOrderRequest, headers?: object, signal?: AbortSignal): Promise<GetFloorOrderResponse>

  /**
   * Not Implemented
   */
  listCollectionActivities(req: ListCollectionActivitiesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectionActivitiesResponse>

  /**
   * Not Implemented
   */
  listCollectibleActivities(req: ListCollectibleActivitiesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleActivitiesResponse>

  listCollectiblesWithLowestListing(req: ListCollectiblesWithLowestListingRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesWithLowestListingResponse>

  listCollectiblesWithHighestOffer(req: ListCollectiblesWithHighestOfferRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesWithHighestOfferResponse>

  syncOrder(req: SyncOrderRequest, headers?: object, signal?: AbortSignal): Promise<SyncOrderResponse>

  syncOrders(req: SyncOrdersRequest, headers?: object, signal?: AbortSignal): Promise<SyncOrdersResponse>

  getOrders(req: GetOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetOrdersResponse>

  checkoutOptionsMarketplace(req: CheckoutOptionsMarketplaceRequest, headers?: object, signal?: AbortSignal): Promise<CheckoutOptionsMarketplaceResponse>

  checkoutOptionsSalesContract(req: CheckoutOptionsSalesContractRequest, headers?: object, signal?: AbortSignal): Promise<CheckoutOptionsSalesContractResponse>

  supportedMarketplaces(req: SupportedMarketplacesRequest, headers?: object, signal?: AbortSignal): Promise<SupportedMarketplacesResponse>

  getPrimarySaleItem(req: GetPrimarySaleItemRequest, headers?: object, signal?: AbortSignal): Promise<GetPrimarySaleItemResponse>

  listPrimarySaleItems(req: ListPrimarySaleItemsRequest, headers?: object, signal?: AbortSignal): Promise<ListPrimarySaleItemsResponse>

  getCountOfPrimarySaleItems(req: GetCountOfPrimarySaleItemsRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfPrimarySaleItemsResponse>
}

//
// Schema types
//

export enum SortOrder {
  ASC = 'ASC',
  DESC = 'DESC'
}

export enum PropertyType {
  INT = 'INT',
  STRING = 'STRING',
  ARRAY = 'ARRAY',
  GENERIC = 'GENERIC'
}

export enum MarketplaceKind {
  unknown = 'unknown',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  blur = 'blur',
  zerox = 'zerox',
  opensea = 'opensea',
  looks_rare = 'looks_rare',
  x2y2 = 'x2y2',
  alienswap = 'alienswap',
  payment_processor = 'payment_processor',
  mintify = 'mintify',
  magic_eden = 'magic_eden'
}

export enum OrderbookKind {
  unknown = 'unknown',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  blur = 'blur',
  opensea = 'opensea',
  looks_rare = 'looks_rare',
  reservoir = 'reservoir',
  x2y2 = 'x2y2',
  magic_eden = 'magic_eden'
}

export enum SourceKind {
  unknown = 'unknown',
  external = 'external',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  opensea = 'opensea',
  magic_eden = 'magic_eden'
}

export enum OrderSide {
  unknown = 'unknown',
  listing = 'listing',
  offer = 'offer'
}

export enum OfferType {
  unknown = 'unknown',
  item = 'item',
  collection = 'collection'
}

export enum OrderStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive',
  expired = 'expired',
  cancelled = 'cancelled',
  filled = 'filled',
  decimals_missing = 'decimals_missing'
}

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155'
}

export enum CollectionPriority {
  unknown = 'unknown',
  low = 'low',
  normal = 'normal',
  high = 'high'
}

export enum CollectionStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_orders = 'syncing_orders',
  active = 'active',
  failed = 'failed',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type'
}

export enum ProjectStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive'
}

export enum ItemsContractStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_contract_metadata = 'syncing_contract_metadata',
  synced_contract_metadata = 'synced_contract_metadata',
  syncing_tokens = 'syncing_tokens',
  synced_tokens = 'synced_tokens',
  active = 'active',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type'
}

export enum CollectibleStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive'
}

export enum CollectibleSource {
  unknown = 'unknown',
  indexer = 'indexer',
  manual = 'manual'
}

export enum CurrencyStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_metadata = 'syncing_metadata',
  active = 'active',
  failed = 'failed'
}

export enum WalletKind {
  unknown = 'unknown',
  sequence = 'sequence'
}

export enum StepType {
  unknown = 'unknown',
  tokenApproval = 'tokenApproval',
  buy = 'buy',
  sell = 'sell',
  createListing = 'createListing',
  createOffer = 'createOffer',
  signEIP712 = 'signEIP712',
  signEIP191 = 'signEIP191',
  cancel = 'cancel'
}

export enum TransactionCrypto {
  none = 'none',
  partially = 'partially',
  all = 'all'
}

export enum TransactionNFTCheckoutProvider {
  unknown = 'unknown',
  transak = 'transak',
  sardine = 'sardine'
}

export enum TransactionOnRampProvider {
  unknown = 'unknown',
  transak = 'transak',
  sardine = 'sardine'
}

export enum TransactionSwapProvider {
  unknown = 'unknown',
  lifi = 'lifi'
}

export enum ExecuteType {
  unknown = 'unknown',
  order = 'order',
  createListing = 'createListing',
  createItemOffer = 'createItemOffer',
  createTraitOffer = 'createTraitOffer'
}

export enum ActivityAction {
  unknown = 'unknown',
  listing = 'listing',
  offer = 'offer',
  mint = 'mint',
  sale = 'sale',
  listingCancel = 'listingCancel',
  offerCancel = 'offerCancel',
  transfer = 'transfer'
}

export enum PrimarySaleContractStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_items = 'syncing_items',
  active = 'active',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type',
  failed = 'failed'
}

export enum PrimarySaleVersion {
  v0 = 'v0',
  v1 = 'v1'
}

export enum PrimarySaleItemDetailType {
  unknown = 'unknown',
  global = 'global',
  individual = 'individual'
}

export enum MetadataStatus {
  NOT_AVAILABLE = 'NOT_AVAILABLE',
  REFRESHING = 'REFRESHING',
  AVAILABLE = 'AVAILABLE'
}

export interface Page {
  page: number
  pageSize: number
  more?: boolean
  sort?: Array<SortBy>
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface Filter {
  text?: string
  properties?: Array<PropertyFilter>
}

export interface PropertyFilter {
  name: string
  type: PropertyType
  min?: number
  max?: number
  values?: Array<any>
}

export interface CollectiblesFilter {
  includeEmpty: boolean
  searchText?: string
  properties?: Array<PropertyFilter>
  marketplaces?: Array<MarketplaceKind>
  inAccounts?: Array<string>
  notInAccounts?: Array<string>
  ordersCreatedBy?: Array<string>
  ordersNotCreatedBy?: Array<string>
  inCurrencyAddresses?: Array<string>
  notInCurrencyAddresses?: Array<string>
  prices?: Array<PriceFilter>
}

export interface OrdersFilter {
  searchText?: string
  properties?: Array<PropertyFilter>
  marketplaces?: Array<MarketplaceKind>
  inAccounts?: Array<string>
  notInAccounts?: Array<string>
  ordersCreatedBy?: Array<string>
  ordersNotCreatedBy?: Array<string>
  inCurrencyAddresses?: Array<string>
  notInCurrencyAddresses?: Array<string>
  prices?: Array<PriceFilter>
}

export interface PriceFilter {
  contractAddress: string
  min?: bigint
  max?: bigint
}

export interface Order {
  orderId: string
  marketplace: MarketplaceKind
  side: OrderSide
  status: OrderStatus
  chainId: number
  originName: string
  slug: string
  collectionContractAddress: string
  tokenId?: bigint
  createdBy: string
  priceAmount: bigint
  priceAmountFormatted: string
  priceAmountNet: bigint
  priceAmountNetFormatted: string
  priceCurrencyAddress: string
  priceDecimals: number
  priceUSD: number
  priceUSDFormatted: string
  quantityInitial: bigint
  quantityInitialFormatted: string
  quantityRemaining: bigint
  quantityRemainingFormatted: string
  quantityAvailable: bigint
  quantityAvailableFormatted: string
  quantityDecimals: number
  feeBps: number
  feeBreakdown: Array<FeeBreakdown>
  validFrom: string
  validUntil: string
  blockNumber: number
  orderCreatedAt?: string
  orderUpdatedAt?: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface FeeBreakdown {
  kind: string
  recipientAddress: string
  bps: number
}

export interface CollectibleOrder {
  metadata: TokenMetadata
  order?: Order
  listing?: Order
  offer?: Order
}

export interface OrderFilter {
  createdBy?: Array<string>
  marketplace?: Array<MarketplaceKind>
  currencies?: Array<string>
}

export interface Collection {
  status: CollectionStatus
  chainId: number
  contractAddress: string
  contractType: ContractType
  priority: CollectionPriority
  tokenQuantityDecimals: number
  config: CollectionConfig
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface CollectionConfig {
  lastSynced: {[key: string]: CollectionLastSynced}
  collectiblesSynced: string
  activitiesSynced: string
  activitiesSyncedContinuity: string
}

export interface CollectionLastSynced {
  allOrders: string
  newOrders: string
  names: Array<string>
  cursors: {[key: string]: string}
}

export interface Project {
  projectId: number
  chainId: number
  contractAddress: string
  status: ProjectStatus
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface ItemsContract {
  status: ItemsContractStatus
  chainId: number
  contractAddress: string
  contractType: ContractType
  lastSynced: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface Collectible {
  status: CollectibleStatus
  tokenId: bigint
  decimals: number
  source: CollectibleSource
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface Currency {
  chainId: number
  contractAddress: string
  status: CurrencyStatus
  name: string
  symbol: string
  decimals: number
  imageUrl: string
  exchangeRate: number
  defaultChainCurrency: boolean
  nativeCurrency: boolean
  openseaListing: boolean
  openseaOffer: boolean
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface OrderData {
  orderId: string
  quantity: bigint
  tokenId?: bigint
}

export interface AdditionalFee {
  amount: bigint
  receiver: string
}

export interface Step {
  id: StepType
  data: string
  to: string
  value: bigint
  price: bigint
  signature?: Signature
  post?: PostRequest
  executeType?: ExecuteType
}

export interface PostRequest {
  endpoint: string
  method: string
  body: any
}

export interface CreateReq {
  tokenId: bigint
  quantity: bigint
  expiry: string
  currencyAddress: string
  pricePerToken: bigint
}

export interface GetOrdersInput {
  contractAddress: string
  orderId: string
  marketplace: MarketplaceKind
}

export interface Signature {
  domain: Domain
  types: any
  primaryType: string
  value: any
}

export interface Domain {
  name: string
  version: string
  chainId: number
  verifyingContract: string
}

export interface GenerateBuySellTransactionResponse {
  steps: Array<Step>
  canBeUsedWithTrails: boolean
}

export interface CheckoutOptionsMarketplaceOrder {
  contractAddress: string
  orderId: string
  marketplace: MarketplaceKind
}

export interface CheckoutOptionsItem {
  tokenId: bigint
  quantity: bigint
}

export interface CheckoutOptions {
  crypto: TransactionCrypto
  swap: Array<TransactionSwapProvider>
  nftCheckout: Array<TransactionNFTCheckoutProvider>
  onRamp: Array<TransactionOnRampProvider>
}

export interface ExecuteInput {
  chainId: string
  signature: string
  method: string
  endpoint: string
  executeType: ExecuteType
  body: any
  slug?: string
}

export interface Activity {
  chainId: number
  contractAddress: string
  tokenId: bigint
  action: ActivityAction
  txHash: string
  from: string
  to?: string
  quantity: bigint
  quantityDecimals: number
  priceAmount?: bigint
  priceAmountFormatted?: string
  priceCurrencyAddress?: string
  priceDecimals?: number
  activityCreatedAt: string
  uniqueHash: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface PrimarySaleContract {
  chainId: number
  contractAddress: string
  collectionAddress: string
  contractType: ContractType
  version: PrimarySaleVersion
  currencyAddress: string
  priceDecimals: number
  status: PrimarySaleContractStatus
  lastSynced: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface PrimarySaleItem {
  itemAddress: string
  contractType: ContractType
  tokenId: bigint
  itemType: PrimarySaleItemDetailType
  startDate: string
  endDate: string
  currencyAddress: string
  priceDecimals: number
  priceAmount: bigint
  priceAmountFormatted: string
  priceUsd: number
  priceUsdFormatted: string
  supply: bigint
  supplyCap: bigint
  unlimitedSupply: boolean
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface CollectiblePrimarySaleItem {
  metadata: TokenMetadata
  primarySaleItem: PrimarySaleItem
}

export interface PrimarySaleItemsFilter {
  includeEmpty: boolean
  searchText?: string
  properties?: Array<PropertyFilter>
  detailTypes?: Array<PrimarySaleItemDetailType>
  startDateAfter?: string
  startDateBefore?: string
  endDateAfter?: string
  endDateBefore?: string
}

export interface TokenMetadata {
  tokenId: bigint
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: {[key: string]: any}
  attributes: Array<{[key: string]: any}>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
  status: MetadataStatus
}

export interface Asset {
  id: number
  collectionId: number
  tokenId: bigint
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export interface CreateCollectionRequest {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface CreateCollectionResponse {
  collection: Collection
}

export interface GetCollectionRequest {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface GetCollectionResponse {
  collection: Collection
}

export interface UpdateCollectionRequest {
  chainId: string
  collection: Collection
}

export interface UpdateCollectionResponse {
  collection: Collection
}

export interface ListCollectionsRequest {
  chainId: string
  projectId: number
  page?: Page
}

export interface ListCollectionsResponse {
  collections: Array<Collection>
  page?: Page
}

export interface DeleteCollectionRequest {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface DeleteCollectionResponse {
  collection: Collection
}

export interface SyncCollectionRequest {
  chainId: string
  contractAddress: string
}

export interface SyncCollectionResponse {
}

export interface CreatePrimarySaleContractRequest {
  chainId: string
  projectId: number
  primarySaleContractAddress: string
  itemsContractAddress: string
}

export interface CreatePrimarySaleContractResponse {
  primarySaleContract: PrimarySaleContract
}

export interface DeletePrimarySaleContractRequest {
  chainId: string
  projectId: number
  primarySaleContractAddress: string
}

export interface DeletePrimarySaleContractResponse {
}

export interface CreateCurrencyRequest {
  chainId: string
  currency: Currency
}

export interface CreateCurrencyResponse {
  currency: Currency
}

export interface CreateCurrenciesRequest {
  chainId: string
  currencies: Array<Currency>
}

export interface CreateCurrenciesResponse {
  currency: {[key: string]: Currency}
}

export interface UpdateCurrencyRequest {
  chainId: string
  currency: Currency
}

export interface UpdateCurrencyResponse {
  currency: Currency
}

export interface ListCurrenciesRequest {
  chainId: string
}

export interface ListCurrenciesResponse {
  currencies: Array<Currency>
}

export interface DeleteCurrencyRequest {
  chainId: string
  contractAddress: string
}

export interface DeleteCurrencyResponse {
  currency: Currency
}

export interface AddCollectiblesRequest {
  chainId: string
  itemsContractAddress: string
  tokenIds: Array<bigint>
}

export interface AddCollectiblesResponse {
}

export interface ListCurrenciesRequest {
  chainId: string
}

export interface ListCurrenciesResponse {
  currencies: Array<Currency>
}

export interface GetCollectionDetailRequest {
  chainId: string
  contractAddress: string
}

export interface GetCollectionDetailResponse {
  collection: Collection
}

export interface GetCollectionActiveListingsCurrenciesRequest {
  chainId: string
  contractAddress: string
}

export interface GetCollectionActiveListingsCurrenciesResponse {
  currencies: Array<Currency>
}

export interface GetCollectionActiveOffersCurrenciesRequest {
  chainId: string
  contractAddress: string
}

export interface GetCollectionActiveOffersCurrenciesResponse {
  currencies: Array<Currency>
}

export interface GetCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
}

export interface GetCollectibleResponse {
  metadata: TokenMetadata
}

export interface GetLowestPriceOfferForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetLowestPriceOfferForCollectibleResponse {
  order: Order
}

export interface GetHighestPriceOfferForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetHighestPriceOfferForCollectibleResponse {
  order: Order
}

export interface GetLowestPriceListingForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetLowestPriceListingForCollectibleResponse {
  order: Order
}

export interface GetHighestPriceListingForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetHighestPriceListingForCollectibleResponse {
  order: Order
}

export interface ListListingsForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
  page?: Page
}

export interface ListListingsForCollectibleResponse {
  listings: Array<Order>
  page?: Page
}

export interface ListOffersForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
  page?: Page
}

export interface ListOffersForCollectibleResponse {
  offers: Array<Order>
  page?: Page
}

export interface ListOrdersWithCollectiblesRequest {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: OrdersFilter
  page?: Page
}

export interface ListOrdersWithCollectiblesResponse {
  collectibles: Array<CollectibleOrder>
  page?: Page
}

export interface GetCountOfAllOrdersRequest {
  chainId: string
  side: OrderSide
  contractAddress: string
}

export interface GetCountOfAllOrdersResponse {
  count: number
}

export interface GetCountOfFilteredOrdersRequest {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: OrdersFilter
}

export interface GetCountOfFilteredOrdersResponse {
  count: number
}

export interface ListListingsRequest {
  chainId: string
  contractAddress: string
  filter?: OrderFilter
  page?: Page
}

export interface ListListingsResponse {
  listings: Array<Order>
  page?: Page
}

export interface ListOffersRequest {
  chainId: string
  contractAddress: string
  filter?: OrderFilter
  page?: Page
}

export interface ListOffersResponse {
  offers: Array<Order>
  page?: Page
}

export interface GetCountOfListingsForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCountOfListingsForCollectibleResponse {
  count: number
}

export interface GetCountOfOffersForCollectibleRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCountOfOffersForCollectibleResponse {
  count: number
}

export interface GetCollectibleLowestOfferRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCollectibleLowestOfferResponse {
  order?: Order
}

export interface GetCollectibleHighestOfferRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCollectibleHighestOfferResponse {
  order?: Order
}

export interface GetCollectibleLowestListingRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCollectibleLowestListingResponse {
  order?: Order
}

export interface GetCollectibleHighestListingRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
}

export interface GetCollectibleHighestListingResponse {
  order?: Order
}

export interface ListCollectibleListingsRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
  page?: Page
}

export interface ListCollectibleListingsResponse {
  listings: Array<Order>
  page?: Page
}

export interface ListCollectibleOffersRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  filter?: OrderFilter
  page?: Page
}

export interface ListCollectibleOffersResponse {
  offers: Array<Order>
  page?: Page
}

export interface GenerateBuyTransactionRequest {
  chainId: string
  collectionAddress: string
  buyer: string
  marketplace: MarketplaceKind
  ordersData: Array<OrderData>
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
  useWithTrails: boolean
}

export interface GenerateBuyTransactionResponse {
  resp: GenerateBuySellTransactionResponse
  steps: Array<Step>
}

export interface GenerateSellTransactionRequest {
  chainId: string
  collectionAddress: string
  seller: string
  marketplace: MarketplaceKind
  ordersData: Array<OrderData>
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
  useWithTrails: boolean
}

export interface GenerateSellTransactionResponse {
  resp: GenerateBuySellTransactionResponse
  steps: Array<Step>
}

export interface GenerateListingTransactionRequest {
  chainId: string
  collectionAddress: string
  owner: string
  contractType: ContractType
  orderbook: OrderbookKind
  listing: CreateReq
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
}

export interface GenerateListingTransactionResponse {
  steps: Array<Step>
}

export interface GenerateOfferTransactionRequest {
  chainId: string
  collectionAddress: string
  maker: string
  contractType: ContractType
  orderbook: OrderbookKind
  offer: CreateReq
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
  offerType: OfferType
}

export interface GenerateOfferTransactionResponse {
  steps: Array<Step>
}

export interface GenerateCancelTransactionRequest {
  chainId: string
  collectionAddress: string
  maker: string
  marketplace: MarketplaceKind
  orderId: string
}

export interface GenerateCancelTransactionResponse {
  steps: Array<Step>
}

export interface ExecuteRequest {
  params: ExecuteInput
  chainId?: string
  signature?: string
  method?: string
  endpoint?: string
  executeType?: ExecuteType
  body?: any
}

export interface ExecuteResponse {
  orderId: string
}

export interface ListCollectiblesRequest {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesResponse {
  collectibles: Array<CollectibleOrder>
  page?: Page
}

export interface GetCountOfAllCollectiblesRequest {
  chainId: string
  contractAddress: string
}

export interface GetCountOfAllCollectiblesResponse {
  count: number
}

export interface GetCountOfFilteredCollectiblesRequest {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: CollectiblesFilter
}

export interface GetCountOfFilteredCollectiblesResponse {
  count: number
}

export interface GetFloorOrderRequest {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
}

export interface GetFloorOrderResponse {
  collectible: CollectibleOrder
}

export interface ListCollectionActivitiesRequest {
  chainId: string
  contractAddress: string
  page?: Page
}

export interface ListCollectionActivitiesResponse {
  activities: Array<Activity>
  page?: Page
}

export interface ListCollectibleActivitiesRequest {
  chainId: string
  contractAddress: string
  tokenId: bigint
  page?: Page
}

export interface ListCollectibleActivitiesResponse {
  activities: Array<Activity>
  page?: Page
}

export interface ListCollectiblesWithLowestListingRequest {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesWithLowestListingResponse {
  collectibles: Array<CollectibleOrder>
  page?: Page
}

export interface ListCollectiblesWithHighestOfferRequest {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesWithHighestOfferResponse {
  collectibles: Array<CollectibleOrder>
  page?: Page
}

export interface SyncOrderRequest {
  chainId: string
  order: Order
}

export interface SyncOrderResponse {
}

export interface SyncOrdersRequest {
  chainId: string
  orders: Array<Order>
}

export interface SyncOrdersResponse {
}

export interface GetOrdersRequest {
  chainId: string
  input: Array<GetOrdersInput>
  page?: Page
}

export interface GetOrdersResponse {
  orders: Array<Order>
  page?: Page
}

export interface CheckoutOptionsMarketplaceRequest {
  chainId: string
  wallet: string
  orders: Array<CheckoutOptionsMarketplaceOrder>
  additionalFee: number
}

export interface CheckoutOptionsMarketplaceResponse {
  options: CheckoutOptions
}

export interface CheckoutOptionsSalesContractRequest {
  chainId: string
  wallet: string
  contractAddress: string
  collectionAddress: string
  items: Array<CheckoutOptionsItem>
}

export interface CheckoutOptionsSalesContractResponse {
  options: CheckoutOptions
}

export interface SupportedMarketplacesRequest {
  chainId: string
}

export interface SupportedMarketplacesResponse {
  marketplaces: Array<MarketplaceKind>
}

export interface GetPrimarySaleItemRequest {
  chainId: string
  primarySaleContractAddress: string
  tokenId: bigint
}

export interface GetPrimarySaleItemResponse {
  item: CollectiblePrimarySaleItem
}

export interface ListPrimarySaleItemsRequest {
  chainId: string
  primarySaleContractAddress: string
  filter?: PrimarySaleItemsFilter
  page?: Page
}

export interface ListPrimarySaleItemsResponse {
  primarySaleItems: Array<CollectiblePrimarySaleItem>
  page?: Page
}

export interface GetCountOfPrimarySaleItemsRequest {
  chainId: string
  primarySaleContractAddress: string
  filter?: PrimarySaleItemsFilter
}

export interface GetCountOfPrimarySaleItemsResponse {
  count: number
}

//
// Client
//

export class Admin implements AdminClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Admin/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  queryKey = {
    createCollection: (req: CreateCollectionRequest) => ['Admin', 'createCollection', req] as const,
    getCollection: (req: GetCollectionRequest) => ['Admin', 'getCollection', req] as const,
    updateCollection: (req: UpdateCollectionRequest) => ['Admin', 'updateCollection', req] as const,
    listCollections: (req: ListCollectionsRequest) => ['Admin', 'listCollections', req] as const,
    deleteCollection: (req: DeleteCollectionRequest) => ['Admin', 'deleteCollection', req] as const,
    syncCollection: (req: SyncCollectionRequest) => ['Admin', 'syncCollection', req] as const,
    createPrimarySaleContract: (req: CreatePrimarySaleContractRequest) => ['Admin', 'createPrimarySaleContract', req] as const,
    deletePrimarySaleContract: (req: DeletePrimarySaleContractRequest) => ['Admin', 'deletePrimarySaleContract', req] as const,
    createCurrency: (req: CreateCurrencyRequest) => ['Admin', 'createCurrency', req] as const,
    createCurrencies: (req: CreateCurrenciesRequest) => ['Admin', 'createCurrencies', req] as const,
    updateCurrency: (req: UpdateCurrencyRequest) => ['Admin', 'updateCurrency', req] as const,
    listCurrencies: (req: ListCurrenciesRequest) => ['Admin', 'listCurrencies', req] as const,
    deleteCurrency: (req: DeleteCurrencyRequest) => ['Admin', 'deleteCurrency', req] as const,
    addCollectibles: (req: AddCollectiblesRequest) => ['Admin', 'addCollectibles', req] as const,
  }

  createCollection = (req: CreateCollectionRequest, headers?: object, signal?: AbortSignal): Promise<CreateCollectionResponse> => {
    return this.fetch(
      this.url('CreateCollection'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CreateCollectionResponse>(_data, 'CreateCollectionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollection = (req: GetCollectionRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionResponse> => {
    return this.fetch(
      this.url('GetCollection'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectionResponse>(_data, 'GetCollectionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  updateCollection = (req: UpdateCollectionRequest, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionResponse> => {
    return this.fetch(
      this.url('UpdateCollection'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<UpdateCollectionResponse>(_data, 'UpdateCollectionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollections = (req: ListCollectionsRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectionsResponse> => {
    return this.fetch(
      this.url('ListCollections'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectionsResponse>(_data, 'ListCollectionsResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  deleteCollection = (req: DeleteCollectionRequest, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionResponse> => {
    return this.fetch(
      this.url('DeleteCollection'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<DeleteCollectionResponse>(_data, 'DeleteCollectionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  syncCollection = (req: SyncCollectionRequest, headers?: object, signal?: AbortSignal): Promise<SyncCollectionResponse> => {
    return this.fetch(
      this.url('SyncCollection'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SyncCollectionResponse>(_data, 'SyncCollectionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  createPrimarySaleContract = (req: CreatePrimarySaleContractRequest, headers?: object, signal?: AbortSignal): Promise<CreatePrimarySaleContractResponse> => {
    return this.fetch(
      this.url('CreatePrimarySaleContract'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CreatePrimarySaleContractResponse>(_data, 'CreatePrimarySaleContractResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  deletePrimarySaleContract = (req: DeletePrimarySaleContractRequest, headers?: object, signal?: AbortSignal): Promise<DeletePrimarySaleContractResponse> => {
    return this.fetch(
      this.url('DeletePrimarySaleContract'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<DeletePrimarySaleContractResponse>(_data, 'DeletePrimarySaleContractResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  createCurrency = (req: CreateCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<CreateCurrencyResponse> => {
    return this.fetch(
      this.url('CreateCurrency'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CreateCurrencyResponse>(_data, 'CreateCurrencyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  createCurrencies = (req: CreateCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<CreateCurrenciesResponse> => {
    return this.fetch(
      this.url('CreateCurrencies'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CreateCurrenciesResponse>(_data, 'CreateCurrenciesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  updateCurrency = (req: UpdateCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<UpdateCurrencyResponse> => {
    return this.fetch(
      this.url('UpdateCurrency'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<UpdateCurrencyResponse>(_data, 'UpdateCurrencyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCurrencies = (req: ListCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesResponse> => {
    return this.fetch(
      this.url('ListCurrencies'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCurrenciesResponse>(_data, 'ListCurrenciesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  deleteCurrency = (req: DeleteCurrencyRequest, headers?: object, signal?: AbortSignal): Promise<DeleteCurrencyResponse> => {
    return this.fetch(
      this.url('DeleteCurrency'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<DeleteCurrencyResponse>(_data, 'DeleteCurrencyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  addCollectibles = (req: AddCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<AddCollectiblesResponse> => {
    return this.fetch(
      this.url('AddCollectibles'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<AddCollectiblesResponse>(_data, 'AddCollectiblesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

}
export class Marketplace implements MarketplaceClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Marketplace/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  queryKey = {
    listCurrencies: (req: ListCurrenciesRequest) => ['Marketplace', 'listCurrencies', req] as const,
    getCollectionDetail: (req: GetCollectionDetailRequest) => ['Marketplace', 'getCollectionDetail', req] as const,
    getCollectionActiveListingsCurrencies: (req: GetCollectionActiveListingsCurrenciesRequest) => ['Marketplace', 'getCollectionActiveListingsCurrencies', req] as const,
    getCollectionActiveOffersCurrencies: (req: GetCollectionActiveOffersCurrenciesRequest) => ['Marketplace', 'getCollectionActiveOffersCurrencies', req] as const,
    getCollectible: (req: GetCollectibleRequest) => ['Marketplace', 'getCollectible', req] as const,
    getLowestPriceOfferForCollectible: (req: GetLowestPriceOfferForCollectibleRequest) => ['Marketplace', 'getLowestPriceOfferForCollectible', req] as const,
    getHighestPriceOfferForCollectible: (req: GetHighestPriceOfferForCollectibleRequest) => ['Marketplace', 'getHighestPriceOfferForCollectible', req] as const,
    getLowestPriceListingForCollectible: (req: GetLowestPriceListingForCollectibleRequest) => ['Marketplace', 'getLowestPriceListingForCollectible', req] as const,
    getHighestPriceListingForCollectible: (req: GetHighestPriceListingForCollectibleRequest) => ['Marketplace', 'getHighestPriceListingForCollectible', req] as const,
    listListingsForCollectible: (req: ListListingsForCollectibleRequest) => ['Marketplace', 'listListingsForCollectible', req] as const,
    listOffersForCollectible: (req: ListOffersForCollectibleRequest) => ['Marketplace', 'listOffersForCollectible', req] as const,
    listOrdersWithCollectibles: (req: ListOrdersWithCollectiblesRequest) => ['Marketplace', 'listOrdersWithCollectibles', req] as const,
    getCountOfAllOrders: (req: GetCountOfAllOrdersRequest) => ['Marketplace', 'getCountOfAllOrders', req] as const,
    getCountOfFilteredOrders: (req: GetCountOfFilteredOrdersRequest) => ['Marketplace', 'getCountOfFilteredOrders', req] as const,
    listListings: (req: ListListingsRequest) => ['Marketplace', 'listListings', req] as const,
    listOffers: (req: ListOffersRequest) => ['Marketplace', 'listOffers', req] as const,
    getCountOfListingsForCollectible: (req: GetCountOfListingsForCollectibleRequest) => ['Marketplace', 'getCountOfListingsForCollectible', req] as const,
    getCountOfOffersForCollectible: (req: GetCountOfOffersForCollectibleRequest) => ['Marketplace', 'getCountOfOffersForCollectible', req] as const,
    getCollectibleLowestOffer: (req: GetCollectibleLowestOfferRequest) => ['Marketplace', 'getCollectibleLowestOffer', req] as const,
    getCollectibleHighestOffer: (req: GetCollectibleHighestOfferRequest) => ['Marketplace', 'getCollectibleHighestOffer', req] as const,
    getCollectibleLowestListing: (req: GetCollectibleLowestListingRequest) => ['Marketplace', 'getCollectibleLowestListing', req] as const,
    getCollectibleHighestListing: (req: GetCollectibleHighestListingRequest) => ['Marketplace', 'getCollectibleHighestListing', req] as const,
    listCollectibleListings: (req: ListCollectibleListingsRequest) => ['Marketplace', 'listCollectibleListings', req] as const,
    listCollectibleOffers: (req: ListCollectibleOffersRequest) => ['Marketplace', 'listCollectibleOffers', req] as const,
    generateBuyTransaction: (req: GenerateBuyTransactionRequest) => ['Marketplace', 'generateBuyTransaction', req] as const,
    generateSellTransaction: (req: GenerateSellTransactionRequest) => ['Marketplace', 'generateSellTransaction', req] as const,
    generateListingTransaction: (req: GenerateListingTransactionRequest) => ['Marketplace', 'generateListingTransaction', req] as const,
    generateOfferTransaction: (req: GenerateOfferTransactionRequest) => ['Marketplace', 'generateOfferTransaction', req] as const,
    generateCancelTransaction: (req: GenerateCancelTransactionRequest) => ['Marketplace', 'generateCancelTransaction', req] as const,
    execute: (req: ExecuteRequest) => ['Marketplace', 'execute', req] as const,
    listCollectibles: (req: ListCollectiblesRequest) => ['Marketplace', 'listCollectibles', req] as const,
    getCountOfAllCollectibles: (req: GetCountOfAllCollectiblesRequest) => ['Marketplace', 'getCountOfAllCollectibles', req] as const,
    getCountOfFilteredCollectibles: (req: GetCountOfFilteredCollectiblesRequest) => ['Marketplace', 'getCountOfFilteredCollectibles', req] as const,
    getFloorOrder: (req: GetFloorOrderRequest) => ['Marketplace', 'getFloorOrder', req] as const,
    listCollectionActivities: (req: ListCollectionActivitiesRequest) => ['Marketplace', 'listCollectionActivities', req] as const,
    listCollectibleActivities: (req: ListCollectibleActivitiesRequest) => ['Marketplace', 'listCollectibleActivities', req] as const,
    listCollectiblesWithLowestListing: (req: ListCollectiblesWithLowestListingRequest) => ['Marketplace', 'listCollectiblesWithLowestListing', req] as const,
    listCollectiblesWithHighestOffer: (req: ListCollectiblesWithHighestOfferRequest) => ['Marketplace', 'listCollectiblesWithHighestOffer', req] as const,
    syncOrder: (req: SyncOrderRequest) => ['Marketplace', 'syncOrder', req] as const,
    syncOrders: (req: SyncOrdersRequest) => ['Marketplace', 'syncOrders', req] as const,
    getOrders: (req: GetOrdersRequest) => ['Marketplace', 'getOrders', req] as const,
    checkoutOptionsMarketplace: (req: CheckoutOptionsMarketplaceRequest) => ['Marketplace', 'checkoutOptionsMarketplace', req] as const,
    checkoutOptionsSalesContract: (req: CheckoutOptionsSalesContractRequest) => ['Marketplace', 'checkoutOptionsSalesContract', req] as const,
    supportedMarketplaces: (req: SupportedMarketplacesRequest) => ['Marketplace', 'supportedMarketplaces', req] as const,
    getPrimarySaleItem: (req: GetPrimarySaleItemRequest) => ['Marketplace', 'getPrimarySaleItem', req] as const,
    listPrimarySaleItems: (req: ListPrimarySaleItemsRequest) => ['Marketplace', 'listPrimarySaleItems', req] as const,
    getCountOfPrimarySaleItems: (req: GetCountOfPrimarySaleItemsRequest) => ['Marketplace', 'getCountOfPrimarySaleItems', req] as const,
  }

  listCurrencies = (req: ListCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesResponse> => {
    return this.fetch(
      this.url('ListCurrencies'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCurrenciesResponse>(_data, 'ListCurrenciesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectionDetail = (req: GetCollectionDetailRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionDetailResponse> => {
    return this.fetch(
      this.url('GetCollectionDetail'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectionDetailResponse>(_data, 'GetCollectionDetailResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectionActiveListingsCurrencies = (req: GetCollectionActiveListingsCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionActiveListingsCurrenciesResponse> => {
    return this.fetch(
      this.url('GetCollectionActiveListingsCurrencies'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectionActiveListingsCurrenciesResponse>(_data, 'GetCollectionActiveListingsCurrenciesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectionActiveOffersCurrencies = (req: GetCollectionActiveOffersCurrenciesRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectionActiveOffersCurrenciesResponse> => {
    return this.fetch(
      this.url('GetCollectionActiveOffersCurrencies'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectionActiveOffersCurrenciesResponse>(_data, 'GetCollectionActiveOffersCurrenciesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectible = (req: GetCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleResponse> => {
    return this.fetch(
      this.url('GetCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectibleResponse>(_data, 'GetCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getLowestPriceOfferForCollectible = (req: GetLowestPriceOfferForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetLowestPriceOfferForCollectibleResponse> => {
    return this.fetch(
      this.url('GetLowestPriceOfferForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetLowestPriceOfferForCollectibleResponse>(_data, 'GetLowestPriceOfferForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getHighestPriceOfferForCollectible = (req: GetHighestPriceOfferForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetHighestPriceOfferForCollectibleResponse> => {
    return this.fetch(
      this.url('GetHighestPriceOfferForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetHighestPriceOfferForCollectibleResponse>(_data, 'GetHighestPriceOfferForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getLowestPriceListingForCollectible = (req: GetLowestPriceListingForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetLowestPriceListingForCollectibleResponse> => {
    return this.fetch(
      this.url('GetLowestPriceListingForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetLowestPriceListingForCollectibleResponse>(_data, 'GetLowestPriceListingForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getHighestPriceListingForCollectible = (req: GetHighestPriceListingForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetHighestPriceListingForCollectibleResponse> => {
    return this.fetch(
      this.url('GetHighestPriceListingForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetHighestPriceListingForCollectibleResponse>(_data, 'GetHighestPriceListingForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listListingsForCollectible = (req: ListListingsForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<ListListingsForCollectibleResponse> => {
    return this.fetch(
      this.url('ListListingsForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListListingsForCollectibleResponse>(_data, 'ListListingsForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listOffersForCollectible = (req: ListOffersForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<ListOffersForCollectibleResponse> => {
    return this.fetch(
      this.url('ListOffersForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListOffersForCollectibleResponse>(_data, 'ListOffersForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listOrdersWithCollectibles = (req: ListOrdersWithCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<ListOrdersWithCollectiblesResponse> => {
    return this.fetch(
      this.url('ListOrdersWithCollectibles'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListOrdersWithCollectiblesResponse>(_data, 'ListOrdersWithCollectiblesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfAllOrders = (req: GetCountOfAllOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfAllOrdersResponse> => {
    return this.fetch(
      this.url('GetCountOfAllOrders'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfAllOrdersResponse>(_data, 'GetCountOfAllOrdersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfFilteredOrders = (req: GetCountOfFilteredOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfFilteredOrdersResponse> => {
    return this.fetch(
      this.url('GetCountOfFilteredOrders'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfFilteredOrdersResponse>(_data, 'GetCountOfFilteredOrdersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listListings = (req: ListListingsRequest, headers?: object, signal?: AbortSignal): Promise<ListListingsResponse> => {
    return this.fetch(
      this.url('ListListings'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListListingsResponse>(_data, 'ListListingsResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listOffers = (req: ListOffersRequest, headers?: object, signal?: AbortSignal): Promise<ListOffersResponse> => {
    return this.fetch(
      this.url('ListOffers'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListOffersResponse>(_data, 'ListOffersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfListingsForCollectible = (req: GetCountOfListingsForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfListingsForCollectibleResponse> => {
    return this.fetch(
      this.url('GetCountOfListingsForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfListingsForCollectibleResponse>(_data, 'GetCountOfListingsForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfOffersForCollectible = (req: GetCountOfOffersForCollectibleRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfOffersForCollectibleResponse> => {
    return this.fetch(
      this.url('GetCountOfOffersForCollectible'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfOffersForCollectibleResponse>(_data, 'GetCountOfOffersForCollectibleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectibleLowestOffer = (req: GetCollectibleLowestOfferRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleLowestOfferResponse> => {
    return this.fetch(
      this.url('GetCollectibleLowestOffer'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectibleLowestOfferResponse>(_data, 'GetCollectibleLowestOfferResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectibleHighestOffer = (req: GetCollectibleHighestOfferRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleHighestOfferResponse> => {
    return this.fetch(
      this.url('GetCollectibleHighestOffer'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectibleHighestOfferResponse>(_data, 'GetCollectibleHighestOfferResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectibleLowestListing = (req: GetCollectibleLowestListingRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleLowestListingResponse> => {
    return this.fetch(
      this.url('GetCollectibleLowestListing'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectibleLowestListingResponse>(_data, 'GetCollectibleLowestListingResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCollectibleHighestListing = (req: GetCollectibleHighestListingRequest, headers?: object, signal?: AbortSignal): Promise<GetCollectibleHighestListingResponse> => {
    return this.fetch(
      this.url('GetCollectibleHighestListing'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCollectibleHighestListingResponse>(_data, 'GetCollectibleHighestListingResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectibleListings = (req: ListCollectibleListingsRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleListingsResponse> => {
    return this.fetch(
      this.url('ListCollectibleListings'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectibleListingsResponse>(_data, 'ListCollectibleListingsResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectibleOffers = (req: ListCollectibleOffersRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleOffersResponse> => {
    return this.fetch(
      this.url('ListCollectibleOffers'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectibleOffersResponse>(_data, 'ListCollectibleOffersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  generateBuyTransaction = (req: GenerateBuyTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateBuyTransactionResponse> => {
    return this.fetch(
      this.url('GenerateBuyTransaction'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GenerateBuyTransactionResponse>(_data, 'GenerateBuyTransactionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  generateSellTransaction = (req: GenerateSellTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateSellTransactionResponse> => {
    return this.fetch(
      this.url('GenerateSellTransaction'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GenerateSellTransactionResponse>(_data, 'GenerateSellTransactionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  generateListingTransaction = (req: GenerateListingTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateListingTransactionResponse> => {
    return this.fetch(
      this.url('GenerateListingTransaction'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GenerateListingTransactionResponse>(_data, 'GenerateListingTransactionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  generateOfferTransaction = (req: GenerateOfferTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateOfferTransactionResponse> => {
    return this.fetch(
      this.url('GenerateOfferTransaction'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GenerateOfferTransactionResponse>(_data, 'GenerateOfferTransactionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  generateCancelTransaction = (req: GenerateCancelTransactionRequest, headers?: object, signal?: AbortSignal): Promise<GenerateCancelTransactionResponse> => {
    return this.fetch(
      this.url('GenerateCancelTransaction'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GenerateCancelTransactionResponse>(_data, 'GenerateCancelTransactionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  execute = (req: ExecuteRequest, headers?: object, signal?: AbortSignal): Promise<ExecuteResponse> => {
    return this.fetch(
      this.url('Execute'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ExecuteResponse>(_data, 'ExecuteResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectibles = (req: ListCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesResponse> => {
    return this.fetch(
      this.url('ListCollectibles'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectiblesResponse>(_data, 'ListCollectiblesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfAllCollectibles = (req: GetCountOfAllCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfAllCollectiblesResponse> => {
    return this.fetch(
      this.url('GetCountOfAllCollectibles'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfAllCollectiblesResponse>(_data, 'GetCountOfAllCollectiblesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfFilteredCollectibles = (req: GetCountOfFilteredCollectiblesRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfFilteredCollectiblesResponse> => {
    return this.fetch(
      this.url('GetCountOfFilteredCollectibles'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfFilteredCollectiblesResponse>(_data, 'GetCountOfFilteredCollectiblesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getFloorOrder = (req: GetFloorOrderRequest, headers?: object, signal?: AbortSignal): Promise<GetFloorOrderResponse> => {
    return this.fetch(
      this.url('GetFloorOrder'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetFloorOrderResponse>(_data, 'GetFloorOrderResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectionActivities = (req: ListCollectionActivitiesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectionActivitiesResponse> => {
    return this.fetch(
      this.url('ListCollectionActivities'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectionActivitiesResponse>(_data, 'ListCollectionActivitiesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectibleActivities = (req: ListCollectibleActivitiesRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectibleActivitiesResponse> => {
    return this.fetch(
      this.url('ListCollectibleActivities'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectibleActivitiesResponse>(_data, 'ListCollectibleActivitiesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectiblesWithLowestListing = (req: ListCollectiblesWithLowestListingRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesWithLowestListingResponse> => {
    return this.fetch(
      this.url('ListCollectiblesWithLowestListing'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectiblesWithLowestListingResponse>(_data, 'ListCollectiblesWithLowestListingResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listCollectiblesWithHighestOffer = (req: ListCollectiblesWithHighestOfferRequest, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesWithHighestOfferResponse> => {
    return this.fetch(
      this.url('ListCollectiblesWithHighestOffer'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListCollectiblesWithHighestOfferResponse>(_data, 'ListCollectiblesWithHighestOfferResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  syncOrder = (req: SyncOrderRequest, headers?: object, signal?: AbortSignal): Promise<SyncOrderResponse> => {
    return this.fetch(
      this.url('SyncOrder'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SyncOrderResponse>(_data, 'SyncOrderResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  syncOrders = (req: SyncOrdersRequest, headers?: object, signal?: AbortSignal): Promise<SyncOrdersResponse> => {
    return this.fetch(
      this.url('SyncOrders'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SyncOrdersResponse>(_data, 'SyncOrdersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getOrders = (req: GetOrdersRequest, headers?: object, signal?: AbortSignal): Promise<GetOrdersResponse> => {
    return this.fetch(
      this.url('GetOrders'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetOrdersResponse>(_data, 'GetOrdersResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  checkoutOptionsMarketplace = (req: CheckoutOptionsMarketplaceRequest, headers?: object, signal?: AbortSignal): Promise<CheckoutOptionsMarketplaceResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsMarketplace'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CheckoutOptionsMarketplaceResponse>(_data, 'CheckoutOptionsMarketplaceResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  checkoutOptionsSalesContract = (req: CheckoutOptionsSalesContractRequest, headers?: object, signal?: AbortSignal): Promise<CheckoutOptionsSalesContractResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsSalesContract'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CheckoutOptionsSalesContractResponse>(_data, 'CheckoutOptionsSalesContractResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  supportedMarketplaces = (req: SupportedMarketplacesRequest, headers?: object, signal?: AbortSignal): Promise<SupportedMarketplacesResponse> => {
    return this.fetch(
      this.url('SupportedMarketplaces'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SupportedMarketplacesResponse>(_data, 'SupportedMarketplacesResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getPrimarySaleItem = (req: GetPrimarySaleItemRequest, headers?: object, signal?: AbortSignal): Promise<GetPrimarySaleItemResponse> => {
    return this.fetch(
      this.url('GetPrimarySaleItem'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetPrimarySaleItemResponse>(_data, 'GetPrimarySaleItemResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listPrimarySaleItems = (req: ListPrimarySaleItemsRequest, headers?: object, signal?: AbortSignal): Promise<ListPrimarySaleItemsResponse> => {
    return this.fetch(
      this.url('ListPrimarySaleItems'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListPrimarySaleItemsResponse>(_data, 'ListPrimarySaleItemsResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getCountOfPrimarySaleItems = (req: GetCountOfPrimarySaleItemsRequest, headers?: object, signal?: AbortSignal): Promise<GetCountOfPrimarySaleItemsResponse> => {
    return this.fetch(
      this.url('GetCountOfPrimarySaleItems'),
      createHttpRequest(JsonEncode(req), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetCountOfPrimarySaleItemsResponse>(_data, 'GetCountOfPrimarySaleItemsResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json', [WebrpcHeader]: WebrpcHeaderValue }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

//
// BigInt helpers
//

const BIG_INT_FIELDS: { [typ: string]: (string | [string, string])[] } = {
  Activity: ['tokenId', 'quantity', 'priceAmount'],
  AddCollectiblesRequest: ['tokenIds[]'],
  AdditionalFee: ['amount'],
  Asset: ['tokenId'],
  CheckoutOptionsItem: ['tokenId', 'quantity'],
  CheckoutOptionsSalesContractRequest: [['items', 'CheckoutOptionsItem[]']],
  Collectible: ['tokenId'],
  CollectibleOrder: [['metadata', 'TokenMetadata'], ['order', 'Order'], ['listing', 'Order'], ['offer', 'Order']],
  CollectiblePrimarySaleItem: [['metadata', 'TokenMetadata'], ['primarySaleItem', 'PrimarySaleItem']],
  CollectiblesFilter: [['prices', 'PriceFilter[]']],
  CreateReq: ['tokenId', 'quantity', 'pricePerToken'],
  GenerateBuySellTransactionResponse: [['steps', 'Step[]']],
  GenerateBuyTransactionRequest: [['ordersData', 'OrderData[]'], ['additionalFees', 'AdditionalFee[]']],
  GenerateBuyTransactionResponse: [['resp', 'GenerateBuySellTransactionResponse'], ['steps', 'Step[]']],
  GenerateCancelTransactionResponse: [['steps', 'Step[]']],
  GenerateListingTransactionRequest: [['listing', 'CreateReq'], ['additionalFees', 'AdditionalFee[]']],
  GenerateListingTransactionResponse: [['steps', 'Step[]']],
  GenerateOfferTransactionRequest: [['offer', 'CreateReq'], ['additionalFees', 'AdditionalFee[]']],
  GenerateOfferTransactionResponse: [['steps', 'Step[]']],
  GenerateSellTransactionRequest: [['ordersData', 'OrderData[]'], ['additionalFees', 'AdditionalFee[]']],
  GenerateSellTransactionResponse: [['resp', 'GenerateBuySellTransactionResponse'], ['steps', 'Step[]']],
  GetCollectibleHighestListingRequest: ['tokenId'],
  GetCollectibleHighestListingResponse: [['order', 'Order']],
  GetCollectibleHighestOfferRequest: ['tokenId'],
  GetCollectibleHighestOfferResponse: [['order', 'Order']],
  GetCollectibleLowestListingRequest: ['tokenId'],
  GetCollectibleLowestListingResponse: [['order', 'Order']],
  GetCollectibleLowestOfferRequest: ['tokenId'],
  GetCollectibleLowestOfferResponse: [['order', 'Order']],
  GetCollectibleRequest: ['tokenId'],
  GetCollectibleResponse: [['metadata', 'TokenMetadata']],
  GetCountOfFilteredCollectiblesRequest: [['filter', 'CollectiblesFilter']],
  GetCountOfFilteredOrdersRequest: [['filter', 'OrdersFilter']],
  GetCountOfListingsForCollectibleRequest: ['tokenId'],
  GetCountOfOffersForCollectibleRequest: ['tokenId'],
  GetFloorOrderRequest: [['filter', 'CollectiblesFilter']],
  GetFloorOrderResponse: [['collectible', 'CollectibleOrder']],
  GetHighestPriceListingForCollectibleRequest: ['tokenId'],
  GetHighestPriceListingForCollectibleResponse: [['order', 'Order']],
  GetHighestPriceOfferForCollectibleRequest: ['tokenId'],
  GetHighestPriceOfferForCollectibleResponse: [['order', 'Order']],
  GetLowestPriceListingForCollectibleRequest: ['tokenId'],
  GetLowestPriceListingForCollectibleResponse: [['order', 'Order']],
  GetLowestPriceOfferForCollectibleRequest: ['tokenId'],
  GetLowestPriceOfferForCollectibleResponse: [['order', 'Order']],
  GetOrdersResponse: [['orders', 'Order[]']],
  GetPrimarySaleItemRequest: ['tokenId'],
  GetPrimarySaleItemResponse: [['item', 'CollectiblePrimarySaleItem']],
  ListCollectibleActivitiesRequest: ['tokenId'],
  ListCollectibleActivitiesResponse: [['activities', 'Activity[]']],
  ListCollectibleListingsRequest: ['tokenId'],
  ListCollectibleListingsResponse: [['listings', 'Order[]']],
  ListCollectibleOffersRequest: ['tokenId'],
  ListCollectibleOffersResponse: [['offers', 'Order[]']],
  ListCollectiblesRequest: [['filter', 'CollectiblesFilter']],
  ListCollectiblesResponse: [['collectibles', 'CollectibleOrder[]']],
  ListCollectiblesWithHighestOfferRequest: [['filter', 'CollectiblesFilter']],
  ListCollectiblesWithHighestOfferResponse: [['collectibles', 'CollectibleOrder[]']],
  ListCollectiblesWithLowestListingRequest: [['filter', 'CollectiblesFilter']],
  ListCollectiblesWithLowestListingResponse: [['collectibles', 'CollectibleOrder[]']],
  ListCollectionActivitiesResponse: [['activities', 'Activity[]']],
  ListListingsForCollectibleRequest: ['tokenId'],
  ListListingsForCollectibleResponse: [['listings', 'Order[]']],
  ListListingsResponse: [['listings', 'Order[]']],
  ListOffersForCollectibleRequest: ['tokenId'],
  ListOffersForCollectibleResponse: [['offers', 'Order[]']],
  ListOffersResponse: [['offers', 'Order[]']],
  ListOrdersWithCollectiblesRequest: [['filter', 'OrdersFilter']],
  ListOrdersWithCollectiblesResponse: [['collectibles', 'CollectibleOrder[]']],
  ListPrimarySaleItemsResponse: [['primarySaleItems', 'CollectiblePrimarySaleItem[]']],
  Order: ['tokenId', 'priceAmount', 'priceAmountNet', 'quantityInitial', 'quantityRemaining', 'quantityAvailable'],
  OrderData: ['quantity', 'tokenId'],
  OrdersFilter: [['prices', 'PriceFilter[]']],
  PriceFilter: ['min', 'max'],
  PrimarySaleItem: ['tokenId', 'priceAmount', 'supply', 'supplyCap'],
  Step: ['value', 'price'],
  SyncOrderRequest: [['order', 'Order']],
  SyncOrdersRequest: [['orders', 'Order[]']],
  TokenMetadata: ['tokenId', ['assets', 'Asset[]']]
}

// Decode in-place: mutate object graph; throw if expected numeric string is invalid.
function decodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  if (!descs.length) return obj
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = decodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        // Handle nestedType that might be an array type like 'Message[]'
        if (nestedType.endsWith('[]')) {
          const baseType = nestedType.slice(0, -2)
          const arr = obj[fieldName]
          if (Array.isArray(arr)) {
            for (let i = 0; i < arr.length; i++) arr[i] = decodeType(baseType, arr[i])
          }
        } else {
          obj[fieldName] = decodeType(nestedType, obj[fieldName])
        }
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i]
          if (typeof v === 'string') {
            try { arr[i] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${base}[${i}]: ${v}` }) }
          }
        }
      }
      continue
    }
    const v = obj[d]
    if (typeof v === 'string') {
      try { obj[d] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${d}: ${v}` }) }
    }
  }
  return obj
}

// Encode object to JSON with BigInts converted to decimal strings.
export const JsonEncode = <T = any>(obj: T): string => {
  return JSON.stringify(obj, (_key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  )
}

// Decode data (JSON string or already-parsed object) and convert declared BigInt string fields back to BigInt.
export const JsonDecode = <T = any>(data: string | any, typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try { parsed = JSON.parse(data) } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return decodeType(typ, parsed) as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string, code?: number, message?: string, status?: number, cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class SecretKeyCorsDisallowedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SecretKeyCorsDisallowed'
    this.code = typeof error.code === 'number' ? error.code : 1009
    this.message = error.message || `CORS disallowed. Admin API Secret Key can't be used from a web app.`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SecretKeyCorsDisallowedError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class InvalidChainError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidChain'
    this.code = typeof error.code === 'number' ? error.code : 1106
    this.message = error.message || `Network not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidChainError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota request exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Quota rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 2000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2001
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class NotImplementedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotImplemented'
    this.code = typeof error.code === 'number' ? error.code : 9999
    this.message = error.message || `Not Implemented`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotImplementedError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  SecretKeyCorsDisallowed = 'SecretKeyCorsDisallowed',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  InvalidChain = 'InvalidChain',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  NotFound = 'NotFound',
  InvalidArgument = 'InvalidArgument',
  NotImplemented = 'NotImplemented',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  SecretKeyCorsDisallowed = 1009,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  InvalidChain = 1106,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  NotFound = 2000,
  InvalidArgument = 2001,
  NotImplemented = 9999,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1009]: SecretKeyCorsDisallowedError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1106]: InvalidChainError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2000]: NotFoundError,
  [2001]: InvalidArgumentError,
  [9999]: NotImplementedError,
}

//
// Webrpc
//

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.31.1;gen-typescript@v0.23.1;api-client@v0-25.11.10+051e186"

type WebrpcGenVersions = {
  WebrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";")
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, WebrpcGenVersion] = versions[0]!.split("@")
  const [codeGenName, codeGenVersion] = versions[1]!.split("@")
  const [schemaName, schemaVersion] = versions[2]!.split("@")

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}
