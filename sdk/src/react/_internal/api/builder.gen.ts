/* eslint-disable */
// sequence-builder v0.1.0 6076759a1a67dde5bcf692f387832e5bb4b94686
// --
// Code generated by webrpc-gen@v0.26.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=schema/builder.ridl -target=typescript -client -out=../../webapp/src/rpc/proto/builder.gen.ts

export const WebrpcHeader = "Webrpc";

export const WebrpcHeaderValue =
  "webrpc@v0.26.1;gen-typescript@v0.17.0;sequence-builder@v0.1.0";

// WebRPC description and code-gen version
export const WebRPCVersion = "v1";

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.1.0";

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "6076759a1a67dde5bcf692f387832e5bb4b94686";

type WebrpcGenVersions = {
  webrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader);
  if (!headerValue) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue);
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";");
  if (versions.length < 3) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, webrpcGenVersion] = versions[0]!.split("@");
  const [codeGenName, codeGenVersion] = versions[1]!.split("@");
  const [schemaName, schemaVersion] = versions[2]!.split("@");

  return {
    webrpcGenVersion: webrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

//
// Types
//

export enum SortOrder {
  DESC = "DESC",
  ASC = "ASC",
}

export enum ProjectType {
  EMBEDDED_WALLET_REACT = "EMBEDDED_WALLET_REACT",
  EMBEDDED_WALLET_NEXTJS = "EMBEDDED_WALLET_NEXTJS",
  EMBEDDED_WALLET_UNITY = "EMBEDDED_WALLET_UNITY",
  EMBEDDED_WALLET_UNREAL = "EMBEDDED_WALLET_UNREAL",
  MARKETPLACE_STANDALONE = "MARKETPLACE_STANDALONE",
  MARKETPLACE_REACT = "MARKETPLACE_REACT",
  MARKETPLACE_UNITY = "MARKETPLACE_UNITY",
  MARKETPLACE_UNREAL = "MARKETPLACE_UNREAL",
  SALE_CONTRACT_ERC1155 = "SALE_CONTRACT_ERC1155",
  SALE_CONTRACT_ERC721 = "SALE_CONTRACT_ERC721",
  ALLOWLIST_STARTER = "ALLOWLIST_STARTER",
}

export enum TemplateType {
  UNKNOWN = "UNKNOWN",
  LOGIN = "LOGIN",
  GUARD = "GUARD",
}

export interface Page {
  pageSize?: number;
  page?: number;
  column?: string;
  more?: boolean;
  before?: any;
  after?: any;
  sort?: Array<SortBy>;
}

export interface SortBy {
  column: string;
  order?: SortOrder;
}

export interface ProjectImplicitRegistry {
  whitelistedDomains: Array<string>;
  ids: { [key: number]: string };
}

export interface Project {
  id: number;
  name: string;
  type?: ProjectType;
  ownerAddress: string;
  ownerEmail?: string;
  ownerAvatarUrl: string;
  licenseId: number;
  logoImageUrl: string;
  websiteUrl: string;
  chainIds: Array<number>;
  ecosystemId?: number;
  collaboratorCount: number;
  onboardingVisibility: boolean;
  onboardingSteps: { [key: string]: boolean };
  implicitRegistry?: ProjectImplicitRegistry;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string;
}

export interface ProjectListFilter {
  name?: string;
  chainId?: number;
  collaboratorAddress?: string;
  collaboratorEmail?: string;
  licenseId?: number;
  active?: boolean;
}

export interface OpenIdProvider {
  iss: string;
  aud: Array<string>;
}

export interface ContractData {
  abi: string;
  bytecode: string;
  hash?: string;
  implementationAddress?: string;
}

export interface SESSettings {
  accessRoleARN: string;
  sourceARN: string;
  region: string;
}

export enum SubscriptionProvider {
  ADMIN = "ADMIN",
  STRIPE = "STRIPE",
  GOOGLE = "GOOGLE",
}

export enum Feature {
  ANALYTICS = "ANALYTICS",
  MARKETPLACE_SUBDOMAIN = "MARKETPLACE_SUBDOMAIN",
  MARKETPLACE_DOMAIN = "MARKETPLACE_DOMAIN",
}

export enum PaymentProvider {
  NONE = "NONE",
  STRIPE = "STRIPE",
  ADMIN = "ADMIN",
}

export interface EcosystemLicense {
  id: number;
  ecosystemId: number;
  isDefault: boolean;
  packageName: string;
  label: string;
  tier: number;
  mainnetEnabled: boolean;
  defaultChainIds?: Array<number>;
  availableChainIds?: Array<number>;
  extraChainIds?: Array<number>;
  settings: LicenseSettings;
  totalLicenses: number;
  licenseUsage?: LicenseUsage;
  licensePerUser: number;
  features?: Array<Feature>;
  createdAt: string;
  updatedAt: string;
}

export interface LicenseSettings {
  subscriptionPrice: string;
  seats: number;
  serviceSettings: { [key: string]: ServiceSettings };
  marketplaceFee: string;
  gasFeeMarkup: string;
  gasIncluded: string;
  features: Array<Feature>;
}

export interface ServiceSettings {
  rateLimit: number;
  requestsIncluded: number;
  overageAllowed: boolean;
  overagePrice: string;
}

export interface LicenseUsage {
  total: number;
  details: { [key: string]: number };
}

export interface BillingOverride {
  priceSubscription?: string;
  extraSeats: number;
  marketplaceFee?: string;
  gasFeeMarkup?: string;
  extraFeatures: Array<Feature>;
  serviceSettings?: { [key: string]: ServiceSettingsOverride };
  topUpEnabled: boolean;
  topUpProvider: PaymentProvider;
  topUpThreshold?: number;
  topUpAmount?: number;
  topUpLimit?: number;
}

export interface ServiceSettingsOverride {
  rateLimit?: number;
  requestsIncluded?: number;
  overageAllowed?: boolean;
  overagePrice?: string;
  usageWarning?: number;
  overageWarning?: number;
  maxOverage?: number;
}

export enum ResourceType {
  CONTRACTS = "CONTRACTS",
  MARKET_COLLECTIONS = "MARKET_COLLECTIONS",
  SHOP_COLLECTIONS = "SHOP_COLLECTIONS",
}

export enum CollaboratorAccess {
  NONE = "NONE",
  READ = "READ",
  WRITE = "WRITE",
  ADMIN = "ADMIN",
}

export enum CollaboratorType {
  USER = "USER",
  SERVICE_ACCOUNT = "SERVICE_ACCOUNT",
}

export enum ContractSourceType {
  LINKED = "LINKED",
  DEPLOYED = "DEPLOYED",
}

export enum PaymentStatus {
  INITIATED = "INITIATED",
  PENDING = "PENDING",
  SUCCEEDED = "SUCCEEDED",
  FAILED = "FAILED",
  PROCESSED = "PROCESSED",
}

export enum AdminMarketplaceContractType {
  UNKNOWN = "UNKNOWN",
  ERC20 = "ERC20",
  ERC721 = "ERC721",
  ERC1155 = "ERC1155",
}

export enum AdminCollectionPriority {
  unknown = "unknown",
  low = "low",
  normal = "normal",
  high = "high",
}

export enum AdminCollectionStatus {
  unknown = "unknown",
  created = "created",
  syncing_contract_metadata = "syncing_contract_metadata",
  synced_contract_metadata = "synced_contract_metadata",
  syncing_metadata = "syncing_metadata",
  synced_metadata = "synced_metadata",
  syncing_tokens = "syncing_tokens",
  synced_tokens = "synced_tokens",
  syncing_orders = "syncing_orders",
  active = "active",
  failed = "failed",
  inactive = "inactive",
  incompatible_type = "incompatible_type",
}

export enum TokenType {
  ERC20 = "ERC20",
  ERC721 = "ERC721",
  ERC1155 = "ERC1155",
}

export enum FileScope {
  LOGO = "LOGO",
  MARKETPLACE = "MARKETPLACE",
  AVATAR = "AVATAR",
  EMAIL = "EMAIL",
  WALLET = "WALLET",
  TOKEN_DIRECTORY = "TOKEN_DIRECTORY",
  ECOSYSTEM = "ECOSYSTEM",
}

export enum TaskStatus {
  PENDING = "PENDING",
  PAUSED = "PAUSED",
  FAILED = "FAILED",
  COMPLETED = "COMPLETED",
  DISABLED = "DISABLED",
}

export enum OnboardingStep {
  linkOrDeployContract = "linkOrDeployContract",
  createMarketplace = "createMarketplace",
  setUpGasTank = "setUpGasTank",
  configureWaas = "configureWaas",
  customizeWallet = "customizeWallet",
  inviteCollaborator = "inviteCollaborator",
  cloneGithub = "cloneGithub",
  copyCredentials = "copyCredentials",
  customizeMarketplace = "customizeMarketplace",
  deployERC721Contract = "deployERC721Contract",
  deployERC1155Contract = "deployERC1155Contract",
  addMarketplaceCollection = "addMarketplaceCollection",
  createCollection = "createCollection",
  customizeCollectible = "customizeCollectible",
  deploySaleContract = "deploySaleContract",
  setSaleSettings = "setSaleSettings",
  addMinterRoleToItems = "addMinterRoleToItems",
  setUpAudienceList = "setUpAudienceList",
  setUpBot = "setUpBot",
}

export enum TrialType {
  ANALYTICS = "ANALYTICS",
}

export enum AuditType {
  SUBSCRIPTION = "SUBSCRIPTION",
  BILLING_OVERRIDE = "BILLING_OVERRIDE",
  ECOSYSTEM_LICENSE = "ECOSYSTEM_LICENSE",
}

export interface Version {
  webrpcVersion: string;
  schemaVersion: string;
  schemaHash: string;
  appVersion: string;
}

export interface RuntimeStatus {
  healthOK: boolean;
  startTime: string;
  uptime: number;
  ver: string;
  env: string;
  branch: string;
  commitHash: string;
  networks: { [key: string]: boolean };
  checks: RuntimeChecks;
}

export interface RuntimeChecks {
  quotaControl: boolean;
  joqueue: boolean;
  stripe: boolean;
  cloudCommerce: boolean;
}

export interface AuthState {
  jwtToken: string;
  expiresAt: string;
  address: string;
  sessionType: string;
  user?: User;
}

export interface User {
  address: string;
  email?: string;
  createdAt: string;
  updatedAt: string;
  sysAdmin: boolean;
  avatarUrl: string;
}

export interface UserSettings {
  projectsLimit: number;
  projectsLeft?: number;
  projectCount: number;
}

export interface UserOverride {
  id: number;
  address: string;
  extraProjects: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProjectOptions {
  type?: ProjectType;
  chainIds?: Array<number>;
}

export interface ResourceFilter {
  contracts?: ContractFilter;
}

export interface Resource {
  type: ResourceType;
  total: number;
  detail: Array<ResourceDetail>;
}

export interface ResourceDetail {
  key: any;
  count: number;
}

export interface ProjectSubscription {
  id: number;
  projectId: number;
  provider?: SubscriptionProvider;
  licenseId: number;
  subscriptionId: string;
  providerUrl?: string;
  dateStart: string;
  dateEnd?: string;
}

export interface Collaborator {
  id: number;
  projectId: number;
  type: CollaboratorType;
  userAddress: string;
  userEmail?: string;
  userAvatarUrl?: string;
  userAvatarKey?: string;
  access: CollaboratorAccess;
  invitationId?: number;
  createdAt: string;
  updatedAt: string;
}

export interface Contract {
  id: number;
  projectId: number;
  contractName: string;
  contractAddress: string;
  contractType: string;
  chainId: number;
  source: ContractSourceType;
  abi?: string;
  bytecode?: string;
  bytecodeHash?: string;
  audienceId?: number;
  decimals?: number;
  symbol?: string;
  contractExtensions: ContractExtensions;
  tags?: Array<string>;
  createdAt: string;
  updatedAt: string;
}

export interface ContractExtensions {
  itemsContractAddress?: string;
  splitterContractAddresses?: Array<string>;
  laosCollectionAddress?: string;
}

export interface ContractSync {
  decimals?: number;
  symbol?: string;
}

export interface ContractFilter {
  chainId?: number;
  contractSourceType?: ContractSourceType;
  contractTypes?: Array<string>;
  tag?: string;
}

export interface ContractTag {
  tag: string;
  count: number;
}

export interface ContractLink {
  contract?: Contract;
  project: Project;
  collaborator: Collaborator;
}

export interface RelayerGasSponsor {
  id: number;
  projectId: number;
  chainId: number;
  displayName: string;
  address: string;
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface RelayerTransaction {
  txnHash: string;
  txnNonce: string;
  metaTxnID?: string;
  txnStatus: string;
  txnRevertReason: string;
  requeues: number;
  queuedAt: string;
  sentAt: string;
  minedAt: string;
  target: string;
  input: string;
  txnArgs: { [key: string]: any };
  txnReceipt?: { [key: string]: any };
  walletAddress: string;
  metaTxnNonce: string;
  gasLimit: number;
  gasPrice: string;
  gasUsed: number;
  gasEstimated: number;
  gasFeeMarkup?: number;
  usdRate: string;
  creditsUsed: number;
  cost: string;
  isWhitelisted: boolean;
  gasSponsor?: number;
  createdAt: string;
  updatedAt: string;
}

export interface GasTankStatus {
  provider: PaymentProvider;
  setupPayment: boolean;
  mainnetSponsors: boolean;
  gasTankBalance?: number;
}

export interface BillingCycle {
  start: string;
  end: string;
}

export interface TopUpSettings {
  active: boolean;
  provider: PaymentProvider;
  threshold: number;
  amount: number;
  limit: number;
}

export interface UsageInfo {
  includedWarn: number;
  includedMax: number;
  overageWarn: number;
  overageMax: number;
  mau?: number;
  usage: number;
  balance: number;
  overage: number;
  extraCharged?: string;
}

export interface SubscriptionInfo {
  current: ProjectSubscription;
  license?: EcosystemLicense;
  cycle: BillingCycle;
  settings: LicenseSettings;
  topUpSettings: TopUpSettings;
  usage: { [key: string]: UsageInfo };
  plannedDowngrade?: EcosystemLicense;
  pendingUpgrade?: EcosystemLicense;
}

export interface PaymentHistory {
  totalPayments: number;
  payments: Array<Payment>;
}

export interface Redirect {
  url: string;
}

export interface StripeEventData {
  object: StripeEventDataObject;
}

export interface StripeEventDataObject {
  id: string;
  object: string;
}

export interface Payment {
  id: number;
  projectId: number;
  chainId?: number;
  status?: PaymentStatus;
  provider: PaymentProvider;
  externalTxnID: string;
  createdAt: string;
}

export interface PaymentLog {
  id: number;
  paymentID: number;
  data: PaymentLogData;
  createdAt: string;
}

export interface PaymentLogData {
  type: string;
  data: any;
}

export interface InvoicesReturn {
  hasMore: boolean;
  invoices: Array<Invoice>;
}

export interface Invoice {
  id: string;
  date: string;
  amount: string;
  paid: boolean;
  url: string;
}

export interface ContractInfo {
  data: any;
}

export interface ContractInfoOverride {
  data: any;
}

export interface ProjectInvitation {
  id: number;
  projectId: number;
  code: string;
  access: CollaboratorAccess;
  expiresAt: string;
  usageCount: number;
  createdAt: string;
  deletedAt?: string;
}

export interface AdminMarketplaceCollection {
  status: AdminCollectionStatus;
  chainId: number;
  contractAddress: string;
  contractType: AdminMarketplaceContractType;
  priority: AdminCollectionPriority;
  tokenQuantityDecimals: number;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string;
}

export interface OffchainInventory {
  id: number;
  projectId: number;
  chainId: number;
  externalProductId: string;
  paymentTokenAddress: string;
  paymentTokenType: TokenType;
  paymentTokenId: number;
  paymentAmount: number;
  paymentRecipient: string;
  chainedCallAddress?: string;
  chainedCallData?: string;
  allowCrossChainPayments?: boolean;
  callbackURL?: string;
  createdAt?: string;
  deletedAt?: string;
}

export interface OffchainPayment {
  id: number;
  offchainInventoryId: number;
  productRecipient: string;
  paymentChainId: number;
  paymentTokenAddress: string;
  expiration: string;
  createdAt: string;
  completedAt?: string;
  processedAt?: string;
}

export interface WalletConfigSchema {
  version: number;
  config: { [key: string]: any };
}

export interface LegacyWalletConfig {
  id?: number;
  version: number;
  projectId: number;
  platform: string;
  config: { [key: string]: any };
  createdAt?: string;
  updatedAt?: string;
}

export interface ProjectFile {
  id: number;
  projectId: number;
  scope: FileScope;
  mimetype: string;
  filepath: string;
  contents: Array<string>;
  hash: Array<string>;
  url: string;
  createdAt: string;
}

export interface WaasTemplate {
  id: number;
  templateType?: TemplateType;
  projectId: number;
  subject: string;
  introText: string;
  logoUrl: string;
  template?: string;
  fromEmail?: string;
  placeholders: Array<string>;
  sesConfig?: SESSettings;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string;
}

export interface TaskRunner {
  id: number;
  workGroup: string;
  runAt: string;
}

export interface Task {
  id: number;
  queue: string;
  status: TaskStatus;
  try: number;
  runAt?: string;
  lastRanAt?: string;
  createdAt?: string;
  payload: Array<string>;
  hash: string;
}

export interface CreditBonus {
  id: number;
  projectId: number;
  amount: number;
  balance: number;
  createdAt: string;
  updatedAt: string;
}

export interface WaasSettings {
  recoveryAddress: string;
  authConfig: WaasAuthConfig;
  oidcProviders: Array<OpenIdProvider>;
  allowedOrigins: Array<string>;
  updateCode: string;
  tenantKey: string;
}

export interface WaasAuthEmailConfig {
  enabled: boolean;
}

export interface WaasAuthGuestConfig {
  enabled: boolean;
}

export interface WaasAuthPlayfabConfig {
  enabled: boolean;
  titleId?: string;
}

export interface WaasAuthStytchConfig {
  enabled: boolean;
  projectId?: string;
}

export interface WaasAuthTwitterConfig {
  enabled: boolean;
  clientId?: string;
}

export interface WaasAuthConfig {
  email?: WaasAuthEmailConfig;
  guest?: WaasAuthGuestConfig;
  playfab?: WaasAuthPlayfabConfig;
  stytch?: WaasAuthStytchConfig;
  twitter?: WaasAuthTwitterConfig;
}

export interface WaasWalletStatus {
  chainId: number;
  address: string;
  deployed: boolean;
}

export interface Audience {
  id: number;
  projectId: number;
  name: string;
  contactCount: number;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string;
}

export interface AudienceContact {
  id?: number;
  audienceId: number;
  name?: string;
  address: string;
  email?: string;
  userIp?: string;
  stage?: number;
  provider?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface AudienceRegistrationStatus {
  totalCount: number;
}

export interface Trial {
  id: number;
  projectId: number;
  type: TrialType;
  startAt: string;
  endAt: string;
}

export interface WalletProof {
  address: string;
  message: string;
  signature: string;
  chainId: number;
}

export interface AuditLog {
  id: number;
  walletAddress: string;
  userEmail: string;
  entityId: number;
  type: AuditType;
  oldValue: any;
  newValue: any;
  createdAt: string;
}

export enum DateInterval {
  DAY = "DAY",
  WEEK = "WEEK",
  MONTH = "MONTH",
}

export interface QueryFilter {
  projectId?: number;
  ecosystemId?: number;
  startDate?: string;
  endDate?: string;
  dateInterval?: DateInterval;
  collections?: Array<string>;
  tokenId?: string;
}

export interface Chart {
  value: number;
  label: string;
}

export interface ChartWithPercentage {
  label: string;
  total: number;
  percentage: number;
}

export interface MultiValueChart {
  value: { [key: string]: number };
  label: string;
}

export interface QueryResult {
  collection: string;
  source: string;
  tokenId?: string;
  volumeUSD: number;
  numTokens: number;
  numTxns: number;
}

export enum ContractLibraryStatus {
  DEPRECATED = "DEPRECATED",
  NIGHTLY = "NIGHTLY",
  STABLE = "STABLE",
}

export interface ContractLibraryItem {
  uid: string;
  contractType: string;
  name: string;
  description: string;
  author: string;
  license: string;
  moreInfoUrl: string;
  disabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ContractLibraryVersion {
  uid: string;
  version: number;
  audited: boolean;
  releaseNotes: string;
  upgradable: boolean;
  sourceData: ContractData;
  factoryAddress?: string;
  factoryData?: ContractData;
  chainIds?: Array<number>;
  status: ContractLibraryStatus;
  createdAt: string;
  updatedAt: string;
}

export interface ProjectContractSource {
  projectId: number;
  uid: string;
  data: ContractData;
  name: string;
  createdAt: string;
  updatedAt: string;
}

export enum EcosystemType {
  UNKNOWN = "UNKNOWN",
  OPEN = "OPEN",
  CLOSED = "CLOSED",
}

export enum EcosystemAccess {
  User = "User",
  Read = "Read",
  Write = "Write",
  Admin = "Admin",
  Owner = "Owner",
}

export enum ThemeType {
  LIGHT = "LIGHT",
  DARK = "DARK",
  CUSTOM = "CUSTOM",
}

export interface Ecosystem {
  id: number;
  name: string;
  type: EcosystemType;
  ownerAddress: string;
  builderDomain: string;
  walletDomain?: string;
  email?: string;
  accessKeyPrefix: string;
  chainIds: Array<number>;
  exclusive: boolean;
  projectCount?: number;
  settings: EcosystemSettings;
  createdAt: string;
  updatedAt: string;
}

export interface EcosystemCollaborator {
  id: number;
  ecosystemId: number;
  userAddress: string;
  access: EcosystemAccess;
  createdAt: string;
  updatedAt: string;
}

export interface EcosystemSettings {
  title: string;
  description: string;
  learnMoreButton: string;
  learnMoreUrl: string;
  crispWebsiteId: string;
  domainAllowList?: Array<string>;
  domainBlockList?: Array<string>;
  themes: Array<ThemeSettings>;
}

export interface ThemeSettings {
  type: ThemeType;
  customCss: string;
  fileLogo: string;
  fileTitle: string;
  fileBackground: string;
  fileBackgroundMobile: string;
}

export interface Configuration {
  ecosystemId: number;
  name: string;
  builderDomain: string;
  walletDomain?: string;
  chainIds: Array<number>;
  license: EcosystemLicense;
  settings: EcosystemSettings;
  exclusiveChainIds: { [key: number]: number };
}

export interface EcosystemTemplate {
  subject: string;
  introText: string;
  logoUrl: string;
  fromEmail: string;
  content: string;
  placeholders: Array<string>;
  sesSettings?: SESSettings;
  createdAt: string;
  updatedAt: string;
}

export enum MarketplaceWalletType {
  UNIVERSAL = "UNIVERSAL",
  EMBEDDED = "EMBEDDED",
  ECOSYSTEM = "ECOSYSTEM",
}

export enum FilterCondition {
  ENTIRE_KEY = "ENTIRE_KEY",
  SPECIFIC_VALUE = "SPECIFIC_VALUE",
}

export enum MarketplaceLegacyType {
  AMM = "AMM",
  P2P = "P2P",
  SEQUENCE = "SEQUENCE",
  ORDERBOOK = "ORDERBOOK",
}

export interface MarketplaceHostname {
  hostname: string;
  projectId: number;
  isDefaultHostname: boolean;
  isCustomDomain: boolean;
  createdAt: string;
}

export interface Marketplace {
  projectId: number;
  settings: MarketplaceSettings;
  market: MarketplacePage;
  shop: MarketplacePage;
  createdAt?: string;
  updatedAt?: string;
}

export interface MarketplaceSettings {
  style: { [key: string]: any };
  publisherId: string;
  title: string;
  socials: MarketplaceSocials;
  faviconUrl: string;
  walletOptions: MarketplaceWallet;
  logoUrl: string;
  fontUrl: string;
  accessKey?: string;
}

export interface MarketplacePage {
  enabled: boolean;
  bannerUrl: string;
  ogImage: string;
  private: boolean;
}

export interface MarketplaceSocials {
  twitter: string;
  discord: string;
  website: string;
  tiktok: string;
  instagram: string;
  youtube: string;
}

export interface MarketplaceWallet {
  walletType: MarketplaceWalletType;
  oidcIssuers: { [key: string]: string };
  connectors: Array<string>;
  includeEIP6963Wallets: boolean;
  ecosystem?: MarketplaceWalletEcosystem;
  embedded?: MarketplaceWalletEmbedded;
}

export interface MarketplaceWalletEcosystem {
  walletUrl: string;
  walletAppName: string;
  logoLightUrl?: string;
  logoDarkUrl?: string;
}

export interface MarketplaceWalletEmbedded {
  tenantKey: string;
  emailEnabled: boolean;
  providers: Array<OpenIdProvider>;
}

export interface MarketCollection {
  id: number;
  projectId: number;
  chainId: number;
  itemsAddress: string;
  contractType: string;
  bannerUrl: string;
  feePercentage: number;
  currencyOptions: Array<string>;
  destinationMarketplace: string;
  filterSettings?: CollectionFilterSettings;
  sortOrder?: number;
  private: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export interface ShopCollection {
  id: number;
  projectId: number;
  chainId: number;
  itemsAddress: string;
  saleAddress: string;
  name: string;
  bannerUrl: string;
  tokenIds: Array<string>;
  customTokenIds: Array<string>;
  sortOrder?: number;
  private: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export interface MetadataFilterRule {
  key: string;
  condition: FilterCondition;
  value?: string;
}

export interface CollectionFilterSettings {
  filterOrder: Array<string>;
  exclusions: Array<MetadataFilterRule>;
}

export interface CollectionListFilter {
  includePrivate: boolean;
}

export interface MarketplaceLegacySettings {
  projectId?: number;
  publisherId: string;
  title: string;
  shortDescription: string;
  socials: MarketplaceSocials;
  faviconUrl: string;
  landingBannerUrl: string;
  collections: Array<MarketplaceLegacyCollection>;
  walletOptions: MarketplaceLegacyWallet;
  landingPageLayout: string;
  logoUrl: string;
  bannerUrl: string;
  fontUrl?: string;
  ogImage?: string;
  accessKey?: string;
}

export interface MarketplaceLegacyWallet {
  walletType: MarketplaceWalletType;
  oidcIssuers: { [key: string]: string };
  connectors: Array<string>;
  includeEIP6963Wallets: boolean;
  ecosystem?: MarketplaceWalletEcosystem;
  waas?: MarketplaceWalletEmbedded;
}

export interface MarketplaceLegacyCollection {
  marketplaceType: MarketplaceLegacyType;
  chainId: number;
  address: string;
  exchanges: Array<string>;
  bannerUrl: string;
  feePercentage: number;
  currencyOptions: Array<string>;
  destinationMarketplace: string;
  filterSettings?: CollectionFilterSettings;
  isLAOSERC721?: boolean;
}

export interface Analytics {
  totalCompute(
    args: TotalComputeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalComputeReturn>;
  computeByService(
    args: ComputeByServiceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ComputeByServiceReturn>;
  dailyComputeByType(
    args: DailyComputeByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyComputeByTypeReturn>;
  dailyComputeByService(
    args: DailyComputeByServiceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyComputeByServiceReturn>;
  getOrderbookCollections(
    args: GetOrderbookCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOrderbookCollectionsReturn>;
  creditsPerDailyActiveUser(
    args: CreditsPerDailyActiveUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreditsPerDailyActiveUserReturn>;
  creditsPerMonthlyActiveUser(
    args: CreditsPerMonthlyActiveUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreditsPerMonthlyActiveUserReturn>;
  walletsTotal(
    args: WalletsTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTotalReturn>;
  walletsDaily(
    args: WalletsDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsDailyReturn>;
  walletsMonthly(
    args: WalletsMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsMonthlyReturn>;
  walletsByCountry(
    args: WalletsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByCountryReturn>;
  walletsByDevice(
    args: WalletsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByDeviceReturn>;
  walletsByBrowser(
    args: WalletsByBrowserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByBrowserReturn>;
  walletsByOS(
    args: WalletsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByOSReturn>;
  walletsByType(
    args: WalletsByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByTypeReturn>;
  walletsTxnSentTotal(
    args: WalletsTxnSentTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentTotalReturn>;
  walletsTxnSentDaily(
    args: WalletsTxnSentDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentDailyReturn>;
  walletsTxnSentMonthly(
    args: WalletsTxnSentMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentMonthlyReturn>;
  walletsByOrigin(
    args: WalletsByOriginArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByOriginReturn>;
  connectionsByOrigin(
    args: ConnectionsByOriginArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ConnectionsByOriginReturn>;
  marketTxnEventTotal(
    args: MarketTxnEventTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventTotalReturn>;
  marketTxnEventDaily(
    args: MarketTxnEventDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventDailyReturn>;
  marketTxnEventMonthly(
    args: MarketTxnEventMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventMonthlyReturn>;
  marketWalletsTotal(
    args: MarketWalletsTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsTotalReturn>;
  marketWalletsDaily(
    args: MarketWalletsDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsDailyReturn>;
  marketWalletsMonthly(
    args: MarketWalletsMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsMonthlyReturn>;
  totalWalletTxnConversionRate(
    args: TotalWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalWalletTxnConversionRateReturn>;
  dailyWalletTxnConversionRate(
    args: DailyWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyWalletTxnConversionRateReturn>;
  monthlyWalletTxnConversionRate(
    args: MonthlyWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyWalletTxnConversionRateReturn>;
  dailyNewWallets(
    args: DailyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyNewWalletsReturn>;
  monthlyNewWallets(
    args: MonthlyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyNewWalletsReturn>;
  totalNewWallets(
    args: TotalNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalNewWalletsReturn>;
  averageDAU(
    args: AverageDAUArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageDAUReturn>;
  rollingStickiness(
    args: RollingStickinessArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RollingStickinessReturn>;
  averageStickiness(
    args: AverageStickinessArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageStickinessReturn>;
  d1RetentionByCohort(
    args: D1RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D1RetentionByCohortReturn>;
  d3RetentionByCohort(
    args: D3RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D3RetentionByCohortReturn>;
  d7RetentionByCohort(
    args: D7RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D7RetentionByCohortReturn>;
  d14RetentionByCohort(
    args: D14RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D14RetentionByCohortReturn>;
  d28RetentionByCohort(
    args: D28RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D28RetentionByCohortReturn>;
  averageD1Retention(
    args: AverageD1RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD1RetentionReturn>;
  averageD3Retention(
    args: AverageD3RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD3RetentionReturn>;
  averageD7Retention(
    args: AverageD7RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD7RetentionReturn>;
  averageD14Retention(
    args: AverageD14RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD14RetentionReturn>;
  averageD28Retention(
    args: AverageD28RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD28RetentionReturn>;
  monthlyActiveWalletsBySegment(
    args: MonthlyActiveWalletsBySegmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyActiveWalletsBySegmentReturn>;
  monthlyTransactingWalletsBySegment(
    args: MonthlyTransactingWalletsBySegmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyTransactingWalletsBySegmentReturn>;
  weeklyActiveWallets(
    args: WeeklyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WeeklyActiveWalletsReturn>;
  /**
   * Views Analytics
   */
  totalViews(
    args: TotalViewsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalViewsReturn>;
  dailyViews(
    args: DailyViewsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyViewsReturn>;
  viewsByCountry(
    args: ViewsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByCountryReturn>;
  viewsByDevice(
    args: ViewsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByDeviceReturn>;
  viewsByOS(
    args: ViewsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByOSReturn>;
  /**
   * Visitors Analytics
   */
  dailyUniqueVisitors(
    args: DailyUniqueVisitorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyUniqueVisitorsReturn>;
  monthlyUniqueVisitors(
    args: MonthlyUniqueVisitorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyUniqueVisitorsReturn>;
  /**
   * Real-time Analytics
   */
  activeSessions(
    args: ActiveSessionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ActiveSessionsReturn>;
  userEvents(
    args: UserEventsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserEventsReturn>;
  /**
   * Ecosystem Analytics
   */
  ecosystemTotalWallets(
    args: EcosystemTotalWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalWalletsReturn>;
  ecosystemTotalProjects(
    args: EcosystemTotalProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalProjectsReturn>;
  ecosystemTotalActiveProjects(
    args: EcosystemTotalActiveProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalActiveProjectsReturn>;
  ecosystemTotalDevelopers(
    args: EcosystemTotalDevelopersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalDevelopersReturn>;
  ecosystemDailyActiveWallets(
    args: EcosystemDailyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyActiveWalletsReturn>;
  ecosystemMonthlyActiveWallets(
    args: EcosystemMonthlyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyActiveWalletsReturn>;
  ecosystemDailyNewProjects(
    args: EcosystemDailyNewProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyNewProjectsReturn>;
  ecosystemMonthlyNewProjects(
    args: EcosystemMonthlyNewProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyNewProjectsReturn>;
  ecosystemTotalContracts(
    args: EcosystemTotalContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalContractsReturn>;
  ecosystemMonthlyContracts(
    args: EcosystemMonthlyContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyContractsReturn>;
  ecosystemTopProjectsByWallets(
    args: EcosystemTopProjectsByWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByWalletsReturn>;
  ecosystemTopProjectsByActiveWallets(
    args: EcosystemTopProjectsByActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByActiveWalletsReturn>;
  ecosystemTopProjectsByNewWallets(
    args: EcosystemTopProjectsByNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByNewWalletsReturn>;
  ecosystemWalletsPerProject(
    args: EcosystemWalletsPerProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsPerProjectReturn>;
  ecosystemMonthlyWalletsPerProject(
    args: EcosystemMonthlyWalletsPerProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyWalletsPerProjectReturn>;
  ecosystemDailyNewWallets(
    args: EcosystemDailyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyNewWalletsReturn>;
  ecosystemMonthlyNewWallets(
    args: EcosystemMonthlyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyNewWalletsReturn>;
  ecosystemTopProjectsByDeveloperActivity(
    args: EcosystemTopProjectsByDeveloperActivityArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByDeveloperActivityReturn>;
  ecosystemTotalMarketplaces(
    args: EcosystemTotalMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalMarketplacesReturn>;
  ecosystemMonthlyMarketplaces(
    args: EcosystemMonthlyMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyMarketplacesReturn>;
  ecosystemActiveMarketplaces(
    args: EcosystemActiveMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemActiveMarketplacesReturn>;
  ecosystemWalletsByCountry(
    args: EcosystemWalletsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByCountryReturn>;
  ecosystemWalletsByDevice(
    args: EcosystemWalletsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByDeviceReturn>;
  ecosystemWalletsByOS(
    args: EcosystemWalletsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByOSReturn>;
  ecosystemWalletsByBrowser(
    args: EcosystemWalletsByBrowserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByBrowserReturn>;
  ecosystemWalletsByType(
    args: EcosystemWalletsByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByTypeReturn>;
}

export interface TotalComputeArgs {
  filter: QueryFilter;
}

export interface TotalComputeReturn {
  computeStats: Array<Chart>;
}
export interface ComputeByServiceArgs {
  filter: QueryFilter;
}

export interface ComputeByServiceReturn {
  computeStats: Array<MultiValueChart>;
}
export interface DailyComputeByTypeArgs {
  filter: QueryFilter;
}

export interface DailyComputeByTypeReturn {
  computeStats: Array<MultiValueChart>;
}
export interface DailyComputeByServiceArgs {
  filter: QueryFilter;
}

export interface DailyComputeByServiceReturn {
  computeStats: { [key: string]: Array<Chart> };
}
export interface GetOrderbookCollectionsArgs {
  filter: QueryFilter;
}

export interface GetOrderbookCollectionsReturn {
  data: Array<QueryResult>;
}
export interface CreditsPerDailyActiveUserArgs {
  filter: QueryFilter;
}

export interface CreditsPerDailyActiveUserReturn {
  data: Array<MultiValueChart>;
}
export interface CreditsPerMonthlyActiveUserArgs {
  filter: QueryFilter;
}

export interface CreditsPerMonthlyActiveUserReturn {
  data: Array<MultiValueChart>;
}
export interface WalletsTotalArgs {
  filter: QueryFilter;
}

export interface WalletsTotalReturn {
  walletStats: Array<Chart>;
}
export interface WalletsDailyArgs {
  filter: QueryFilter;
}

export interface WalletsDailyReturn {
  walletStats: Array<Chart>;
}
export interface WalletsMonthlyArgs {
  filter: QueryFilter;
}

export interface WalletsMonthlyReturn {
  walletStats: Array<Chart>;
}
export interface WalletsByCountryArgs {
  filter: QueryFilter;
}

export interface WalletsByCountryReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface WalletsByDeviceArgs {
  filter: QueryFilter;
}

export interface WalletsByDeviceReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface WalletsByBrowserArgs {
  filter: QueryFilter;
}

export interface WalletsByBrowserReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface WalletsByOSArgs {
  filter: QueryFilter;
}

export interface WalletsByOSReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface WalletsByTypeArgs {
  filter: QueryFilter;
}

export interface WalletsByTypeReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface WalletsTxnSentTotalArgs {
  filter: QueryFilter;
}

export interface WalletsTxnSentTotalReturn {
  walletStats: Array<Chart>;
}
export interface WalletsTxnSentDailyArgs {
  filter: QueryFilter;
}

export interface WalletsTxnSentDailyReturn {
  walletStats: Array<Chart>;
}
export interface WalletsTxnSentMonthlyArgs {
  filter: QueryFilter;
}

export interface WalletsTxnSentMonthlyReturn {
  walletStats: Array<Chart>;
}
export interface WalletsByOriginArgs {
  filter: QueryFilter;
}

export interface WalletsByOriginReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface ConnectionsByOriginArgs {
  filter: QueryFilter;
}

export interface ConnectionsByOriginReturn {
  walletStats: Array<ChartWithPercentage>;
}
export interface MarketTxnEventTotalArgs {
  filter: QueryFilter;
}

export interface MarketTxnEventTotalReturn {
  marketStats: Array<Chart>;
}
export interface MarketTxnEventDailyArgs {
  filter: QueryFilter;
}

export interface MarketTxnEventDailyReturn {
  marketStats: Array<MultiValueChart>;
}
export interface MarketTxnEventMonthlyArgs {
  filter: QueryFilter;
}

export interface MarketTxnEventMonthlyReturn {
  marketStats: Array<Chart>;
}
export interface MarketWalletsTotalArgs {
  filter: QueryFilter;
}

export interface MarketWalletsTotalReturn {
  marketStats: Array<Chart>;
}
export interface MarketWalletsDailyArgs {
  filter: QueryFilter;
}

export interface MarketWalletsDailyReturn {
  marketStats: Array<Chart>;
}
export interface MarketWalletsMonthlyArgs {
  filter: QueryFilter;
}

export interface MarketWalletsMonthlyReturn {
  marketStats: Array<Chart>;
}
export interface TotalWalletTxnConversionRateArgs {
  filter: QueryFilter;
}

export interface TotalWalletTxnConversionRateReturn {
  marketStats: Array<Chart>;
}
export interface DailyWalletTxnConversionRateArgs {
  filter: QueryFilter;
}

export interface DailyWalletTxnConversionRateReturn {
  marketStats: Array<Chart>;
}
export interface MonthlyWalletTxnConversionRateArgs {
  filter: QueryFilter;
}

export interface MonthlyWalletTxnConversionRateReturn {
  marketStats: Array<Chart>;
}
export interface DailyNewWalletsArgs {
  filter: QueryFilter;
}

export interface DailyNewWalletsReturn {
  data: Array<Chart>;
}
export interface MonthlyNewWalletsArgs {
  filter: QueryFilter;
}

export interface MonthlyNewWalletsReturn {
  data: Array<Chart>;
}
export interface TotalNewWalletsArgs {
  filter: QueryFilter;
}

export interface TotalNewWalletsReturn {
  data: Array<Chart>;
}
export interface AverageDAUArgs {
  filter: QueryFilter;
}

export interface AverageDAUReturn {
  data: Array<Chart>;
}
export interface RollingStickinessArgs {
  filter: QueryFilter;
}

export interface RollingStickinessReturn {
  data: Array<Chart>;
}
export interface AverageStickinessArgs {
  filter: QueryFilter;
}

export interface AverageStickinessReturn {
  data: Array<Chart>;
}
export interface D1RetentionByCohortArgs {
  filter: QueryFilter;
}

export interface D1RetentionByCohortReturn {
  data: Array<Chart>;
}
export interface D3RetentionByCohortArgs {
  filter: QueryFilter;
}

export interface D3RetentionByCohortReturn {
  data: Array<Chart>;
}
export interface D7RetentionByCohortArgs {
  filter: QueryFilter;
}

export interface D7RetentionByCohortReturn {
  data: Array<Chart>;
}
export interface D14RetentionByCohortArgs {
  filter: QueryFilter;
}

export interface D14RetentionByCohortReturn {
  data: Array<Chart>;
}
export interface D28RetentionByCohortArgs {
  filter: QueryFilter;
}

export interface D28RetentionByCohortReturn {
  data: Array<Chart>;
}
export interface AverageD1RetentionArgs {
  filter: QueryFilter;
}

export interface AverageD1RetentionReturn {
  data: Array<Chart>;
}
export interface AverageD3RetentionArgs {
  filter: QueryFilter;
}

export interface AverageD3RetentionReturn {
  data: Array<Chart>;
}
export interface AverageD7RetentionArgs {
  filter: QueryFilter;
}

export interface AverageD7RetentionReturn {
  data: Array<Chart>;
}
export interface AverageD14RetentionArgs {
  filter: QueryFilter;
}

export interface AverageD14RetentionReturn {
  data: Array<Chart>;
}
export interface AverageD28RetentionArgs {
  filter: QueryFilter;
}

export interface AverageD28RetentionReturn {
  data: Array<Chart>;
}
export interface MonthlyActiveWalletsBySegmentArgs {
  filter: QueryFilter;
}

export interface MonthlyActiveWalletsBySegmentReturn {
  data: { [key: string]: Array<Chart> };
}
export interface MonthlyTransactingWalletsBySegmentArgs {
  filter: QueryFilter;
}

export interface MonthlyTransactingWalletsBySegmentReturn {
  data: { [key: string]: Array<Chart> };
}
export interface WeeklyActiveWalletsArgs {
  filter: QueryFilter;
}

export interface WeeklyActiveWalletsReturn {
  data: Array<Chart>;
}
export interface TotalViewsArgs {
  filter: QueryFilter;
}

export interface TotalViewsReturn {
  data: Array<Chart>;
}
export interface DailyViewsArgs {
  filter: QueryFilter;
}

export interface DailyViewsReturn {
  data: Array<Chart>;
}
export interface ViewsByCountryArgs {
  filter: QueryFilter;
}

export interface ViewsByCountryReturn {
  data: Array<ChartWithPercentage>;
}
export interface ViewsByDeviceArgs {
  filter: QueryFilter;
}

export interface ViewsByDeviceReturn {
  data: Array<ChartWithPercentage>;
}
export interface ViewsByOSArgs {
  filter: QueryFilter;
}

export interface ViewsByOSReturn {
  data: Array<ChartWithPercentage>;
}
export interface DailyUniqueVisitorsArgs {
  filter: QueryFilter;
}

export interface DailyUniqueVisitorsReturn {
  data: Array<MultiValueChart>;
}
export interface MonthlyUniqueVisitorsArgs {
  filter: QueryFilter;
}

export interface MonthlyUniqueVisitorsReturn {
  data: Array<MultiValueChart>;
}
export interface ActiveSessionsArgs {
  filter: QueryFilter;
}

export interface ActiveSessionsReturn {
  data: Array<Chart>;
}
export interface UserEventsArgs {
  filter: QueryFilter;
}

export interface UserEventsReturn {
  data: Array<Chart>;
}
export interface EcosystemTotalWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalWalletsReturn {
  data: Array<Chart>;
}
export interface EcosystemTotalProjectsArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalProjectsReturn {
  data: Array<Chart>;
}
export interface EcosystemTotalActiveProjectsArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalActiveProjectsReturn {
  data: Array<Chart>;
}
export interface EcosystemTotalDevelopersArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalDevelopersReturn {
  data: Array<Chart>;
}
export interface EcosystemDailyActiveWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemDailyActiveWalletsReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyActiveWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyActiveWalletsReturn {
  data: Array<Chart>;
}
export interface EcosystemDailyNewProjectsArgs {
  filter: QueryFilter;
}

export interface EcosystemDailyNewProjectsReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyNewProjectsArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyNewProjectsReturn {
  data: Array<Chart>;
}
export interface EcosystemTotalContractsArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalContractsReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyContractsArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyContractsReturn {
  data: Array<Chart>;
}
export interface EcosystemTopProjectsByWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemTopProjectsByWalletsReturn {
  data: Array<MultiValueChart>;
}
export interface EcosystemTopProjectsByActiveWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemTopProjectsByActiveWalletsReturn {
  data: Array<MultiValueChart>;
}
export interface EcosystemTopProjectsByNewWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemTopProjectsByNewWalletsReturn {
  data: Array<MultiValueChart>;
}
export interface EcosystemWalletsPerProjectArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsPerProjectReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyWalletsPerProjectArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyWalletsPerProjectReturn {
  data: Array<Chart>;
}
export interface EcosystemDailyNewWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemDailyNewWalletsReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyNewWalletsArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyNewWalletsReturn {
  data: Array<Chart>;
}
export interface EcosystemTopProjectsByDeveloperActivityArgs {
  filter: QueryFilter;
}

export interface EcosystemTopProjectsByDeveloperActivityReturn {
  data: Array<MultiValueChart>;
}
export interface EcosystemTotalMarketplacesArgs {
  filter: QueryFilter;
}

export interface EcosystemTotalMarketplacesReturn {
  data: Array<Chart>;
}
export interface EcosystemMonthlyMarketplacesArgs {
  filter: QueryFilter;
}

export interface EcosystemMonthlyMarketplacesReturn {
  data: Array<Chart>;
}
export interface EcosystemActiveMarketplacesArgs {
  filter: QueryFilter;
}

export interface EcosystemActiveMarketplacesReturn {
  data: Array<Chart>;
}
export interface EcosystemWalletsByCountryArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsByCountryReturn {
  data: Array<ChartWithPercentage>;
}
export interface EcosystemWalletsByDeviceArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsByDeviceReturn {
  data: Array<ChartWithPercentage>;
}
export interface EcosystemWalletsByOSArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsByOSReturn {
  data: Array<ChartWithPercentage>;
}
export interface EcosystemWalletsByBrowserArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsByBrowserReturn {
  data: Array<ChartWithPercentage>;
}
export interface EcosystemWalletsByTypeArgs {
  filter: QueryFilter;
}

export interface EcosystemWalletsByTypeReturn {
  data: Array<ChartWithPercentage>;
}

export interface ContractLibrary {
  listItems(
    args: ListItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListItemsReturn>;
  getItem(
    args: GetItemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetItemReturn>;
  listVersions(
    args: ListVersionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListVersionsReturn>;
  getVersion(
    args: GetVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetVersionReturn>;
  findVersion(
    args: FindVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindVersionReturn>;
  detectContractVersion(
    args: DetectContractVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DetectContractVersionReturn>;
  syncContract(
    args: SyncContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncContractReturn>;
  listProjectSources(
    args: ListProjectSourcesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectSourcesReturn>;
  getProjectSource(
    args: GetProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetProjectSourceReturn>;
  addProjectSource(
    args: AddProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddProjectSourceReturn>;
  updateProjectSource(
    args: UpdateProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateProjectSourceReturn>;
  notifyDeploy(
    args: NotifyDeployArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<NotifyDeployReturn>;
  deleteProjectSource(
    args: DeleteProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectSourceReturn>;
}

export interface ListItemsArgs {
  status?: Array<ContractLibraryStatus>;
  page: Page;
}

export interface ListItemsReturn {
  page: Page;
  items: Array<ContractLibraryItem>;
}
export interface GetItemArgs {
  uid: string;
}

export interface GetItemReturn {
  item: ContractLibraryItem;
}
export interface ListVersionsArgs {
  uid: string;
  page?: Page;
}

export interface ListVersionsReturn {
  page: Page;
  itemVersions: Array<ContractLibraryVersion>;
}
export interface GetVersionArgs {
  uid: string;
  status?: ContractLibraryStatus;
  version?: number;
}

export interface GetVersionReturn {
  itemVersion: ContractLibraryVersion;
}
export interface FindVersionArgs {
  uid: string;
  hash: string;
}

export interface FindVersionReturn {
  itemVersion: ContractLibraryVersion;
}
export interface DetectContractVersionArgs {
  chainId: number;
  address: string;
}

export interface DetectContractVersionReturn {
  version?: ContractLibraryVersion;
}
export interface SyncContractArgs {
  projectId: number;
  chainId: number;
  address: string;
}

export interface SyncContractReturn {
  version?: ContractLibraryVersion;
  source?: ProjectContractSource;
}
export interface ListProjectSourcesArgs {
  projectId: number;
  page?: Page;
}

export interface ListProjectSourcesReturn {
  page: Page;
  sources: Array<ProjectContractSource>;
}
export interface GetProjectSourceArgs {
  projectId: number;
  uid: string;
}

export interface GetProjectSourceReturn {
  source: ProjectContractSource;
}
export interface AddProjectSourceArgs {
  projectId: number;
  uid: string;
  name: string;
  data: ContractData;
}

export interface AddProjectSourceReturn {
  source: ProjectContractSource;
}
export interface UpdateProjectSourceArgs {
  projectId: number;
  uid: string;
  name: string;
  data: ContractData;
}

export interface UpdateProjectSourceReturn {
  source: ProjectContractSource;
}
export interface NotifyDeployArgs {
  projectId: number;
  uid: string;
  chainId: number;
  address: string;
}

export interface NotifyDeployReturn {
  ok: boolean;
}
export interface DeleteProjectSourceArgs {
  projectId: number;
  uid: string;
}

export interface DeleteProjectSourceReturn {
  ok: boolean;
}

export interface EcosystemManager {
  /**
   * Ecosystems
   */
  createEcosystem(
    args: CreateEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateEcosystemReturn>;
  getEcosystem(
    args: GetEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemReturn>;
  findEcosystem(
    args: FindEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindEcosystemReturn>;
  updateEcosystem(
    args: UpdateEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemReturn>;
  listEcosystems(
    args: ListEcosystemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemsReturn>;
  /**
   * Ecosystem > Collaborators
   */
  setEcosystemCollaborator(
    args: SetEcosystemCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetEcosystemCollaboratorReturn>;
  getEcosystemCollaborator(
    args: GetEcosystemCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemCollaboratorReturn>;
  listEcosystemCollaborators(
    args: ListEcosystemCollaboratorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemCollaboratorsReturn>;
  /**
   * Ecosystem > Licenses
   */
  createEcosystemLicense(
    args: CreateEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateEcosystemLicenseReturn>;
  getEcosystemLicense(
    args: GetEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemLicenseReturn>;
  updateEcosystemLicense(
    args: UpdateEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemLicenseReturn>;
  listEcosystemLicenses(
    args: ListEcosystemLicensesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemLicensesReturn>;
  deleteEcosystemLicense(
    args: DeleteEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteEcosystemLicenseReturn>;
  getEcosystemDefaultLicense(
    args: GetEcosystemDefaultLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemDefaultLicenseReturn>;
  setEcosystemDefaultLicense(
    args: SetEcosystemDefaultLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetEcosystemDefaultLicenseReturn>;
  assignLicense(
    args: AssignLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AssignLicenseReturn>;
  /**
   * EcosystemSettings
   */
  updateEcosystemSettings(
    args: UpdateEcosystemSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemSettingsReturn>;
  /**
   * Ecosystem > Templates
   */
  listTemplates(
    args: ListTemplatesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListTemplatesReturn>;
  getTemplate(
    args: GetTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTemplateReturn>;
  setTemplate(
    args: SetTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetTemplateReturn>;
  /**
   * Ecosystem > Projects
   */
  setProjectEcosystem(
    args: SetProjectEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectEcosystemReturn>;
  listEcosystemProjects(
    args: ListEcosystemProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemProjectsReturn>;
  getEcosystemProject(
    args: GetEcosystemProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemProjectReturn>;
  restoreEcosystemProject(
    args: RestoreEcosystemProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RestoreEcosystemProjectReturn>;
}

export interface CreateEcosystemArgs {
  ecosystem: Ecosystem;
}

export interface CreateEcosystemReturn {
  ecosystem: Ecosystem;
}
export interface GetEcosystemArgs {
  id: number;
}

export interface GetEcosystemReturn {
  ecosystem: Ecosystem;
}
export interface FindEcosystemArgs {
  name?: string;
  domain?: string;
  projectId?: number;
}

export interface FindEcosystemReturn {
  ecosystem: Ecosystem;
}
export interface UpdateEcosystemArgs {
  id: number;
  ecosystem: Ecosystem;
}

export interface UpdateEcosystemReturn {
  ok: boolean;
}
export interface ListEcosystemsArgs {
  query?: string;
  ecosystemType?: EcosystemType;
  page?: Page;
}

export interface ListEcosystemsReturn {
  page: Page;
  ecosystems: Array<Ecosystem>;
}
export interface SetEcosystemCollaboratorArgs {
  id: number;
  userAddress: string;
  access?: EcosystemAccess;
}

export interface SetEcosystemCollaboratorReturn {
  ok: boolean;
}
export interface GetEcosystemCollaboratorArgs {
  id: number;
  userAddress: string;
}

export interface GetEcosystemCollaboratorReturn {
  level: EcosystemCollaborator;
}
export interface ListEcosystemCollaboratorsArgs {
  id: number;
  page?: Page;
}

export interface ListEcosystemCollaboratorsReturn {
  page: Page;
  collaborators: Array<EcosystemCollaborator>;
}
export interface CreateEcosystemLicenseArgs {
  license: EcosystemLicense;
}

export interface CreateEcosystemLicenseReturn {
  license: EcosystemLicense;
}
export interface GetEcosystemLicenseArgs {
  id: number;
}

export interface GetEcosystemLicenseReturn {
  license: EcosystemLicense;
}
export interface UpdateEcosystemLicenseArgs {
  id: number;
  license: EcosystemLicense;
}

export interface UpdateEcosystemLicenseReturn {
  ok: boolean;
}
export interface ListEcosystemLicensesArgs {
  ecosystemId: number;
  page?: Page;
}

export interface ListEcosystemLicensesReturn {
  page: Page;
  licenses: Array<EcosystemLicense>;
}
export interface DeleteEcosystemLicenseArgs {
  id: number;
}

export interface DeleteEcosystemLicenseReturn {
  ok: boolean;
}
export interface GetEcosystemDefaultLicenseArgs {
  ecosystemId: number;
}

export interface GetEcosystemDefaultLicenseReturn {
  license: EcosystemLicense;
}
export interface SetEcosystemDefaultLicenseArgs {
  ecosystemId: number;
  licenseId: number;
}

export interface SetEcosystemDefaultLicenseReturn {
  ok: boolean;
}
export interface AssignLicenseArgs {
  licenseId: number;
  projectId: number;
}

export interface AssignLicenseReturn {
  ok: boolean;
}
export interface UpdateEcosystemSettingsArgs {
  id: number;
  settings: EcosystemSettings;
}

export interface UpdateEcosystemSettingsReturn {
  ok: boolean;
}
export interface ListTemplatesArgs {
  ecosystemId: number;
  templateType?: TemplateType;
}

export interface ListTemplatesReturn {
  templates: { [key: string]: EcosystemTemplate };
}
export interface GetTemplateArgs {
  ecosystemId: number;
  templateType: TemplateType;
}

export interface GetTemplateReturn {
  template: EcosystemTemplate;
}
export interface SetTemplateArgs {
  ecosystemId: number;
  templateType: TemplateType;
  template?: EcosystemTemplate;
}

export interface SetTemplateReturn {
  template: EcosystemTemplate;
}
export interface SetProjectEcosystemArgs {
  projectId: number;
  ecosystemId?: number;
}

export interface SetProjectEcosystemReturn {
  ok: boolean;
}
export interface ListEcosystemProjectsArgs {
  ecosystemId: number;
  filter?: ProjectListFilter;
  page?: Page;
}

export interface ListEcosystemProjectsReturn {
  page: Page;
  projects: Array<Project>;
}
export interface GetEcosystemProjectArgs {
  ecosystemId: number;
  projectId: number;
}

export interface GetEcosystemProjectReturn {
  project: Project;
}
export interface RestoreEcosystemProjectArgs {
  ecosystemId: number;
  projectId: number;
}

export interface RestoreEcosystemProjectReturn {
  ok: boolean;
}

export interface GasTank {
  getBalance(
    args: GetBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetBalanceReturn>;
  adjustProjectBalance(
    args: AdjustProjectBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdjustProjectBalanceReturn>;
  spendBalance(
    args: SpendBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SpendBalanceReturn>;
}

export interface GetBalanceArgs {
  projectId: number;
}

export interface GetBalanceReturn {
  ok: boolean;
  balance: number;
  markupFactor: number;
}
export interface AdjustProjectBalanceArgs {
  projectId: number;
  amount: number;
  identifier: string;
}

export interface AdjustProjectBalanceReturn {
  balance: number;
}
export interface SpendBalanceArgs {
  projectId: number;
  amount: number;
}

export interface SpendBalanceReturn {
  balance: number;
}

export interface MarketplaceService {
  /**
   * Marketplace management
   */
  getMarketplace(
    args: GetMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceReturn>;
  createMarketplace(
    args: CreateMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateMarketplaceReturn>;
  updateMarketplace(
    args: UpdateMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMarketplaceReturn>;
  deleteMarketplace(
    args: DeleteMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteMarketplaceReturn>;
  /**
   * Market Collection management
   */
  listMarketCollections(
    args: ListMarketCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListMarketCollectionsReturn>;
  getMarketCollection(
    args: GetMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketCollectionReturn>;
  findMarketCollection(
    args: FindMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindMarketCollectionReturn>;
  addMarketCollection(
    args: AddMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddMarketCollectionReturn>;
  updateMarketCollection(
    args: UpdateMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMarketCollectionReturn>;
  reorderMarketCollections(
    args: ReorderMarketCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ReorderMarketCollectionsReturn>;
  syncMarketCollection(
    args: SyncMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncMarketCollectionReturn>;
  deleteMarketCollection(
    args: DeleteMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteMarketCollectionReturn>;
  /**
   * Shop Collection management
   */
  listShopCollections(
    args: ListShopCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListShopCollectionsReturn>;
  getShopCollection(
    args: GetShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetShopCollectionReturn>;
  findShopCollection(
    args: FindShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindShopCollectionReturn>;
  addShopCollection(
    args: AddShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddShopCollectionReturn>;
  updateShopCollection(
    args: UpdateShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateShopCollectionReturn>;
  reorderShopCollections(
    args: ReorderShopCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ReorderShopCollectionsReturn>;
  deleteShopCollection(
    args: DeleteShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteShopCollectionReturn>;
  /**
   * Hostname management
   */
  listHostnames(
    args: ListHostnamesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListHostnamesReturn>;
  addHostname(
    args: AddHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddHostnameReturn>;
  deleteHostname(
    args: DeleteHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteHostnameReturn>;
  changeDefaultHostname(
    args: ChangeDefaultHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ChangeDefaultHostnameReturn>;
  resetHostname(
    args: ResetHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ResetHostnameReturn>;
  /**
   * Public Methods
   */
  lookupMarketplace(
    args: LookupMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupMarketplaceReturn>;
}

export interface GetMarketplaceArgs {
  projectId: number;
}

export interface GetMarketplaceReturn {
  marketplace: Marketplace;
}
export interface CreateMarketplaceArgs {
  projectId: number;
  marketplace: Marketplace;
}

export interface CreateMarketplaceReturn {
  marketplace: Marketplace;
}
export interface UpdateMarketplaceArgs {
  projectId: number;
  settings?: MarketplaceSettings;
  market?: MarketplacePage;
  shop?: MarketplacePage;
}

export interface UpdateMarketplaceReturn {
  marketplace: Marketplace;
}
export interface DeleteMarketplaceArgs {
  projectId: number;
}

export interface DeleteMarketplaceReturn {
  ok: boolean;
}
export interface ListMarketCollectionsArgs {
  projectId: number;
  chainId?: number;
  page?: Page;
  filter?: CollectionListFilter;
}

export interface ListMarketCollectionsReturn {
  page: Page;
  collections: Array<MarketCollection>;
}
export interface GetMarketCollectionArgs {
  projectId: number;
  collectionId: number;
}

export interface GetMarketCollectionReturn {
  collection: MarketCollection;
}
export interface FindMarketCollectionArgs {
  projectId: number;
  chainId: number;
  contractAddress: string;
}

export interface FindMarketCollectionReturn {
  collection: MarketCollection;
}
export interface AddMarketCollectionArgs {
  projectId: number;
  collection: MarketCollection;
}

export interface AddMarketCollectionReturn {
  collection: MarketCollection;
}
export interface UpdateMarketCollectionArgs {
  projectId: number;
  collection: MarketCollection;
}

export interface UpdateMarketCollectionReturn {
  collection: MarketCollection;
}
export interface ReorderMarketCollectionsArgs {
  projectId: number;
  collectionIds: Array<number>;
}

export interface ReorderMarketCollectionsReturn {
  ok: boolean;
}
export interface SyncMarketCollectionArgs {
  projectId: number;
  chainId: number;
  contractAddress: string;
}

export interface SyncMarketCollectionReturn {
  ok: boolean;
}
export interface DeleteMarketCollectionArgs {
  projectId: number;
  collectionId: number;
}

export interface DeleteMarketCollectionReturn {
  ok: boolean;
}
export interface ListShopCollectionsArgs {
  projectId: number;
  chainId?: number;
  page?: Page;
  filter?: CollectionListFilter;
}

export interface ListShopCollectionsReturn {
  page: Page;
  collections: Array<ShopCollection>;
}
export interface GetShopCollectionArgs {
  projectId: number;
  collectionId: number;
}

export interface GetShopCollectionReturn {
  collection: ShopCollection;
}
export interface FindShopCollectionArgs {
  projectId: number;
  chainId: number;
  contractAddress: string;
}

export interface FindShopCollectionReturn {
  collection: ShopCollection;
}
export interface AddShopCollectionArgs {
  projectId: number;
  collection: ShopCollection;
  currencyAddress: string;
}

export interface AddShopCollectionReturn {
  collection: ShopCollection;
}
export interface UpdateShopCollectionArgs {
  projectId: number;
  collection: ShopCollection;
  currencyAddress: string;
}

export interface UpdateShopCollectionReturn {
  collection: ShopCollection;
}
export interface ReorderShopCollectionsArgs {
  projectId: number;
  collectionIds: Array<number>;
}

export interface ReorderShopCollectionsReturn {
  ok: boolean;
}
export interface DeleteShopCollectionArgs {
  projectId: number;
  collectionId: number;
}

export interface DeleteShopCollectionReturn {
  ok: boolean;
}
export interface ListHostnamesArgs {
  projectId: number;
}

export interface ListHostnamesReturn {
  hostnames: Array<MarketplaceHostname>;
}
export interface AddHostnameArgs {
  projectId: number;
  domain: string;
  custom: boolean;
}

export interface AddHostnameReturn {
  hostname: MarketplaceHostname;
}
export interface DeleteHostnameArgs {
  projectId: number;
  domain: string;
}

export interface DeleteHostnameReturn {
  ok: boolean;
}
export interface ChangeDefaultHostnameArgs {
  projectId: number;
}

export interface ChangeDefaultHostnameReturn {
  hostname: MarketplaceHostname;
}
export interface ResetHostnameArgs {
  projectId: number;
}

export interface ResetHostnameReturn {
  ok: boolean;
}
export interface LookupMarketplaceArgs {
  projectId?: number;
  domain?: string;
  userAddress?: string;
}

export interface LookupMarketplaceReturn {
  marketplace: Marketplace;
  marketCollections: Array<MarketCollection>;
  shopCollections: Array<ShopCollection>;
}

export interface Builder {
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>;
  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
  runtimeStatus(
    headers?: object,
    signal?: AbortSignal
  ): Promise<RuntimeStatusReturn>;
  getConfiguration(
    args: GetConfigurationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetConfigurationReturn>;
  /**
   * Users
   */
  getCurrentUser(
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCurrentUserReturn>;
  getCurrentUserSettings(
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCurrentUserSettingsReturn>;
  getEmailPreferences(
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEmailPreferencesReturn>;
  updateEmailPreferences(
    args: UpdateEmailPreferencesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEmailPreferencesReturn>;
  getAuthToken(
    args: GetAuthTokenArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAuthTokenReturn>;
  /**
   * Projects
   */
  createProject(
    args: CreateProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateProjectReturn>;
  getProject(
    args: GetProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetProjectReturn>;
  updateProject(
    args: UpdateProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateProjectReturn>;
  addProjectChain(
    args: AddProjectChainArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddProjectChainReturn>;
  removeProjectChain(
    args: RemoveProjectChainArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveProjectChainReturn>;
  setProjectChains(
    args: SetProjectChainsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectChainsReturn>;
  deleteProject(
    args: DeleteProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectReturn>;
  listProjects(
    args: ListProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectsReturn>;
  countProjects(
    args: CountProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CountProjectsReturn>;
  /**
   * Project -> Resources
   */
  getResource(
    args: GetResourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetResourceReturn>;
  /**
   * Project -> Implicit Registry
   */
  setProjectImplicitRegistry(
    args: SetProjectImplicitRegistryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectImplicitRegistryReturn>;
  /**
   * Project > Collaborators
   */
  createCollaborator(
    args: CreateCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateCollaboratorReturn>;
  getCollaborator(
    args: GetCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollaboratorReturn>;
  updateCollaborator(
    args: UpdateCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateCollaboratorReturn>;
  removeCollaborator(
    args: RemoveCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveCollaboratorReturn>;
  listCollaborators(
    args: ListCollaboratorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollaboratorsReturn>;
  addServiceAccount(
    args: AddServiceAccountArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddServiceAccountReturn>;
  getServiceAccount(
    args: GetServiceAccountArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetServiceAccountReturn>;
  /**
   * Project > Contracts
   */
  createContract(
    args: CreateContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateContractReturn>;
  getContract(
    args: GetContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractReturn>;
  updateContract(
    args: UpdateContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateContractReturn>;
  setContractItemsAddress(
    args: SetContractItemsAddressArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetContractItemsAddressReturn>;
  deleteContract(
    args: DeleteContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteContractReturn>;
  listContracts(
    args: ListContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListContractsReturn>;
  exploreContractLinks(
    args: ExploreContractLinksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ExploreContractLinksReturn>;
  findProjectContract(
    args: FindProjectContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindProjectContractReturn>;
  getContractLinks(
    args: GetContractLinksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractLinksReturn>;
  /**
   * Project > Contracts
   */
  syncContracts(
    args: SyncContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncContractsReturn>;
  getContractTags(
    args: GetContractTagsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractTagsReturn>;
  contractLookup(
    args: ContractLookupArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ContractLookupReturn>;
  /**
   * Project > Email Templates
   */
  getWaasTemplate(
    args: GetWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetWaasTemplateReturn>;
  createWaasTemplate(
    args: CreateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateWaasTemplateReturn>;
  updateWaasTemplate(
    args: UpdateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWaasTemplateReturn>;
  /**
   * @deprecated
   */
  getEmailTemplate(
    args: GetEmailTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEmailTemplateReturn>;
  /**
   * Payments
   */
  gasTankStatus(
    args: GasTankStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GasTankStatusReturn>;
  createBillingSession(
    args: CreateBillingSessionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateBillingSessionReturn>;
  updateTopupSettings(
    args: UpdateTopupSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateTopupSettingsReturn>;
  topUpGasTank(
    args: TopUpGasTankArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TopUpGasTankReturn>;
  getInvoices(
    args: GetInvoicesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetInvoicesReturn>;
  /**
   * Subscriptions
   */
  getSubscriptionInfo(
    args: GetSubscriptionInfoArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetSubscriptionInfoReturn>;
  /**
   * ProjectInvitations
   */
  createProjectInvitation(
    args: CreateProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateProjectInvitationReturn>;
  listProjectInvitations(
    args: ListProjectInvitationsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectInvitationsReturn>;
  deleteProjectInvitation(
    args: DeleteProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectInvitationReturn>;
  useProjectInvitation(
    args: UseProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UseProjectInvitationReturn>;
  /**
   * Marketplace
   *
   * @deprecated
   */
  lookupMarketplaceConfig(
    args: LookupMarketplaceConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupMarketplaceConfigReturn>;
  /**
   * Inventory payments and management
   */
  addOffchainInventory(
    args: AddOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddOffchainInventoryReturn>;
  getOffchainInventory(
    args: GetOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOffchainInventoryReturn>;
  listOffchainInventories(
    args: ListOffchainInventoriesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainInventoriesReturn>;
  updateOffchainInventory(
    args: UpdateOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateOffchainInventoryReturn>;
  deleteOffchainInventory(
    args: DeleteOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteOffchainInventoryReturn>;
  listOffchainPayments(
    args: ListOffchainPaymentsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainPaymentsReturn>;
  /**
   * Wallet Config
   */
  getLegacyWalletConfig(
    args: GetLegacyWalletConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLegacyWalletConfigReturn>;
  updateLegacyWalletConfig(
    args: UpdateLegacyWalletConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateLegacyWalletConfigReturn>;
  /**
   * ProjectFile
   */
  listProjectFiles(
    args: ListProjectFilesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectFilesReturn>;
  deleteProjectFile(
    args: DeleteProjectFileArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectFileReturn>;
  /**
   * Onboarding
   */
  onboardingMark(
    args: OnboardingMarkArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<OnboardingMarkReturn>;
  onboardingStatus(
    args: OnboardingStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<OnboardingStatusReturn>;
  /**
   * WaaS
   */
  getWaasSettings(
    args: GetWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetWaasSettingsReturn>;
  createWaasSettings(
    args: CreateWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateWaasSettingsReturn>;
  updateWaasSettings(
    args: UpdateWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWaasSettingsReturn>;
  waasWalletStatus(
    args: WaasWalletStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WaasWalletStatusReturn>;
  deployWaasWallet(
    args: DeployWaasWalletArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeployWaasWalletReturn>;
  /**
   * Cloud Commerce
   */
  cloudCommerceConnect(
    args: CloudCommerceConnectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CloudCommerceConnectReturn>;
  /**
   * Audience
   */
  listAudiences(
    args: ListAudiencesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListAudiencesReturn>;
  getAudience(
    args: GetAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceReturn>;
  createAudience(
    args: CreateAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateAudienceReturn>;
  updateAudience(
    args: UpdateAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateAudienceReturn>;
  deleteAudience(
    args: DeleteAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteAudienceReturn>;
  /**
   * Audience Contacts
   */
  getAudienceContacts(
    args: GetAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceContactsReturn>;
  addAudienceContacts(
    args: AddAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddAudienceContactsReturn>;
  removeAudienceContacts(
    args: RemoveAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveAudienceContactsReturn>;
  findAudienceContacts(
    args: FindAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindAudienceContactsReturn>;
  /**
   * Audience Registration (public)
   */
  registerAudienceContact(
    args: RegisterAudienceContactArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RegisterAudienceContactReturn>;
  getRegisteredAudienceContact(
    args: GetRegisteredAudienceContactArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetRegisteredAudienceContactReturn>;
  getAudienceRegistrationPublicStatus(
    args: GetAudienceRegistrationPublicStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceRegistrationPublicStatusReturn>;
  isAudienceContactRegistered(
    args: IsAudienceContactRegisteredArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsAudienceContactRegisteredReturn>;
  /**
   * Trials
   */
  getTrial(
    args: GetTrialArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTrialReturn>;
  startTrial(
    args: StartTrialArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<StartTrialReturn>;
  /**
   * TODO: - move those methods to separate service
   * service Admin
   * Users
   */
  adminListUsers(
    args: AdminListUsersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListUsersReturn>;
  adminGetUser(
    args: AdminGetUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetUserReturn>;
  adminFindUsers(
    args: AdminFindUsersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminFindUsersReturn>;
  adminUpdateUser(
    args: AdminUpdateUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateUserReturn>;
  /**
   * Projects
   */
  adminGetProject(
    args: AdminGetProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetProjectReturn>;
  adminSetProjectOwner(
    args: AdminSetProjectOwnerArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetProjectOwnerReturn>;
  adminListProjects(
    args: AdminListProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListProjectsReturn>;
  adminRestoreProject(
    args: AdminRestoreProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminRestoreProjectReturn>;
  /**
   * Email Templates
   */
  adminGetWaasTemplate(
    args: AdminGetWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetWaasTemplateReturn>;
  adminUpdateWaasTemplate(
    args: AdminUpdateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateWaasTemplateReturn>;
  adminCreateWaasTemplate(
    args: AdminCreateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminCreateWaasTemplateReturn>;
  /**
   * Contracts
   */
  adminContractProjectLookup(
    args: AdminContractProjectLookupArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminContractProjectLookupReturn>;
  /**
   * User Settings
   */
  adminGetUserOverride(
    args: AdminGetUserOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetUserOverrideReturn>;
  adminSetUserOverride(
    args: AdminSetUserOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetUserOverrideReturn>;
  /**
   * Subscriptions
   */
  adminGetBillingSettings(
    args: AdminGetBillingSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetBillingSettingsReturn>;
  adminSetBillingSettings(
    args: AdminSetBillingSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetBillingSettingsReturn>;
  adminSetProjectLicense(
    args: AdminSetProjectLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetProjectLicenseReturn>;
  /**
   * Relayer Gas Tanks
   */
  adminRelayerAddressGasSponsors(
    args: AdminRelayerAddressGasSponsorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminRelayerAddressGasSponsorsReturn>;
  /**
   * Cloud Commerce
   */
  adminCloudCommerceEvent(
    args: AdminCloudCommerceEventArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminCloudCommerceEventReturn>;
  /**
   * Audit
   */
  adminListAuditLogs(
    args: AdminListAuditLogsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListAuditLogsReturn>;
  /**
   * JobQueue
   */
  jobqueueListRunners(
    args: JobqueueListRunnersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueListRunnersReturn>;
  jobqueueListTasks(
    args: JobqueueListTasksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueListTasksReturn>;
  jobqueueGetTask(
    args: JobqueueGetTaskArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueGetTaskReturn>;
  jobqueueFindTask(
    args: JobqueueFindTaskArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueFindTaskReturn>;
  /**
   * Token Directory
   */
  isInTokenDirectory(
    args: IsInTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsInTokenDirectoryReturn>;
  setTokenDirectoryFeatureIndex(
    args: SetTokenDirectoryFeatureIndexArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetTokenDirectoryFeatureIndexReturn>;
  addContractToTokenDirectory(
    args: AddContractToTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddContractToTokenDirectoryReturn>;
  removeContractFromTokenDirectory(
    args: RemoveContractFromTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveContractFromTokenDirectoryReturn>;
  /**
   * Metadata info override
   */
  getContractInfoOverride(
    args: GetContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractInfoOverrideReturn>;
  addContractInfoOverride(
    args: AddContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddContractInfoOverrideReturn>;
  updateContractInfoOverride(
    args: UpdateContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateContractInfoOverrideReturn>;
  removeContractInfoOverride(
    args: RemoveContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveContractInfoOverrideReturn>;
  /**
   * Marketplace Collection Management
   */
  adminGetMarketplaceCollection(
    args: AdminGetMarketplaceCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetMarketplaceCollectionReturn>;
  adminListMarketplaceCollections(
    args: AdminListMarketplaceCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListMarketplaceCollectionsReturn>;
  adminUpdateMarketplaceCollection(
    args: AdminUpdateMarketplaceCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateMarketplaceCollectionReturn>;
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean;
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version;
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus;
}
export interface GetConfigurationArgs {
  name?: string;
  domain?: string;
  projectId?: number;
}

export interface GetConfigurationReturn {
  config: Configuration;
}
export interface GetCurrentUserArgs {}

export interface GetCurrentUserReturn {
  user: User;
}
export interface GetCurrentUserSettingsArgs {}

export interface GetCurrentUserSettingsReturn {
  settings: UserSettings;
}
export interface GetEmailPreferencesArgs {}

export interface GetEmailPreferencesReturn {
  preferences: { [key: string]: boolean };
  labels: { [key: string]: string };
}
export interface UpdateEmailPreferencesArgs {
  preferences: { [key: string]: boolean };
}

export interface UpdateEmailPreferencesReturn {
  ok: boolean;
}
export interface GetAuthTokenArgs {
  ethauthProof: string;
  email?: string;
}

export interface GetAuthTokenReturn {
  ok: boolean;
  auth: AuthState;
}
export interface CreateProjectArgs {
  name: string;
  options?: CreateProjectOptions;
}

export interface CreateProjectReturn {
  project: Project;
}
export interface GetProjectArgs {
  id: number;
}

export interface GetProjectReturn {
  project: Project;
}
export interface UpdateProjectArgs {
  projectId: number;
  project: Project;
}

export interface UpdateProjectReturn {
  ok: boolean;
}
export interface AddProjectChainArgs {
  projectId: number;
  chainId: number;
}

export interface AddProjectChainReturn {
  ok: boolean;
  chainIds: Array<number>;
}
export interface RemoveProjectChainArgs {
  projectId: number;
  chainId: number;
}

export interface RemoveProjectChainReturn {
  ok: boolean;
  chainIds: Array<number>;
}
export interface SetProjectChainsArgs {
  projectId: number;
  chainIds: Array<number>;
}

export interface SetProjectChainsReturn {
  ok: boolean;
}
export interface DeleteProjectArgs {
  projectId: number;
}

export interface DeleteProjectReturn {
  ok: boolean;
}
export interface ListProjectsArgs {
  chainId?: number;
  page?: Page;
}

export interface ListProjectsReturn {
  page: Page;
  projects: Array<Project>;
}
export interface CountProjectsArgs {
  chainId?: number;
}

export interface CountProjectsReturn {
  count: number;
}
export interface GetResourceArgs {
  parentId?: number;
  resourceType: ResourceType;
  filter?: ResourceFilter;
}

export interface GetResourceReturn {
  resource: Resource;
}
export interface SetProjectImplicitRegistryArgs {
  projectId: number;
  implicitRegistry: ProjectImplicitRegistry;
}

export interface SetProjectImplicitRegistryReturn {
  ok: boolean;
}
export interface CreateCollaboratorArgs {
  projectId: number;
  userAddress: string;
  access?: CollaboratorAccess;
}

export interface CreateCollaboratorReturn {
  collaborator: Collaborator;
}
export interface GetCollaboratorArgs {
  projectId: number;
  userAddress: string;
}

export interface GetCollaboratorReturn {
  collaborator: Collaborator;
}
export interface UpdateCollaboratorArgs {
  projectId: number;
  userAddress: string;
  access: CollaboratorAccess;
}

export interface UpdateCollaboratorReturn {
  collaborator: Collaborator;
}
export interface RemoveCollaboratorArgs {
  projectId: number;
  userAddress: string;
}

export interface RemoveCollaboratorReturn {
  ok: boolean;
}
export interface ListCollaboratorsArgs {
  projectId: number;
  collaboratorType?: CollaboratorType;
  page?: Page;
}

export interface ListCollaboratorsReturn {
  page: Page;
  collaborators: Array<Collaborator>;
}
export interface AddServiceAccountArgs {
  projectId: number;
  access?: CollaboratorAccess;
}

export interface AddServiceAccountReturn {
  collaborator: Collaborator;
  jwtToken: string;
}
export interface GetServiceAccountArgs {
  projectId: number;
  address: string;
}

export interface GetServiceAccountReturn {
  collaborator: Collaborator;
  jwtToken: string;
}
export interface CreateContractArgs {
  projectId: number;
  contract: Contract;
}

export interface CreateContractReturn {
  contract: Contract;
}
export interface GetContractArgs {
  id: number;
}

export interface GetContractReturn {
  contract: Contract;
}
export interface UpdateContractArgs {
  id: number;
  contract: Contract;
}

export interface UpdateContractReturn {
  ok: boolean;
}
export interface SetContractItemsAddressArgs {
  id: number;
  address: string;
}

export interface SetContractItemsAddressReturn {
  contract: Contract;
}
export interface DeleteContractArgs {
  id: number;
}

export interface DeleteContractReturn {
  ok: boolean;
}
export interface ListContractsArgs {
  projectId: number;
  filter?: ContractFilter;
  page?: Page;
}

export interface ListContractsReturn {
  page: Page;
  contracts: Array<Contract>;
}
export interface ExploreContractLinksArgs {
  contractAddress: string;
  chainId?: number;
  onlyLinked?: boolean;
  page?: Page;
}

export interface ExploreContractLinksReturn {
  page: Page;
  links: Array<ContractLink>;
}
export interface FindProjectContractArgs {
  projectId: number;
  contractAddress: string;
  chainId: number;
}

export interface FindProjectContractReturn {
  contract: Contract;
}
export interface GetContractLinksArgs {
  projectId: number;
  id: number;
}

export interface GetContractLinksReturn {
  contracts: Array<Contract>;
}
export interface SyncContractsArgs {
  projectId: number;
  chainId: number;
  contractAddress: string;
  sync: ContractSync;
}

export interface SyncContractsReturn {
  ok: boolean;
}
export interface GetContractTagsArgs {
  projectId: number;
}

export interface GetContractTagsReturn {
  tags: Array<ContractTag>;
}
export interface ContractLookupArgs {
  chainId: number;
  address: string;
}

export interface ContractLookupReturn {
  contract: Contract;
}
export interface GetWaasTemplateArgs {
  projectId: number;
  templateType?: TemplateType;
}

export interface GetWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface CreateWaasTemplateArgs {
  projectId: number;
  templateType?: TemplateType;
  subject: string;
  introText: string;
  logoUrl: string;
}

export interface CreateWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface UpdateWaasTemplateArgs {
  update: WaasTemplate;
}

export interface UpdateWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface GetEmailTemplateArgs {
  projectId: number;
  templateType?: TemplateType;
}

export interface GetEmailTemplateReturn {
  emailTemplate: WaasTemplate;
}
export interface GasTankStatusArgs {
  projectId: number;
}

export interface GasTankStatusReturn {
  status: GasTankStatus;
}
export interface CreateBillingSessionArgs {
  projectId: number;
  path: string;
}

export interface CreateBillingSessionReturn {
  session: Redirect;
}
export interface UpdateTopupSettingsArgs {
  projectId: number;
  settings: TopUpSettings;
}

export interface UpdateTopupSettingsReturn {
  invoiceUrl: string;
}
export interface TopUpGasTankArgs {
  projectId: number;
  amount: number;
}

export interface TopUpGasTankReturn {
  invoiceUrl: string;
}
export interface GetInvoicesArgs {
  projectId: number;
  before?: string;
}

export interface GetInvoicesReturn {
  data: InvoicesReturn;
}
export interface GetSubscriptionInfoArgs {
  projectId: number;
}

export interface GetSubscriptionInfoReturn {
  subscription: SubscriptionInfo;
}
export interface CreateProjectInvitationArgs {
  projectId: number;
  access?: CollaboratorAccess;
  expiresAt?: string;
}

export interface CreateProjectInvitationReturn {
  invitation: ProjectInvitation;
}
export interface ListProjectInvitationsArgs {
  projectId: number;
}

export interface ListProjectInvitationsReturn {
  invitations: Array<ProjectInvitation>;
}
export interface DeleteProjectInvitationArgs {
  invitationId: number;
}

export interface DeleteProjectInvitationReturn {
  ok: boolean;
}
export interface UseProjectInvitationArgs {
  invitationCode: string;
}

export interface UseProjectInvitationReturn {
  ok: boolean;
  projectId: number;
}
export interface LookupMarketplaceConfigArgs {
  projectId?: number;
  hostname?: string;
}

export interface LookupMarketplaceConfigReturn {
  settings: MarketplaceLegacySettings;
}
export interface AddOffchainInventoryArgs {
  inventory: OffchainInventory;
}

export interface AddOffchainInventoryReturn {
  inventoryId: number;
}
export interface GetOffchainInventoryArgs {
  inventoryId: number;
}

export interface GetOffchainInventoryReturn {
  inventory: OffchainInventory;
}
export interface ListOffchainInventoriesArgs {
  projectId: number;
}

export interface ListOffchainInventoriesReturn {
  inventories: Array<OffchainInventory>;
}
export interface UpdateOffchainInventoryArgs {
  inventory: OffchainInventory;
}

export interface UpdateOffchainInventoryReturn {}
export interface DeleteOffchainInventoryArgs {
  inventoryId: number;
}

export interface DeleteOffchainInventoryReturn {
  ok: boolean;
}
export interface ListOffchainPaymentsArgs {
  inventoryId: number;
  page?: Page;
}

export interface ListOffchainPaymentsReturn {
  page: Page;
  payments: Array<OffchainPayment>;
}
export interface GetLegacyWalletConfigArgs {
  projectId: number;
  platform: string;
}

export interface GetLegacyWalletConfigReturn {
  config: LegacyWalletConfig;
}
export interface UpdateLegacyWalletConfigArgs {
  projectId: number;
  platform: string;
  config: LegacyWalletConfig;
}

export interface UpdateLegacyWalletConfigReturn {
  ok: boolean;
}
export interface ListProjectFilesArgs {
  projectId: number;
  scope?: FileScope;
}

export interface ListProjectFilesReturn {
  files: Array<ProjectFile>;
}
export interface DeleteProjectFileArgs {
  id: number;
}

export interface DeleteProjectFileReturn {
  ok: boolean;
}
export interface OnboardingMarkArgs {
  projectId: number;
  step: OnboardingStep;
}

export interface OnboardingMarkReturn {
  ok: boolean;
}
export interface OnboardingStatusArgs {
  projectId: number;
}

export interface OnboardingStatusReturn {
  steps: Array<OnboardingStep>;
}
export interface GetWaasSettingsArgs {
  projectId: number;
}

export interface GetWaasSettingsReturn {
  config: WaasSettings;
}
export interface CreateWaasSettingsArgs {
  projectId: number;
  recoveryAddress: string;
  auth?: WaasAuthConfig;
  oidcProviders: Array<OpenIdProvider>;
  allowedOrigins?: Array<string>;
  password?: string;
}

export interface CreateWaasSettingsReturn {
  config: WaasSettings;
}
export interface UpdateWaasSettingsArgs {
  projectId: number;
  updateCode: string;
  auth?: WaasAuthConfig;
  oidcProviders: Array<OpenIdProvider>;
  allowedOrigins?: Array<string>;
}

export interface UpdateWaasSettingsReturn {
  config: WaasSettings;
}
export interface WaasWalletStatusArgs {
  projectId: number;
}

export interface WaasWalletStatusReturn {
  walletStatus: Array<WaasWalletStatus>;
}
export interface DeployWaasWalletArgs {
  projectId: number;
  chainId: number;
}

export interface DeployWaasWalletReturn {
  address: string;
  txnHash: string;
}
export interface CloudCommerceConnectArgs {
  projectId: number;
  accountId: string;
}

export interface CloudCommerceConnectReturn {
  ok: boolean;
}
export interface ListAudiencesArgs {
  projectId: number;
}

export interface ListAudiencesReturn {
  audiences: Array<Audience>;
}
export interface GetAudienceArgs {
  projectId: number;
  audienceId: number;
}

export interface GetAudienceReturn {
  audience: Audience;
  contracts: Array<Contract>;
}
export interface CreateAudienceArgs {
  projectId: number;
  name: string;
}

export interface CreateAudienceReturn {
  audience: Audience;
}
export interface UpdateAudienceArgs {
  projectId: number;
  audienceId: number;
  name: string;
}

export interface UpdateAudienceReturn {
  audience: Audience;
}
export interface DeleteAudienceArgs {
  projectId: number;
  audienceId: number;
}

export interface DeleteAudienceReturn {
  ok: boolean;
}
export interface GetAudienceContactsArgs {
  projectId: number;
  audienceId: number;
  page?: Page;
}

export interface GetAudienceContactsReturn {
  audience: Audience;
  contacts: Array<AudienceContact>;
  page: Page;
}
export interface AddAudienceContactsArgs {
  projectId: number;
  audienceId: number;
  contacts: Array<AudienceContact>;
}

export interface AddAudienceContactsReturn {
  ok: boolean;
}
export interface RemoveAudienceContactsArgs {
  projectId: number;
  audienceId: number;
  contactIds: Array<number>;
}

export interface RemoveAudienceContactsReturn {
  ok: boolean;
}
export interface FindAudienceContactsArgs {
  projectId: number;
  audienceId: number;
  address?: string;
  email?: string;
}

export interface FindAudienceContactsReturn {
  contact: Array<AudienceContact>;
}
export interface RegisterAudienceContactArgs {
  projectId: number;
  audienceId: number;
  contact: AudienceContact;
  walletProof: WalletProof;
}

export interface RegisterAudienceContactReturn {
  ok: boolean;
}
export interface GetRegisteredAudienceContactArgs {
  projectId: number;
  audienceId: number;
  walletProof: WalletProof;
}

export interface GetRegisteredAudienceContactReturn {
  contact: AudienceContact;
}
export interface GetAudienceRegistrationPublicStatusArgs {
  projectId: number;
  audienceId: number;
}

export interface GetAudienceRegistrationPublicStatusReturn {
  status: AudienceRegistrationStatus;
}
export interface IsAudienceContactRegisteredArgs {
  projectId: number;
  audienceId: number;
  walletAddress: string;
}

export interface IsAudienceContactRegisteredReturn {
  registered: boolean;
}
export interface GetTrialArgs {
  projectId: number;
  trialType: TrialType;
}

export interface GetTrialReturn {
  trial: Trial;
}
export interface StartTrialArgs {
  projectId: number;
  trialType: TrialType;
}

export interface StartTrialReturn {
  trial: Trial;
}
export interface AdminListUsersArgs {
  email?: string;
  address?: string;
  sysAdmin?: boolean;
  page?: Page;
}

export interface AdminListUsersReturn {
  page: Page;
  users: Array<User>;
}
export interface AdminGetUserArgs {
  address: string;
}

export interface AdminGetUserReturn {
  user: User;
}
export interface AdminFindUsersArgs {
  email: string;
}

export interface AdminFindUsersReturn {
  users: Array<User>;
}
export interface AdminUpdateUserArgs {
  address: string;
  email?: string;
  sysAdmin?: boolean;
}

export interface AdminUpdateUserReturn {
  user: User;
}
export interface AdminGetProjectArgs {
  projectId: number;
}

export interface AdminGetProjectReturn {
  project: Project;
  history: Array<ProjectSubscription>;
}
export interface AdminSetProjectOwnerArgs {
  projectId: number;
  address: string;
}

export interface AdminSetProjectOwnerReturn {
  ok: boolean;
}
export interface AdminListProjectsArgs {
  ecosystemId?: number;
  filter: ProjectListFilter;
  page?: Page;
}

export interface AdminListProjectsReturn {
  page: Page;
  projects: Array<Project>;
}
export interface AdminRestoreProjectArgs {
  projectId: number;
}

export interface AdminRestoreProjectReturn {
  ok: boolean;
}
export interface AdminGetWaasTemplateArgs {
  projectId: number;
  templateType?: TemplateType;
}

export interface AdminGetWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface AdminUpdateWaasTemplateArgs {
  projectId: number;
  update: WaasTemplate;
}

export interface AdminUpdateWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface AdminCreateWaasTemplateArgs {
  projectId: number;
  template: WaasTemplate;
}

export interface AdminCreateWaasTemplateReturn {
  waasTemplate: WaasTemplate;
}
export interface AdminContractProjectLookupArgs {
  chainId: number;
  address: string;
}

export interface AdminContractProjectLookupReturn {
  contracts: Array<Contract>;
}
export interface AdminGetUserOverrideArgs {
  userAddress: string;
}

export interface AdminGetUserOverrideReturn {
  settings: UserSettings;
  override: UserOverride;
}
export interface AdminSetUserOverrideArgs {
  override: UserOverride;
}

export interface AdminSetUserOverrideReturn {
  settings: UserSettings;
}
export interface AdminGetBillingSettingsArgs {
  projectId: number;
}

export interface AdminGetBillingSettingsReturn {
  settings: BillingOverride;
}
export interface AdminSetBillingSettingsArgs {
  projectId: number;
  settings: BillingOverride;
}

export interface AdminSetBillingSettingsReturn {
  ok: boolean;
}
export interface AdminSetProjectLicenseArgs {
  projectId: number;
  licenseId: number;
}

export interface AdminSetProjectLicenseReturn {
  ok: boolean;
}
export interface AdminRelayerAddressGasSponsorsArgs {
  chainId: number;
  address: string;
  page?: Page;
}

export interface AdminRelayerAddressGasSponsorsReturn {
  page: Page;
  gasSponsors: Array<RelayerGasSponsor>;
}
export interface AdminCloudCommerceEventArgs {
  eventId: string;
  payload: { [key: string]: any };
}

export interface AdminCloudCommerceEventReturn {
  ok: boolean;
}
export interface AdminListAuditLogsArgs {
  projectId?: number;
  walletAddress?: string;
  auditType?: AuditType;
  email?: string;
  page?: Page;
}

export interface AdminListAuditLogsReturn {
  logs: Array<AuditLog>;
  page: Page;
}
export interface JobqueueListRunnersArgs {
  workGroup?: string;
}

export interface JobqueueListRunnersReturn {
  runners: Array<TaskRunner>;
}
export interface JobqueueListTasksArgs {
  queue?: string;
  status?: TaskStatus;
  page?: Page;
}

export interface JobqueueListTasksReturn {
  page: Page;
  tasks: Array<Task>;
}
export interface JobqueueGetTaskArgs {
  id: number;
}

export interface JobqueueGetTaskReturn {
  task: Task;
}
export interface JobqueueFindTaskArgs {
  queue: string;
  hash: string;
}

export interface JobqueueFindTaskReturn {
  task: Task;
}
export interface IsInTokenDirectoryArgs {
  chainId: number;
  address: string;
}

export interface IsInTokenDirectoryReturn {
  ok: boolean;
  featureIndex: number;
}
export interface SetTokenDirectoryFeatureIndexArgs {
  chainId: number;
  address: string;
  featureIndex: number;
}

export interface SetTokenDirectoryFeatureIndexReturn {
  ok: boolean;
}
export interface AddContractToTokenDirectoryArgs {
  chainId: number;
  address: string;
}

export interface AddContractToTokenDirectoryReturn {
  ok: boolean;
}
export interface RemoveContractFromTokenDirectoryArgs {
  chainId: number;
  address: string;
}

export interface RemoveContractFromTokenDirectoryReturn {
  ok: boolean;
}
export interface GetContractInfoOverrideArgs {
  chainId: number;
  address: string;
}

export interface GetContractInfoOverrideReturn {
  contractInfoOverride: ContractInfoOverride;
}
export interface AddContractInfoOverrideArgs {
  chainId: number;
  address: string;
  contractInfoOverride: ContractInfoOverride;
}

export interface AddContractInfoOverrideReturn {
  ok: boolean;
}
export interface UpdateContractInfoOverrideArgs {
  chainId: number;
  address: string;
  contractInfoOverride: ContractInfoOverride;
}

export interface UpdateContractInfoOverrideReturn {
  ok: boolean;
}
export interface RemoveContractInfoOverrideArgs {
  chainId: number;
  address: string;
}

export interface RemoveContractInfoOverrideReturn {
  ok: boolean;
}
export interface AdminGetMarketplaceCollectionArgs {
  projectId: number;
  chainId: number;
  contractAddress: string;
}

export interface AdminGetMarketplaceCollectionReturn {
  collection: AdminMarketplaceCollection;
}
export interface AdminListMarketplaceCollectionsArgs {
  projectId: number;
  chainId: number;
  page: Page;
}

export interface AdminListMarketplaceCollectionsReturn {
  collections: Array<AdminMarketplaceCollection>;
  page: Page;
}
export interface AdminUpdateMarketplaceCollectionArgs {
  projectId: number;
  collection: AdminMarketplaceCollection;
}

export interface AdminUpdateMarketplaceCollectionReturn {
  collection: AdminMarketplaceCollection;
}

//
// Client
//
export class Analytics implements Analytics {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/Analytics/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  totalCompute = (
    args: TotalComputeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalComputeReturn> => {
    return this.fetch(
      this.url("TotalCompute"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            computeStats: <Array<Chart>>_data.computeStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  computeByService = (
    args: ComputeByServiceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ComputeByServiceReturn> => {
    return this.fetch(
      this.url("ComputeByService"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            computeStats: <Array<MultiValueChart>>_data.computeStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyComputeByType = (
    args: DailyComputeByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyComputeByTypeReturn> => {
    return this.fetch(
      this.url("DailyComputeByType"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            computeStats: <Array<MultiValueChart>>_data.computeStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyComputeByService = (
    args: DailyComputeByServiceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyComputeByServiceReturn> => {
    return this.fetch(
      this.url("DailyComputeByService"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            computeStats: <{ [key: string]: Array<Chart> }>_data.computeStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getOrderbookCollections = (
    args: GetOrderbookCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOrderbookCollectionsReturn> => {
    return this.fetch(
      this.url("GetOrderbookCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<QueryResult>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  creditsPerDailyActiveUser = (
    args: CreditsPerDailyActiveUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreditsPerDailyActiveUserReturn> => {
    return this.fetch(
      this.url("CreditsPerDailyActiveUser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  creditsPerMonthlyActiveUser = (
    args: CreditsPerMonthlyActiveUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreditsPerMonthlyActiveUserReturn> => {
    return this.fetch(
      this.url("CreditsPerMonthlyActiveUser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsTotal = (
    args: WalletsTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTotalReturn> => {
    return this.fetch(
      this.url("WalletsTotal"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsDaily = (
    args: WalletsDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsDailyReturn> => {
    return this.fetch(
      this.url("WalletsDaily"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsMonthly = (
    args: WalletsMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsMonthlyReturn> => {
    return this.fetch(
      this.url("WalletsMonthly"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByCountry = (
    args: WalletsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByCountryReturn> => {
    return this.fetch(
      this.url("WalletsByCountry"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByDevice = (
    args: WalletsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByDeviceReturn> => {
    return this.fetch(
      this.url("WalletsByDevice"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByBrowser = (
    args: WalletsByBrowserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByBrowserReturn> => {
    return this.fetch(
      this.url("WalletsByBrowser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByOS = (
    args: WalletsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByOSReturn> => {
    return this.fetch(
      this.url("WalletsByOS"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByType = (
    args: WalletsByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByTypeReturn> => {
    return this.fetch(
      this.url("WalletsByType"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsTxnSentTotal = (
    args: WalletsTxnSentTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentTotalReturn> => {
    return this.fetch(
      this.url("WalletsTxnSentTotal"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsTxnSentDaily = (
    args: WalletsTxnSentDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentDailyReturn> => {
    return this.fetch(
      this.url("WalletsTxnSentDaily"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsTxnSentMonthly = (
    args: WalletsTxnSentMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsTxnSentMonthlyReturn> => {
    return this.fetch(
      this.url("WalletsTxnSentMonthly"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<Chart>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  walletsByOrigin = (
    args: WalletsByOriginArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WalletsByOriginReturn> => {
    return this.fetch(
      this.url("WalletsByOrigin"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  connectionsByOrigin = (
    args: ConnectionsByOriginArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ConnectionsByOriginReturn> => {
    return this.fetch(
      this.url("ConnectionsByOrigin"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStats: <Array<ChartWithPercentage>>_data.walletStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketTxnEventTotal = (
    args: MarketTxnEventTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventTotalReturn> => {
    return this.fetch(
      this.url("MarketTxnEventTotal"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketTxnEventDaily = (
    args: MarketTxnEventDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventDailyReturn> => {
    return this.fetch(
      this.url("MarketTxnEventDaily"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<MultiValueChart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketTxnEventMonthly = (
    args: MarketTxnEventMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketTxnEventMonthlyReturn> => {
    return this.fetch(
      this.url("MarketTxnEventMonthly"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketWalletsTotal = (
    args: MarketWalletsTotalArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsTotalReturn> => {
    return this.fetch(
      this.url("MarketWalletsTotal"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketWalletsDaily = (
    args: MarketWalletsDailyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsDailyReturn> => {
    return this.fetch(
      this.url("MarketWalletsDaily"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  marketWalletsMonthly = (
    args: MarketWalletsMonthlyArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MarketWalletsMonthlyReturn> => {
    return this.fetch(
      this.url("MarketWalletsMonthly"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  totalWalletTxnConversionRate = (
    args: TotalWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalWalletTxnConversionRateReturn> => {
    return this.fetch(
      this.url("TotalWalletTxnConversionRate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyWalletTxnConversionRate = (
    args: DailyWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyWalletTxnConversionRateReturn> => {
    return this.fetch(
      this.url("DailyWalletTxnConversionRate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  monthlyWalletTxnConversionRate = (
    args: MonthlyWalletTxnConversionRateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyWalletTxnConversionRateReturn> => {
    return this.fetch(
      this.url("MonthlyWalletTxnConversionRate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketStats: <Array<Chart>>_data.marketStats,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyNewWallets = (
    args: DailyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyNewWalletsReturn> => {
    return this.fetch(
      this.url("DailyNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  monthlyNewWallets = (
    args: MonthlyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyNewWalletsReturn> => {
    return this.fetch(
      this.url("MonthlyNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  totalNewWallets = (
    args: TotalNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalNewWalletsReturn> => {
    return this.fetch(
      this.url("TotalNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageDAU = (
    args: AverageDAUArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageDAUReturn> => {
    return this.fetch(
      this.url("AverageDAU"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  rollingStickiness = (
    args: RollingStickinessArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RollingStickinessReturn> => {
    return this.fetch(
      this.url("RollingStickiness"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageStickiness = (
    args: AverageStickinessArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageStickinessReturn> => {
    return this.fetch(
      this.url("AverageStickiness"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  d1RetentionByCohort = (
    args: D1RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D1RetentionByCohortReturn> => {
    return this.fetch(
      this.url("D1RetentionByCohort"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  d3RetentionByCohort = (
    args: D3RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D3RetentionByCohortReturn> => {
    return this.fetch(
      this.url("D3RetentionByCohort"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  d7RetentionByCohort = (
    args: D7RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D7RetentionByCohortReturn> => {
    return this.fetch(
      this.url("D7RetentionByCohort"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  d14RetentionByCohort = (
    args: D14RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D14RetentionByCohortReturn> => {
    return this.fetch(
      this.url("D14RetentionByCohort"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  d28RetentionByCohort = (
    args: D28RetentionByCohortArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<D28RetentionByCohortReturn> => {
    return this.fetch(
      this.url("D28RetentionByCohort"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageD1Retention = (
    args: AverageD1RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD1RetentionReturn> => {
    return this.fetch(
      this.url("AverageD1Retention"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageD3Retention = (
    args: AverageD3RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD3RetentionReturn> => {
    return this.fetch(
      this.url("AverageD3Retention"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageD7Retention = (
    args: AverageD7RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD7RetentionReturn> => {
    return this.fetch(
      this.url("AverageD7Retention"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageD14Retention = (
    args: AverageD14RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD14RetentionReturn> => {
    return this.fetch(
      this.url("AverageD14Retention"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  averageD28Retention = (
    args: AverageD28RetentionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AverageD28RetentionReturn> => {
    return this.fetch(
      this.url("AverageD28Retention"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  monthlyActiveWalletsBySegment = (
    args: MonthlyActiveWalletsBySegmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyActiveWalletsBySegmentReturn> => {
    return this.fetch(
      this.url("MonthlyActiveWalletsBySegment"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <{ [key: string]: Array<Chart> }>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  monthlyTransactingWalletsBySegment = (
    args: MonthlyTransactingWalletsBySegmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyTransactingWalletsBySegmentReturn> => {
    return this.fetch(
      this.url("MonthlyTransactingWalletsBySegment"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <{ [key: string]: Array<Chart> }>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  weeklyActiveWallets = (
    args: WeeklyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WeeklyActiveWalletsReturn> => {
    return this.fetch(
      this.url("WeeklyActiveWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  totalViews = (
    args: TotalViewsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TotalViewsReturn> => {
    return this.fetch(
      this.url("TotalViews"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyViews = (
    args: DailyViewsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyViewsReturn> => {
    return this.fetch(
      this.url("DailyViews"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  viewsByCountry = (
    args: ViewsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByCountryReturn> => {
    return this.fetch(
      this.url("ViewsByCountry"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  viewsByDevice = (
    args: ViewsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByDeviceReturn> => {
    return this.fetch(
      this.url("ViewsByDevice"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  viewsByOS = (
    args: ViewsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ViewsByOSReturn> => {
    return this.fetch(
      this.url("ViewsByOS"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  dailyUniqueVisitors = (
    args: DailyUniqueVisitorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DailyUniqueVisitorsReturn> => {
    return this.fetch(
      this.url("DailyUniqueVisitors"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  monthlyUniqueVisitors = (
    args: MonthlyUniqueVisitorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<MonthlyUniqueVisitorsReturn> => {
    return this.fetch(
      this.url("MonthlyUniqueVisitors"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  activeSessions = (
    args: ActiveSessionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ActiveSessionsReturn> => {
    return this.fetch(
      this.url("ActiveSessions"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  userEvents = (
    args: UserEventsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserEventsReturn> => {
    return this.fetch(
      this.url("UserEvents"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalWallets = (
    args: EcosystemTotalWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemTotalWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalProjects = (
    args: EcosystemTotalProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalProjectsReturn> => {
    return this.fetch(
      this.url("EcosystemTotalProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalActiveProjects = (
    args: EcosystemTotalActiveProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalActiveProjectsReturn> => {
    return this.fetch(
      this.url("EcosystemTotalActiveProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalDevelopers = (
    args: EcosystemTotalDevelopersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalDevelopersReturn> => {
    return this.fetch(
      this.url("EcosystemTotalDevelopers"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemDailyActiveWallets = (
    args: EcosystemDailyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyActiveWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemDailyActiveWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyActiveWallets = (
    args: EcosystemMonthlyActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyActiveWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyActiveWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemDailyNewProjects = (
    args: EcosystemDailyNewProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyNewProjectsReturn> => {
    return this.fetch(
      this.url("EcosystemDailyNewProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyNewProjects = (
    args: EcosystemMonthlyNewProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyNewProjectsReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyNewProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalContracts = (
    args: EcosystemTotalContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalContractsReturn> => {
    return this.fetch(
      this.url("EcosystemTotalContracts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyContracts = (
    args: EcosystemMonthlyContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyContractsReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyContracts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTopProjectsByWallets = (
    args: EcosystemTopProjectsByWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemTopProjectsByWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTopProjectsByActiveWallets = (
    args: EcosystemTopProjectsByActiveWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByActiveWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemTopProjectsByActiveWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTopProjectsByNewWallets = (
    args: EcosystemTopProjectsByNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByNewWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemTopProjectsByNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsPerProject = (
    args: EcosystemWalletsPerProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsPerProjectReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsPerProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyWalletsPerProject = (
    args: EcosystemMonthlyWalletsPerProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyWalletsPerProjectReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyWalletsPerProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemDailyNewWallets = (
    args: EcosystemDailyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemDailyNewWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemDailyNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyNewWallets = (
    args: EcosystemMonthlyNewWalletsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyNewWalletsReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyNewWallets"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTopProjectsByDeveloperActivity = (
    args: EcosystemTopProjectsByDeveloperActivityArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTopProjectsByDeveloperActivityReturn> => {
    return this.fetch(
      this.url("EcosystemTopProjectsByDeveloperActivity"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<MultiValueChart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemTotalMarketplaces = (
    args: EcosystemTotalMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemTotalMarketplacesReturn> => {
    return this.fetch(
      this.url("EcosystemTotalMarketplaces"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemMonthlyMarketplaces = (
    args: EcosystemMonthlyMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemMonthlyMarketplacesReturn> => {
    return this.fetch(
      this.url("EcosystemMonthlyMarketplaces"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemActiveMarketplaces = (
    args: EcosystemActiveMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemActiveMarketplacesReturn> => {
    return this.fetch(
      this.url("EcosystemActiveMarketplaces"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<Chart>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsByCountry = (
    args: EcosystemWalletsByCountryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByCountryReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsByCountry"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsByDevice = (
    args: EcosystemWalletsByDeviceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByDeviceReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsByDevice"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsByOS = (
    args: EcosystemWalletsByOSArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByOSReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsByOS"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsByBrowser = (
    args: EcosystemWalletsByBrowserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByBrowserReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsByBrowser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  ecosystemWalletsByType = (
    args: EcosystemWalletsByTypeArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<EcosystemWalletsByTypeReturn> => {
    return this.fetch(
      this.url("EcosystemWalletsByType"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <Array<ChartWithPercentage>>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}
export class ContractLibrary implements ContractLibrary {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/ContractLibrary/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  listItems = (
    args: ListItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListItemsReturn> => {
    return this.fetch(
      this.url("ListItems"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            items: <Array<ContractLibraryItem>>_data.items,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getItem = (
    args: GetItemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetItemReturn> => {
    return this.fetch(
      this.url("GetItem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            item: <ContractLibraryItem>_data.item,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listVersions = (
    args: ListVersionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListVersionsReturn> => {
    return this.fetch(
      this.url("ListVersions"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            itemVersions: <Array<ContractLibraryVersion>>_data.itemVersions,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getVersion = (
    args: GetVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetVersionReturn> => {
    return this.fetch(
      this.url("GetVersion"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            itemVersion: <ContractLibraryVersion>_data.itemVersion,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findVersion = (
    args: FindVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindVersionReturn> => {
    return this.fetch(
      this.url("FindVersion"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            itemVersion: <ContractLibraryVersion>_data.itemVersion,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  detectContractVersion = (
    args: DetectContractVersionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DetectContractVersionReturn> => {
    return this.fetch(
      this.url("DetectContractVersion"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            version: <ContractLibraryVersion>_data.version,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  syncContract = (
    args: SyncContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncContractReturn> => {
    return this.fetch(
      this.url("SyncContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            version: <ContractLibraryVersion>_data.version,
            source: <ProjectContractSource>_data.source,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listProjectSources = (
    args: ListProjectSourcesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectSourcesReturn> => {
    return this.fetch(
      this.url("ListProjectSources"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            sources: <Array<ProjectContractSource>>_data.sources,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getProjectSource = (
    args: GetProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetProjectSourceReturn> => {
    return this.fetch(
      this.url("GetProjectSource"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            source: <ProjectContractSource>_data.source,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addProjectSource = (
    args: AddProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddProjectSourceReturn> => {
    return this.fetch(
      this.url("AddProjectSource"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            source: <ProjectContractSource>_data.source,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateProjectSource = (
    args: UpdateProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateProjectSourceReturn> => {
    return this.fetch(
      this.url("UpdateProjectSource"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            source: <ProjectContractSource>_data.source,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  notifyDeploy = (
    args: NotifyDeployArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<NotifyDeployReturn> => {
    return this.fetch(
      this.url("NotifyDeploy"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteProjectSource = (
    args: DeleteProjectSourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectSourceReturn> => {
    return this.fetch(
      this.url("DeleteProjectSource"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}
export class EcosystemManager implements EcosystemManager {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/EcosystemManager/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  createEcosystem = (
    args: CreateEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateEcosystemReturn> => {
    return this.fetch(
      this.url("CreateEcosystem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ecosystem: <Ecosystem>_data.ecosystem,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEcosystem = (
    args: GetEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemReturn> => {
    return this.fetch(
      this.url("GetEcosystem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ecosystem: <Ecosystem>_data.ecosystem,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findEcosystem = (
    args: FindEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindEcosystemReturn> => {
    return this.fetch(
      this.url("FindEcosystem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ecosystem: <Ecosystem>_data.ecosystem,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateEcosystem = (
    args: UpdateEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemReturn> => {
    return this.fetch(
      this.url("UpdateEcosystem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listEcosystems = (
    args: ListEcosystemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemsReturn> => {
    return this.fetch(
      this.url("ListEcosystems"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            ecosystems: <Array<Ecosystem>>_data.ecosystems,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setEcosystemCollaborator = (
    args: SetEcosystemCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetEcosystemCollaboratorReturn> => {
    return this.fetch(
      this.url("SetEcosystemCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEcosystemCollaborator = (
    args: GetEcosystemCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemCollaboratorReturn> => {
    return this.fetch(
      this.url("GetEcosystemCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            level: <EcosystemCollaborator>_data.level,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listEcosystemCollaborators = (
    args: ListEcosystemCollaboratorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemCollaboratorsReturn> => {
    return this.fetch(
      this.url("ListEcosystemCollaborators"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            collaborators: <Array<EcosystemCollaborator>>_data.collaborators,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createEcosystemLicense = (
    args: CreateEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateEcosystemLicenseReturn> => {
    return this.fetch(
      this.url("CreateEcosystemLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            license: <EcosystemLicense>_data.license,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEcosystemLicense = (
    args: GetEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemLicenseReturn> => {
    return this.fetch(
      this.url("GetEcosystemLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            license: <EcosystemLicense>_data.license,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateEcosystemLicense = (
    args: UpdateEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemLicenseReturn> => {
    return this.fetch(
      this.url("UpdateEcosystemLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listEcosystemLicenses = (
    args: ListEcosystemLicensesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemLicensesReturn> => {
    return this.fetch(
      this.url("ListEcosystemLicenses"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            licenses: <Array<EcosystemLicense>>_data.licenses,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteEcosystemLicense = (
    args: DeleteEcosystemLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteEcosystemLicenseReturn> => {
    return this.fetch(
      this.url("DeleteEcosystemLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEcosystemDefaultLicense = (
    args: GetEcosystemDefaultLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemDefaultLicenseReturn> => {
    return this.fetch(
      this.url("GetEcosystemDefaultLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            license: <EcosystemLicense>_data.license,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setEcosystemDefaultLicense = (
    args: SetEcosystemDefaultLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetEcosystemDefaultLicenseReturn> => {
    return this.fetch(
      this.url("SetEcosystemDefaultLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  assignLicense = (
    args: AssignLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AssignLicenseReturn> => {
    return this.fetch(
      this.url("AssignLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateEcosystemSettings = (
    args: UpdateEcosystemSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEcosystemSettingsReturn> => {
    return this.fetch(
      this.url("UpdateEcosystemSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listTemplates = (
    args: ListTemplatesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListTemplatesReturn> => {
    return this.fetch(
      this.url("ListTemplates"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            templates: <{ [key: string]: EcosystemTemplate }>_data.templates,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getTemplate = (
    args: GetTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTemplateReturn> => {
    return this.fetch(
      this.url("GetTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            template: <EcosystemTemplate>_data.template,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setTemplate = (
    args: SetTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetTemplateReturn> => {
    return this.fetch(
      this.url("SetTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            template: <EcosystemTemplate>_data.template,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setProjectEcosystem = (
    args: SetProjectEcosystemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectEcosystemReturn> => {
    return this.fetch(
      this.url("SetProjectEcosystem"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listEcosystemProjects = (
    args: ListEcosystemProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListEcosystemProjectsReturn> => {
    return this.fetch(
      this.url("ListEcosystemProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            projects: <Array<Project>>_data.projects,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEcosystemProject = (
    args: GetEcosystemProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEcosystemProjectReturn> => {
    return this.fetch(
      this.url("GetEcosystemProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            project: <Project>_data.project,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  restoreEcosystemProject = (
    args: RestoreEcosystemProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RestoreEcosystemProjectReturn> => {
    return this.fetch(
      this.url("RestoreEcosystemProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}
export class GasTank implements GasTank {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/GasTank/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  getBalance = (
    args: GetBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetBalanceReturn> => {
    return this.fetch(
      this.url("GetBalance"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            balance: <number>_data.balance,
            markupFactor: <number>_data.markupFactor,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adjustProjectBalance = (
    args: AdjustProjectBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdjustProjectBalanceReturn> => {
    return this.fetch(
      this.url("AdjustProjectBalance"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            balance: <number>_data.balance,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  spendBalance = (
    args: SpendBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SpendBalanceReturn> => {
    return this.fetch(
      this.url("SpendBalance"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            balance: <number>_data.balance,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}
export class MarketplaceService implements MarketplaceService {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/MarketplaceService/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  getMarketplace = (
    args: GetMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceReturn> => {
    return this.fetch(
      this.url("GetMarketplace"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketplace: <Marketplace>_data.marketplace,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createMarketplace = (
    args: CreateMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateMarketplaceReturn> => {
    return this.fetch(
      this.url("CreateMarketplace"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketplace: <Marketplace>_data.marketplace,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateMarketplace = (
    args: UpdateMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMarketplaceReturn> => {
    return this.fetch(
      this.url("UpdateMarketplace"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketplace: <Marketplace>_data.marketplace,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteMarketplace = (
    args: DeleteMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteMarketplaceReturn> => {
    return this.fetch(
      this.url("DeleteMarketplace"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listMarketCollections = (
    args: ListMarketCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListMarketCollectionsReturn> => {
    return this.fetch(
      this.url("ListMarketCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            collections: <Array<MarketCollection>>_data.collections,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getMarketCollection = (
    args: GetMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketCollectionReturn> => {
    return this.fetch(
      this.url("GetMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <MarketCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findMarketCollection = (
    args: FindMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindMarketCollectionReturn> => {
    return this.fetch(
      this.url("FindMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <MarketCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addMarketCollection = (
    args: AddMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddMarketCollectionReturn> => {
    return this.fetch(
      this.url("AddMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <MarketCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateMarketCollection = (
    args: UpdateMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMarketCollectionReturn> => {
    return this.fetch(
      this.url("UpdateMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <MarketCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  reorderMarketCollections = (
    args: ReorderMarketCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ReorderMarketCollectionsReturn> => {
    return this.fetch(
      this.url("ReorderMarketCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  syncMarketCollection = (
    args: SyncMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncMarketCollectionReturn> => {
    return this.fetch(
      this.url("SyncMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteMarketCollection = (
    args: DeleteMarketCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteMarketCollectionReturn> => {
    return this.fetch(
      this.url("DeleteMarketCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listShopCollections = (
    args: ListShopCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListShopCollectionsReturn> => {
    return this.fetch(
      this.url("ListShopCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            collections: <Array<ShopCollection>>_data.collections,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getShopCollection = (
    args: GetShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetShopCollectionReturn> => {
    return this.fetch(
      this.url("GetShopCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <ShopCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findShopCollection = (
    args: FindShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindShopCollectionReturn> => {
    return this.fetch(
      this.url("FindShopCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <ShopCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addShopCollection = (
    args: AddShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddShopCollectionReturn> => {
    return this.fetch(
      this.url("AddShopCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <ShopCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateShopCollection = (
    args: UpdateShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateShopCollectionReturn> => {
    return this.fetch(
      this.url("UpdateShopCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <ShopCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  reorderShopCollections = (
    args: ReorderShopCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ReorderShopCollectionsReturn> => {
    return this.fetch(
      this.url("ReorderShopCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteShopCollection = (
    args: DeleteShopCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteShopCollectionReturn> => {
    return this.fetch(
      this.url("DeleteShopCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listHostnames = (
    args: ListHostnamesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListHostnamesReturn> => {
    return this.fetch(
      this.url("ListHostnames"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            hostnames: <Array<MarketplaceHostname>>_data.hostnames,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addHostname = (
    args: AddHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddHostnameReturn> => {
    return this.fetch(
      this.url("AddHostname"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            hostname: <MarketplaceHostname>_data.hostname,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteHostname = (
    args: DeleteHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteHostnameReturn> => {
    return this.fetch(
      this.url("DeleteHostname"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  changeDefaultHostname = (
    args: ChangeDefaultHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ChangeDefaultHostnameReturn> => {
    return this.fetch(
      this.url("ChangeDefaultHostname"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            hostname: <MarketplaceHostname>_data.hostname,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  resetHostname = (
    args: ResetHostnameArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ResetHostnameReturn> => {
    return this.fetch(
      this.url("ResetHostname"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  lookupMarketplace = (
    args: LookupMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupMarketplaceReturn> => {
    return this.fetch(
      this.url("LookupMarketplace"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            marketplace: <Marketplace>_data.marketplace,
            marketCollections: <Array<MarketCollection>>_data.marketCollections,
            shopCollections: <Array<ShopCollection>>_data.shopCollections,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}
export class Builder implements Builder {
  protected hostname: string;
  protected fetch: Fetch;
  protected path = "/rpc/Builder/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init);
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(
      this.url("Ping"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <boolean>_data.status,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  version = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<VersionReturn> => {
    return this.fetch(
      this.url("Version"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            version: <Version>_data.version,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  runtimeStatus = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<RuntimeStatusReturn> => {
    return this.fetch(
      this.url("RuntimeStatus"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <RuntimeStatus>_data.status,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getConfiguration = (
    args: GetConfigurationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetConfigurationReturn> => {
    return this.fetch(
      this.url("GetConfiguration"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <Configuration>_data.config,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getCurrentUser = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCurrentUserReturn> => {
    return this.fetch(
      this.url("GetCurrentUser"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            user: <User>_data.user,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getCurrentUserSettings = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCurrentUserSettingsReturn> => {
    return this.fetch(
      this.url("GetCurrentUserSettings"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            settings: <UserSettings>_data.settings,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEmailPreferences = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEmailPreferencesReturn> => {
    return this.fetch(
      this.url("GetEmailPreferences"),
      createHTTPRequest({}, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            preferences: <{ [key: string]: boolean }>_data.preferences,
            labels: <{ [key: string]: string }>_data.labels,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateEmailPreferences = (
    args: UpdateEmailPreferencesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateEmailPreferencesReturn> => {
    return this.fetch(
      this.url("UpdateEmailPreferences"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getAuthToken = (
    args: GetAuthTokenArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAuthTokenReturn> => {
    return this.fetch(
      this.url("GetAuthToken"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            auth: <AuthState>_data.auth,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createProject = (
    args: CreateProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateProjectReturn> => {
    return this.fetch(
      this.url("CreateProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            project: <Project>_data.project,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getProject = (
    args: GetProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetProjectReturn> => {
    return this.fetch(
      this.url("GetProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            project: <Project>_data.project,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateProject = (
    args: UpdateProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateProjectReturn> => {
    return this.fetch(
      this.url("UpdateProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addProjectChain = (
    args: AddProjectChainArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddProjectChainReturn> => {
    return this.fetch(
      this.url("AddProjectChain"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            chainIds: <Array<number>>_data.chainIds,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  removeProjectChain = (
    args: RemoveProjectChainArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveProjectChainReturn> => {
    return this.fetch(
      this.url("RemoveProjectChain"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            chainIds: <Array<number>>_data.chainIds,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setProjectChains = (
    args: SetProjectChainsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectChainsReturn> => {
    return this.fetch(
      this.url("SetProjectChains"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteProject = (
    args: DeleteProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectReturn> => {
    return this.fetch(
      this.url("DeleteProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listProjects = (
    args: ListProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectsReturn> => {
    return this.fetch(
      this.url("ListProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            projects: <Array<Project>>_data.projects,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  countProjects = (
    args: CountProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CountProjectsReturn> => {
    return this.fetch(
      this.url("CountProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            count: <number>_data.count,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getResource = (
    args: GetResourceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetResourceReturn> => {
    return this.fetch(
      this.url("GetResource"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            resource: <Resource>_data.resource,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setProjectImplicitRegistry = (
    args: SetProjectImplicitRegistryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetProjectImplicitRegistryReturn> => {
    return this.fetch(
      this.url("SetProjectImplicitRegistry"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createCollaborator = (
    args: CreateCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateCollaboratorReturn> => {
    return this.fetch(
      this.url("CreateCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collaborator: <Collaborator>_data.collaborator,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getCollaborator = (
    args: GetCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollaboratorReturn> => {
    return this.fetch(
      this.url("GetCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collaborator: <Collaborator>_data.collaborator,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateCollaborator = (
    args: UpdateCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateCollaboratorReturn> => {
    return this.fetch(
      this.url("UpdateCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collaborator: <Collaborator>_data.collaborator,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  removeCollaborator = (
    args: RemoveCollaboratorArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveCollaboratorReturn> => {
    return this.fetch(
      this.url("RemoveCollaborator"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listCollaborators = (
    args: ListCollaboratorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollaboratorsReturn> => {
    return this.fetch(
      this.url("ListCollaborators"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            collaborators: <Array<Collaborator>>_data.collaborators,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addServiceAccount = (
    args: AddServiceAccountArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddServiceAccountReturn> => {
    return this.fetch(
      this.url("AddServiceAccount"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collaborator: <Collaborator>_data.collaborator,
            jwtToken: <string>_data.jwtToken,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getServiceAccount = (
    args: GetServiceAccountArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetServiceAccountReturn> => {
    return this.fetch(
      this.url("GetServiceAccount"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collaborator: <Collaborator>_data.collaborator,
            jwtToken: <string>_data.jwtToken,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createContract = (
    args: CreateContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateContractReturn> => {
    return this.fetch(
      this.url("CreateContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contract: <Contract>_data.contract,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getContract = (
    args: GetContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractReturn> => {
    return this.fetch(
      this.url("GetContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contract: <Contract>_data.contract,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateContract = (
    args: UpdateContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateContractReturn> => {
    return this.fetch(
      this.url("UpdateContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setContractItemsAddress = (
    args: SetContractItemsAddressArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetContractItemsAddressReturn> => {
    return this.fetch(
      this.url("SetContractItemsAddress"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contract: <Contract>_data.contract,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteContract = (
    args: DeleteContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteContractReturn> => {
    return this.fetch(
      this.url("DeleteContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listContracts = (
    args: ListContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListContractsReturn> => {
    return this.fetch(
      this.url("ListContracts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            contracts: <Array<Contract>>_data.contracts,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  exploreContractLinks = (
    args: ExploreContractLinksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ExploreContractLinksReturn> => {
    return this.fetch(
      this.url("ExploreContractLinks"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            links: <Array<ContractLink>>_data.links,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findProjectContract = (
    args: FindProjectContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindProjectContractReturn> => {
    return this.fetch(
      this.url("FindProjectContract"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contract: <Contract>_data.contract,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getContractLinks = (
    args: GetContractLinksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractLinksReturn> => {
    return this.fetch(
      this.url("GetContractLinks"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contracts: <Array<Contract>>_data.contracts,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  syncContracts = (
    args: SyncContractsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SyncContractsReturn> => {
    return this.fetch(
      this.url("SyncContracts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getContractTags = (
    args: GetContractTagsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractTagsReturn> => {
    return this.fetch(
      this.url("GetContractTags"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            tags: <Array<ContractTag>>_data.tags,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  contractLookup = (
    args: ContractLookupArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ContractLookupReturn> => {
    return this.fetch(
      this.url("ContractLookup"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contract: <Contract>_data.contract,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getWaasTemplate = (
    args: GetWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetWaasTemplateReturn> => {
    return this.fetch(
      this.url("GetWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createWaasTemplate = (
    args: CreateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateWaasTemplateReturn> => {
    return this.fetch(
      this.url("CreateWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateWaasTemplate = (
    args: UpdateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWaasTemplateReturn> => {
    return this.fetch(
      this.url("UpdateWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getEmailTemplate = (
    args: GetEmailTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetEmailTemplateReturn> => {
    return this.fetch(
      this.url("GetEmailTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            emailTemplate: <WaasTemplate>_data.emailTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  gasTankStatus = (
    args: GasTankStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GasTankStatusReturn> => {
    return this.fetch(
      this.url("GasTankStatus"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <GasTankStatus>_data.status,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createBillingSession = (
    args: CreateBillingSessionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateBillingSessionReturn> => {
    return this.fetch(
      this.url("CreateBillingSession"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            session: <Redirect>_data.session,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateTopupSettings = (
    args: UpdateTopupSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateTopupSettingsReturn> => {
    return this.fetch(
      this.url("UpdateTopupSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            invoiceUrl: <string>_data.invoiceUrl,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  topUpGasTank = (
    args: TopUpGasTankArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TopUpGasTankReturn> => {
    return this.fetch(
      this.url("TopUpGasTank"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            invoiceUrl: <string>_data.invoiceUrl,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getInvoices = (
    args: GetInvoicesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetInvoicesReturn> => {
    return this.fetch(
      this.url("GetInvoices"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            data: <InvoicesReturn>_data.data,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getSubscriptionInfo = (
    args: GetSubscriptionInfoArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetSubscriptionInfoReturn> => {
    return this.fetch(
      this.url("GetSubscriptionInfo"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            subscription: <SubscriptionInfo>_data.subscription,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createProjectInvitation = (
    args: CreateProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateProjectInvitationReturn> => {
    return this.fetch(
      this.url("CreateProjectInvitation"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            invitation: <ProjectInvitation>_data.invitation,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listProjectInvitations = (
    args: ListProjectInvitationsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectInvitationsReturn> => {
    return this.fetch(
      this.url("ListProjectInvitations"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            invitations: <Array<ProjectInvitation>>_data.invitations,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteProjectInvitation = (
    args: DeleteProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectInvitationReturn> => {
    return this.fetch(
      this.url("DeleteProjectInvitation"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  useProjectInvitation = (
    args: UseProjectInvitationArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UseProjectInvitationReturn> => {
    return this.fetch(
      this.url("UseProjectInvitation"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            projectId: <number>_data.projectId,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  lookupMarketplaceConfig = (
    args: LookupMarketplaceConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupMarketplaceConfigReturn> => {
    return this.fetch(
      this.url("LookupMarketplaceConfig"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            settings: <MarketplaceLegacySettings>_data.settings,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addOffchainInventory = (
    args: AddOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddOffchainInventoryReturn> => {
    return this.fetch(
      this.url("AddOffchainInventory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventoryId: <number>_data.inventoryId,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getOffchainInventory = (
    args: GetOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOffchainInventoryReturn> => {
    return this.fetch(
      this.url("GetOffchainInventory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventory: <OffchainInventory>_data.inventory,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listOffchainInventories = (
    args: ListOffchainInventoriesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainInventoriesReturn> => {
    return this.fetch(
      this.url("ListOffchainInventories"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            inventories: <Array<OffchainInventory>>_data.inventories,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateOffchainInventory = (
    args: UpdateOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateOffchainInventoryReturn> => {
    return this.fetch(
      this.url("UpdateOffchainInventory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {};
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteOffchainInventory = (
    args: DeleteOffchainInventoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteOffchainInventoryReturn> => {
    return this.fetch(
      this.url("DeleteOffchainInventory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listOffchainPayments = (
    args: ListOffchainPaymentsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainPaymentsReturn> => {
    return this.fetch(
      this.url("ListOffchainPayments"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            payments: <Array<OffchainPayment>>_data.payments,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getLegacyWalletConfig = (
    args: GetLegacyWalletConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLegacyWalletConfigReturn> => {
    return this.fetch(
      this.url("GetLegacyWalletConfig"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <LegacyWalletConfig>_data.config,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateLegacyWalletConfig = (
    args: UpdateLegacyWalletConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateLegacyWalletConfigReturn> => {
    return this.fetch(
      this.url("UpdateLegacyWalletConfig"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listProjectFiles = (
    args: ListProjectFilesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListProjectFilesReturn> => {
    return this.fetch(
      this.url("ListProjectFiles"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            files: <Array<ProjectFile>>_data.files,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteProjectFile = (
    args: DeleteProjectFileArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteProjectFileReturn> => {
    return this.fetch(
      this.url("DeleteProjectFile"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  onboardingMark = (
    args: OnboardingMarkArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<OnboardingMarkReturn> => {
    return this.fetch(
      this.url("OnboardingMark"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  onboardingStatus = (
    args: OnboardingStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<OnboardingStatusReturn> => {
    return this.fetch(
      this.url("OnboardingStatus"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            steps: <Array<OnboardingStep>>_data.steps,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getWaasSettings = (
    args: GetWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetWaasSettingsReturn> => {
    return this.fetch(
      this.url("GetWaasSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <WaasSettings>_data.config,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createWaasSettings = (
    args: CreateWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateWaasSettingsReturn> => {
    return this.fetch(
      this.url("CreateWaasSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <WaasSettings>_data.config,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateWaasSettings = (
    args: UpdateWaasSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWaasSettingsReturn> => {
    return this.fetch(
      this.url("UpdateWaasSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            config: <WaasSettings>_data.config,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  waasWalletStatus = (
    args: WaasWalletStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WaasWalletStatusReturn> => {
    return this.fetch(
      this.url("WaasWalletStatus"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            walletStatus: <Array<WaasWalletStatus>>_data.walletStatus,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deployWaasWallet = (
    args: DeployWaasWalletArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeployWaasWalletReturn> => {
    return this.fetch(
      this.url("DeployWaasWallet"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            address: <string>_data.address,
            txnHash: <string>_data.txnHash,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  cloudCommerceConnect = (
    args: CloudCommerceConnectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CloudCommerceConnectReturn> => {
    return this.fetch(
      this.url("CloudCommerceConnect"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  listAudiences = (
    args: ListAudiencesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListAudiencesReturn> => {
    return this.fetch(
      this.url("ListAudiences"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            audiences: <Array<Audience>>_data.audiences,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getAudience = (
    args: GetAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceReturn> => {
    return this.fetch(
      this.url("GetAudience"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            audience: <Audience>_data.audience,
            contracts: <Array<Contract>>_data.contracts,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  createAudience = (
    args: CreateAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreateAudienceReturn> => {
    return this.fetch(
      this.url("CreateAudience"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            audience: <Audience>_data.audience,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateAudience = (
    args: UpdateAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateAudienceReturn> => {
    return this.fetch(
      this.url("UpdateAudience"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            audience: <Audience>_data.audience,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  deleteAudience = (
    args: DeleteAudienceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteAudienceReturn> => {
    return this.fetch(
      this.url("DeleteAudience"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getAudienceContacts = (
    args: GetAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceContactsReturn> => {
    return this.fetch(
      this.url("GetAudienceContacts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            audience: <Audience>_data.audience,
            contacts: <Array<AudienceContact>>_data.contacts,
            page: <Page>_data.page,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addAudienceContacts = (
    args: AddAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddAudienceContactsReturn> => {
    return this.fetch(
      this.url("AddAudienceContacts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  removeAudienceContacts = (
    args: RemoveAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveAudienceContactsReturn> => {
    return this.fetch(
      this.url("RemoveAudienceContacts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  findAudienceContacts = (
    args: FindAudienceContactsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FindAudienceContactsReturn> => {
    return this.fetch(
      this.url("FindAudienceContacts"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contact: <Array<AudienceContact>>_data.contact,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  registerAudienceContact = (
    args: RegisterAudienceContactArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RegisterAudienceContactReturn> => {
    return this.fetch(
      this.url("RegisterAudienceContact"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getRegisteredAudienceContact = (
    args: GetRegisteredAudienceContactArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetRegisteredAudienceContactReturn> => {
    return this.fetch(
      this.url("GetRegisteredAudienceContact"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contact: <AudienceContact>_data.contact,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getAudienceRegistrationPublicStatus = (
    args: GetAudienceRegistrationPublicStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAudienceRegistrationPublicStatusReturn> => {
    return this.fetch(
      this.url("GetAudienceRegistrationPublicStatus"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            status: <AudienceRegistrationStatus>_data.status,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  isAudienceContactRegistered = (
    args: IsAudienceContactRegisteredArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsAudienceContactRegisteredReturn> => {
    return this.fetch(
      this.url("IsAudienceContactRegistered"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            registered: <boolean>_data.registered,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getTrial = (
    args: GetTrialArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTrialReturn> => {
    return this.fetch(
      this.url("GetTrial"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            trial: <Trial>_data.trial,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  startTrial = (
    args: StartTrialArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<StartTrialReturn> => {
    return this.fetch(
      this.url("StartTrial"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            trial: <Trial>_data.trial,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminListUsers = (
    args: AdminListUsersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListUsersReturn> => {
    return this.fetch(
      this.url("AdminListUsers"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            users: <Array<User>>_data.users,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetUser = (
    args: AdminGetUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetUserReturn> => {
    return this.fetch(
      this.url("AdminGetUser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            user: <User>_data.user,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminFindUsers = (
    args: AdminFindUsersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminFindUsersReturn> => {
    return this.fetch(
      this.url("AdminFindUsers"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            users: <Array<User>>_data.users,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminUpdateUser = (
    args: AdminUpdateUserArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateUserReturn> => {
    return this.fetch(
      this.url("AdminUpdateUser"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            user: <User>_data.user,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetProject = (
    args: AdminGetProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetProjectReturn> => {
    return this.fetch(
      this.url("AdminGetProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            project: <Project>_data.project,
            history: <Array<ProjectSubscription>>_data.history,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminSetProjectOwner = (
    args: AdminSetProjectOwnerArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetProjectOwnerReturn> => {
    return this.fetch(
      this.url("AdminSetProjectOwner"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminListProjects = (
    args: AdminListProjectsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListProjectsReturn> => {
    return this.fetch(
      this.url("AdminListProjects"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            projects: <Array<Project>>_data.projects,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminRestoreProject = (
    args: AdminRestoreProjectArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminRestoreProjectReturn> => {
    return this.fetch(
      this.url("AdminRestoreProject"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetWaasTemplate = (
    args: AdminGetWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetWaasTemplateReturn> => {
    return this.fetch(
      this.url("AdminGetWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminUpdateWaasTemplate = (
    args: AdminUpdateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateWaasTemplateReturn> => {
    return this.fetch(
      this.url("AdminUpdateWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminCreateWaasTemplate = (
    args: AdminCreateWaasTemplateArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminCreateWaasTemplateReturn> => {
    return this.fetch(
      this.url("AdminCreateWaasTemplate"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            waasTemplate: <WaasTemplate>_data.waasTemplate,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminContractProjectLookup = (
    args: AdminContractProjectLookupArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminContractProjectLookupReturn> => {
    return this.fetch(
      this.url("AdminContractProjectLookup"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contracts: <Array<Contract>>_data.contracts,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetUserOverride = (
    args: AdminGetUserOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetUserOverrideReturn> => {
    return this.fetch(
      this.url("AdminGetUserOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            settings: <UserSettings>_data.settings,
            override: <UserOverride>_data.override,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminSetUserOverride = (
    args: AdminSetUserOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetUserOverrideReturn> => {
    return this.fetch(
      this.url("AdminSetUserOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            settings: <UserSettings>_data.settings,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetBillingSettings = (
    args: AdminGetBillingSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetBillingSettingsReturn> => {
    return this.fetch(
      this.url("AdminGetBillingSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            settings: <BillingOverride>_data.settings,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminSetBillingSettings = (
    args: AdminSetBillingSettingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetBillingSettingsReturn> => {
    return this.fetch(
      this.url("AdminSetBillingSettings"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminSetProjectLicense = (
    args: AdminSetProjectLicenseArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminSetProjectLicenseReturn> => {
    return this.fetch(
      this.url("AdminSetProjectLicense"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminRelayerAddressGasSponsors = (
    args: AdminRelayerAddressGasSponsorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminRelayerAddressGasSponsorsReturn> => {
    return this.fetch(
      this.url("AdminRelayerAddressGasSponsors"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            gasSponsors: <Array<RelayerGasSponsor>>_data.gasSponsors,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminCloudCommerceEvent = (
    args: AdminCloudCommerceEventArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminCloudCommerceEventReturn> => {
    return this.fetch(
      this.url("AdminCloudCommerceEvent"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminListAuditLogs = (
    args: AdminListAuditLogsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListAuditLogsReturn> => {
    return this.fetch(
      this.url("AdminListAuditLogs"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            logs: <Array<AuditLog>>_data.logs,
            page: <Page>_data.page,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  jobqueueListRunners = (
    args: JobqueueListRunnersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueListRunnersReturn> => {
    return this.fetch(
      this.url("JobqueueListRunners"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            runners: <Array<TaskRunner>>_data.runners,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  jobqueueListTasks = (
    args: JobqueueListTasksArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueListTasksReturn> => {
    return this.fetch(
      this.url("JobqueueListTasks"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            page: <Page>_data.page,
            tasks: <Array<Task>>_data.tasks,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  jobqueueGetTask = (
    args: JobqueueGetTaskArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueGetTaskReturn> => {
    return this.fetch(
      this.url("JobqueueGetTask"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            task: <Task>_data.task,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  jobqueueFindTask = (
    args: JobqueueFindTaskArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<JobqueueFindTaskReturn> => {
    return this.fetch(
      this.url("JobqueueFindTask"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            task: <Task>_data.task,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  isInTokenDirectory = (
    args: IsInTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsInTokenDirectoryReturn> => {
    return this.fetch(
      this.url("IsInTokenDirectory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
            featureIndex: <number>_data.featureIndex,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  setTokenDirectoryFeatureIndex = (
    args: SetTokenDirectoryFeatureIndexArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SetTokenDirectoryFeatureIndexReturn> => {
    return this.fetch(
      this.url("SetTokenDirectoryFeatureIndex"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addContractToTokenDirectory = (
    args: AddContractToTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddContractToTokenDirectoryReturn> => {
    return this.fetch(
      this.url("AddContractToTokenDirectory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  removeContractFromTokenDirectory = (
    args: RemoveContractFromTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveContractFromTokenDirectoryReturn> => {
    return this.fetch(
      this.url("RemoveContractFromTokenDirectory"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  getContractInfoOverride = (
    args: GetContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetContractInfoOverrideReturn> => {
    return this.fetch(
      this.url("GetContractInfoOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            contractInfoOverride: <ContractInfoOverride>(
              _data.contractInfoOverride
            ),
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  addContractInfoOverride = (
    args: AddContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddContractInfoOverrideReturn> => {
    return this.fetch(
      this.url("AddContractInfoOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  updateContractInfoOverride = (
    args: UpdateContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateContractInfoOverrideReturn> => {
    return this.fetch(
      this.url("UpdateContractInfoOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  removeContractInfoOverride = (
    args: RemoveContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveContractInfoOverrideReturn> => {
    return this.fetch(
      this.url("RemoveContractInfoOverride"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            ok: <boolean>_data.ok,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminGetMarketplaceCollection = (
    args: AdminGetMarketplaceCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminGetMarketplaceCollectionReturn> => {
    return this.fetch(
      this.url("AdminGetMarketplaceCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <AdminMarketplaceCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminListMarketplaceCollections = (
    args: AdminListMarketplaceCollectionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminListMarketplaceCollectionsReturn> => {
    return this.fetch(
      this.url("AdminListMarketplaceCollections"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collections: <Array<AdminMarketplaceCollection>>_data.collections,
            page: <Page>_data.page,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };

  adminUpdateMarketplaceCollection = (
    args: AdminUpdateMarketplaceCollectionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdminUpdateMarketplaceCollectionReturn> => {
    return this.fetch(
      this.url("AdminUpdateMarketplaceCollection"),
      createHTTPRequest(args, headers, signal)
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return {
            collection: <AdminMarketplaceCollection>_data.collection,
          };
        });
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ""}`,
        });
      }
    );
  };
}

const createHTTPRequest = (
  body: object = {},
  headers: object = {},
  signal: AbortSignal | null = null
): object => {
  const reqHeaders: { [key: string]: string } = {
    ...headers,
    "Content-Type": "application/json",
  };
  reqHeaders[WebrpcHeader] = WebrpcHeaderValue;

  return {
    method: "POST",
    headers: reqHeaders,
    body: JSON.stringify(body || {}),
    signal,
  };
};

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then((text) => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`,
      });
    }
    if (!res.ok) {
      const code: number = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

export class WebrpcError extends Error {
  name: string;
  code: number;
  message: string;
  status: number;
  cause?: string;

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string;

  constructor(
    name: string,
    code: number,
    message: string,
    status: number,
    cause?: string
  ) {
    super(message);
    this.name = name || "WebrpcError";
    this.code = typeof code === "number" ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }

  static new(payload: any): WebrpcError {
    return new this(
      payload.error,
      payload.code,
      payload.message || payload.msg,
      payload.status,
      payload.cause
    );
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = "WebrpcEndpoint",
    code: number = 0,
    message: string = `endpoint error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = "WebrpcRequestFailed",
    code: number = -1,
    message: string = `request failed`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = "WebrpcBadRoute",
    code: number = -2,
    message: string = `bad route`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = "WebrpcBadMethod",
    code: number = -3,
    message: string = `bad method`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = "WebrpcBadRequest",
    code: number = -4,
    message: string = `bad request`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = "WebrpcBadResponse",
    code: number = -5,
    message: string = `bad response`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = "WebrpcServerPanic",
    code: number = -6,
    message: string = `server panic`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = "WebrpcInternalError",
    code: number = -7,
    message: string = `internal error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}

export class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(
    name: string = "WebrpcClientDisconnected",
    code: number = -8,
    message: string = `client disconnected`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(
    name: string = "WebrpcStreamLost",
    code: number = -9,
    message: string = `stream lost`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(
    name: string = "WebrpcStreamFinished",
    code: number = -10,
    message: string = `stream finished`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = "Unauthorized",
    code: number = 1000,
    message: string = `Unauthorized access`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = "PermissionDenied",
    code: number = 1001,
    message: string = `Permission denied`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError.prototype);
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(
    name: string = "SessionExpired",
    code: number = 1002,
    message: string = `Session expired`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError.prototype);
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(
    name: string = "MethodNotFound",
    code: number = 1003,
    message: string = `Method not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError.prototype);
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(
    name: string = "RequestConflict",
    code: number = 1004,
    message: string = `Conflict with target resource`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError.prototype);
  }
}

export class ServiceDisabledError extends WebrpcError {
  constructor(
    name: string = "ServiceDisabled",
    code: number = 1005,
    message: string = `Service disabled`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ServiceDisabledError.prototype);
  }
}

export class TimeoutError extends WebrpcError {
  constructor(
    name: string = "Timeout",
    code: number = 2000,
    message: string = `Request timed out`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError.prototype);
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(
    name: string = "InvalidArgument",
    code: number = 2001,
    message: string = `Invalid argument`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
}

export class NotFoundError extends WebrpcError {
  constructor(
    name: string = "NotFound",
    code: number = 3000,
    message: string = `Resource not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export class UserNotFoundError extends WebrpcError {
  constructor(
    name: string = "UserNotFound",
    code: number = 3001,
    message: string = `User not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UserNotFoundError.prototype);
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(
    name: string = "ProjectNotFound",
    code: number = 3002,
    message: string = `Project not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype);
  }
}

export class InvalidTierError extends WebrpcError {
  constructor(
    name: string = "InvalidTier",
    code: number = 3003,
    message: string = `Invalid subscription tier`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidTierError.prototype);
  }
}

export class EmailTemplateExistsError extends WebrpcError {
  constructor(
    name: string = "EmailTemplateExists",
    code: number = 3004,
    message: string = `Email Template exists`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, EmailTemplateExistsError.prototype);
  }
}

export class SubscriptionLimitError extends WebrpcError {
  constructor(
    name: string = "SubscriptionLimit",
    code: number = 3005,
    message: string = `Subscription limit reached`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, SubscriptionLimitError.prototype);
  }
}

export class FeatureNotIncludedError extends WebrpcError {
  constructor(
    name: string = "FeatureNotIncluded",
    code: number = 3006,
    message: string = `Feature not included`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, FeatureNotIncludedError.prototype);
  }
}

export class InvalidNetworkError extends WebrpcError {
  constructor(
    name: string = "InvalidNetwork",
    code: number = 3007,
    message: string = `Invalid network`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidNetworkError.prototype);
  }
}

export class InvitationExpiredError extends WebrpcError {
  constructor(
    name: string = "InvitationExpired",
    code: number = 4000,
    message: string = `Invitation code is expired`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvitationExpiredError.prototype);
  }
}

export class AlreadyCollaboratorError extends WebrpcError {
  constructor(
    name: string = "AlreadyCollaborator",
    code: number = 4001,
    message: string = `Already a collaborator`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AlreadyCollaboratorError.prototype);
  }
}

export class NoPaymentMethodError extends WebrpcError {
  constructor(
    name: string = "NoPaymentMethod",
    code: number = 4002,
    message: string = `No default payment method`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NoPaymentMethodError.prototype);
  }
}

export class SeatsLimitReachedError extends WebrpcError {
  constructor(
    name: string = "SeatsLimitReached",
    code: number = 4003,
    message: string = `Seats limit reached`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, SeatsLimitReachedError.prototype);
  }
}

export enum errors {
  WebrpcEndpoint = "WebrpcEndpoint",
  WebrpcRequestFailed = "WebrpcRequestFailed",
  WebrpcBadRoute = "WebrpcBadRoute",
  WebrpcBadMethod = "WebrpcBadMethod",
  WebrpcBadRequest = "WebrpcBadRequest",
  WebrpcBadResponse = "WebrpcBadResponse",
  WebrpcServerPanic = "WebrpcServerPanic",
  WebrpcInternalError = "WebrpcInternalError",
  WebrpcClientDisconnected = "WebrpcClientDisconnected",
  WebrpcStreamLost = "WebrpcStreamLost",
  WebrpcStreamFinished = "WebrpcStreamFinished",
  Unauthorized = "Unauthorized",
  PermissionDenied = "PermissionDenied",
  SessionExpired = "SessionExpired",
  MethodNotFound = "MethodNotFound",
  RequestConflict = "RequestConflict",
  ServiceDisabled = "ServiceDisabled",
  Timeout = "Timeout",
  InvalidArgument = "InvalidArgument",
  NotFound = "NotFound",
  UserNotFound = "UserNotFound",
  ProjectNotFound = "ProjectNotFound",
  InvalidTier = "InvalidTier",
  EmailTemplateExists = "EmailTemplateExists",
  SubscriptionLimit = "SubscriptionLimit",
  FeatureNotIncluded = "FeatureNotIncluded",
  InvalidNetwork = "InvalidNetwork",
  InvitationExpired = "InvitationExpired",
  AlreadyCollaborator = "AlreadyCollaborator",
  NoPaymentMethod = "NoPaymentMethod",
  SeatsLimitReached = "SeatsLimitReached",
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientDisconnected = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  ServiceDisabled = 1005,
  Timeout = 2000,
  InvalidArgument = 2001,
  NotFound = 3000,
  UserNotFound = 3001,
  ProjectNotFound = 3002,
  InvalidTier = 3003,
  EmailTemplateExists = 3004,
  SubscriptionLimit = 3005,
  FeatureNotIncluded = 3006,
  InvalidNetwork = 3007,
  InvitationExpired = 4000,
  AlreadyCollaborator = 4001,
  NoPaymentMethod = 4002,
  SeatsLimitReached = 4003,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: ServiceDisabledError,
  [2000]: TimeoutError,
  [2001]: InvalidArgumentError,
  [3000]: NotFoundError,
  [3001]: UserNotFoundError,
  [3002]: ProjectNotFoundError,
  [3003]: InvalidTierError,
  [3004]: EmailTemplateExistsError,
  [3005]: SubscriptionLimitError,
  [3006]: FeatureNotIncludedError,
  [3007]: InvalidNetworkError,
  [4000]: InvitationExpiredError,
  [4001]: AlreadyCollaboratorError,
  [4002]: NoPaymentMethodError,
  [4003]: SeatsLimitReachedError,
};

export type Fetch = (
  input: RequestInfo,
  init?: RequestInit
) => Promise<Response>;
