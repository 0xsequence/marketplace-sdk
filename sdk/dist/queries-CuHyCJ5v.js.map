{"version":3,"file":"queries-CuHyCJ5v.js","names":["args: Omit<UseBalanceOfCollectibleArgs, 'userAddress'> & {\n\t\tuserAddress: Address;\n\t}","config: SdkConfig","args: UseBalanceOfCollectibleArgs","params: FetchCollectibleParams","apiArgs: GetTokenMetadataArgs","params: CollectibleQueryOptions","params: FetchCollectionDetailsParams","apiArgs: GetCollectionDetailArgs","params: CollectionDetailsQueryOptions","params: FetchMarketCurrenciesParams","params: MarketCurrenciesQueryOptions","args: UseCountOfPrimarySaleItemsArgs","config: SdkConfig","params: FetchCurrencyParams","currency","params: CurrencyQueryOptions","params: FetchFloorOrderParams","apiArgs: GetFloorOrderArgs","params: FloorOrderQueryOptions","params: FetchHighestOfferParams","apiArgs: GetCollectibleHighestOfferArgs","params: HighestOfferQueryOptions","args: UseListBalancesArgs","config: SdkConfig","page: Page","params: FetchListCollectiblesParams","marketplaceConfig: MarketplaceConfig","page: Page","apiArgs: ListCollectiblesArgs","collectibles: CollectibleOrder[]","params: ListCollectiblesQueryOptions","args: UseInventoryArgs","collectionKey: string","token: TokenBalance","chainId: number","accountAddress: Address","collectionAddress: Address","config: SdkConfig","state: InventoryState","isLaos721: boolean","page: IndexerPage","page: Page","collectibles: CollectibleOrder[]","c: CollectibleOrder","args: GetInventoryArgs","marketplaceConfig: MarketplaceConfig","params: FetchListCollectionsParams","params: ListCollectionsQueryOptions","params: FetchListTokenMetadataParams","params: ListTokenMetadataQueryOptions","params: FetchLowestListingParams","apiArgs: GetCollectibleLowestListingArgs","params: LowestListingQueryOptions","params: FetchTokenSuppliesParams","result","apiArgs: GetTokenSuppliesArgs","params: TokenSuppliesQueryOptions"],"sources":["../src/react/queries/balanceOfCollectible.ts","../src/react/queries/collectible.ts","../src/react/queries/collectionDetails.ts","../src/react/queries/marketCurrencies.ts","../src/react/queries/countOfPrimarySaleItems.ts","../src/react/queries/currency.ts","../src/react/queries/floorOrder.ts","../src/react/queries/highestOffer.ts","../src/react/queries/listBalances.ts","../src/react/queries/listCollectibles.ts","../src/react/queries/inventory.ts","../src/react/queries/listCollections.ts","../src/react/queries/listTokenMetadata.ts","../src/react/queries/lowestListing.ts","../src/react/queries/tokenSupplies.ts"],"sourcesContent":["import { queryOptions, skipToken } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { UseQueryParameters } from 'wagmi/query';\nimport type { SdkConfig } from '../../types';\nimport { collectableKeys, getIndexerClient, LaosAPI } from '../_internal';\n\nexport type UseBalanceOfCollectibleArgs = {\n\tcollectionAddress: Address;\n\tcollectableId: string;\n\tuserAddress: Address | undefined;\n\tchainId: number;\n\tisLaos721?: boolean;\n\tquery?: UseQueryParameters;\n};\n\n/**\n * Fetches the balance of a specific collectible for a user\n *\n * @param args - Arguments for the API call\n * @param config - SDK configuration\n * @returns The balance data\n */\nexport async function fetchBalanceOfCollectible(\n\targs: Omit<UseBalanceOfCollectibleArgs, 'userAddress'> & {\n\t\tuserAddress: Address;\n\t},\n\tconfig: SdkConfig,\n) {\n\tif (args.isLaos721) {\n\t\tconst laosApi = new LaosAPI();\n\t\tconst response = await laosApi.getTokenBalances({\n\t\t\tchainId: args.chainId.toString(),\n\t\t\tcontractAddress: args.collectionAddress,\n\t\t\taccountAddress: args.userAddress,\n\t\t\tincludeMetadata: true,\n\t\t});\n\n\t\treturn response.balances[0] || null;\n\t}\n\n\tconst indexerClient = getIndexerClient(args.chainId, config);\n\treturn indexerClient\n\t\t.getTokenBalances({\n\t\t\taccountAddress: args.userAddress,\n\t\t\tcontractAddress: args.collectionAddress,\n\t\t\ttokenID: args.collectableId,\n\t\t\tincludeMetadata: false,\n\t\t\tmetadataOptions: {\n\t\t\t\tverifiedOnly: true,\n\t\t\t\tincludeContracts: [args.collectionAddress],\n\t\t\t},\n\t\t})\n\t\t.then((res) => res.balances[0] || null);\n}\n\n/**\n * Creates a tanstack query options object for the balance query\n *\n * @param args - The query arguments\n * @param config - SDK configuration\n * @returns Query options configuration\n */\nexport function balanceOfCollectibleOptions(\n\targs: UseBalanceOfCollectibleArgs,\n\tconfig: SdkConfig,\n) {\n\tconst enabled = !!args.userAddress && (args.query?.enabled ?? true);\n\treturn queryOptions({\n\t\tqueryKey: [...collectableKeys.userBalances, args],\n\t\tqueryFn: enabled\n\t\t\t? () =>\n\t\t\t\t\tfetchBalanceOfCollectible(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...args,\n\t\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: this is guaranteed by the userAddress check above\n\t\t\t\t\t\t\tuserAddress: args.userAddress!,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t)\n\t\t\t: skipToken,\n\t});\n}\n","import type { GetTokenMetadataArgs } from '@0xsequence/metadata';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport { getMetadataClient, type ValuesOptional } from '../_internal';\nimport { collectableKeys } from '../_internal/api/query-keys';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchCollectibleParams\n\textends Omit<\n\t\tGetTokenMetadataArgs,\n\t\t'chainID' | 'contractAddress' | 'tokenIDs'\n\t> {\n\tchainId: number;\n\tcollectionAddress: string;\n\tcollectibleId: string;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches collectible metadata from the metadata API\n */\nexport async function fetchCollectible(params: FetchCollectibleParams) {\n\tconst { collectionAddress, collectibleId, chainId, config } = params;\n\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst apiArgs: GetTokenMetadataArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainID: String(chainId),\n\t\ttokenIDs: [collectibleId],\n\t};\n\n\tconst result = await metadataClient.getTokenMetadata(apiArgs);\n\treturn result.tokenMetadata[0];\n}\n\nexport type CollectibleQueryOptions = ValuesOptional<FetchCollectibleParams> & {\n\tquery?: StandardQueryOptions;\n};\n\nexport function collectibleQueryOptions(params: CollectibleQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.collectibleId &&\n\t\t\tparams.chainId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectableKeys.details, params],\n\t\tqueryFn: () =>\n\t\t\tfetchCollectible({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectibleId: params.collectibleId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport { getMarketplaceClient, type ValuesOptional } from '../_internal';\nimport type { GetCollectionDetailArgs } from '../_internal/api/marketplace.gen';\nimport { collectionKeys } from '../_internal/api/query-keys';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchCollectionDetailsParams\n\textends Omit<GetCollectionDetailArgs, 'chainId' | 'contractAddress'> {\n\tchainId: number;\n\tcollectionAddress: string;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches collection details from the marketplace API\n */\nexport async function fetchCollectionDetails(\n\tparams: FetchCollectionDetailsParams,\n) {\n\tconst { collectionAddress, chainId, config, ...additionalApiParams } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst apiArgs: GetCollectionDetailArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainId: String(chainId),\n\t\t...additionalApiParams,\n\t};\n\n\tconst result = await marketplaceClient.getCollectionDetail(apiArgs);\n\treturn result.collection;\n}\n\nexport type CollectionDetailsQueryOptions =\n\tValuesOptional<FetchCollectionDetailsParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function collectionDetailsQueryOptions(\n\tparams: CollectionDetailsQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectionKeys.detail, params],\n\t\tqueryFn: () =>\n\t\t\tfetchCollectionDetails({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport { type Address, zeroAddress } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport { compareAddress } from '../../utils';\nimport {\n\tcurrencyKeys,\n\tgetMarketplaceClient,\n\tgetQueryClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\nimport { marketplaceConfigOptions } from './marketplaceConfig';\n\nexport interface FetchMarketCurrenciesParams {\n\tchainId: number;\n\tincludeNativeCurrency?: boolean;\n\tcollectionAddress?: Address;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches supported currencies for a marketplace\n */\nexport async function fetchMarketCurrencies(\n\tparams: FetchMarketCurrenciesParams,\n) {\n\tconst { chainId, includeNativeCurrency, collectionAddress, config } = params;\n\tconst includeNativeCurrencyOption = includeNativeCurrency ?? true;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tlet currencies = await marketplaceClient\n\t\t.listCurrencies({\n\t\t\tchainId: String(chainId),\n\t\t})\n\t\t.then((resp) =>\n\t\t\tresp.currencies.map((currency) => ({\n\t\t\t\t...currency,\n\t\t\t\tcontractAddress: currency.contractAddress || zeroAddress,\n\t\t\t})),\n\t\t);\n\n\tif (collectionAddress) {\n\t\tconst queryClient = getQueryClient();\n\t\tconst marketplaceConfig = await queryClient.fetchQuery(\n\t\t\tmarketplaceConfigOptions(config),\n\t\t);\n\n\t\tconst currenciesOptions = marketplaceConfig.market.collections.find(\n\t\t\t(collection) =>\n\t\t\t\tcompareAddress(collection.itemsAddress, collectionAddress),\n\t\t)?.currencyOptions;\n\n\t\t// Filter currencies based on collection currency options\n\t\tif (currenciesOptions) {\n\t\t\tcurrencies = currencies.filter((currency) =>\n\t\t\t\tcurrenciesOptions.includes(currency.contractAddress),\n\t\t\t);\n\t\t}\n\t}\n\n\tif (!includeNativeCurrencyOption) {\n\t\tcurrencies = currencies.filter((currency) => !currency.nativeCurrency);\n\t}\n\n\treturn currencies;\n}\n\nexport type MarketCurrenciesQueryOptions =\n\tValuesOptional<FetchMarketCurrenciesParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function marketCurrenciesQueryOptions(\n\tparams: MarketCurrenciesQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId && params.config && (params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...currencyKeys.lists, params],\n\t\tqueryFn: () =>\n\t\t\tfetchMarketCurrencies({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t\tincludeNativeCurrency: params.includeNativeCurrency,\n\t\t\t\tcollectionAddress: params.collectionAddress,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport {\n\ttype GetCountOfPrimarySaleItemsArgs,\n\tgetMarketplaceClient,\n\ttype PrimarySaleItemsFilter,\n} from '../_internal';\n\nexport interface UseCountOfPrimarySaleItemsArgs\n\textends Omit<\n\t\tGetCountOfPrimarySaleItemsArgs,\n\t\t'chainId' | 'primarySaleContractAddress'\n\t> {\n\tchainId: number;\n\tprimarySaleContractAddress: Address;\n\tfilter?: PrimarySaleItemsFilter;\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n}\n\nexport async function fetchCountOfPrimarySaleItems(\n\targs: UseCountOfPrimarySaleItemsArgs,\n\tconfig: SdkConfig,\n) {\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst { chainId, primarySaleContractAddress, filter } = args;\n\tconst data = await marketplaceClient.getCountOfPrimarySaleItems({\n\t\tchainId: String(chainId),\n\t\tprimarySaleContractAddress,\n\t\tfilter,\n\t});\n\n\treturn data.count;\n}\n\nexport function countOfPrimarySaleItemsOptions(\n\targs: UseCountOfPrimarySaleItemsArgs,\n\tconfig: SdkConfig,\n) {\n\treturn queryOptions({\n\t\tenabled: args.query?.enabled ?? true,\n\t\tqueryKey: ['countOfPrimarySaleItems', args],\n\t\tqueryFn: () => fetchCountOfPrimarySaleItems(args, config),\n\t});\n}\n","import { queryOptions, skipToken } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport {\n\ttype Currency,\n\tcurrencyKeys,\n\tgetMarketplaceClient,\n\tgetQueryClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchCurrencyParams {\n\tchainId: number;\n\tcurrencyAddress: Address;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches currency details from the marketplace API\n */\nexport async function fetchCurrency(\n\tparams: FetchCurrencyParams,\n): Promise<Currency | undefined> {\n\tconst { chainId, currencyAddress, config } = params;\n\tconst queryClient = getQueryClient();\n\n\tlet currencies = queryClient.getQueryData([...currencyKeys.lists, chainId]) as\n\t\t| Currency[]\n\t\t| undefined;\n\n\tif (!currencies) {\n\t\tconst marketplaceClient = getMarketplaceClient(config);\n\t\tcurrencies = await marketplaceClient\n\t\t\t.listCurrencies({ chainId: String(chainId) })\n\t\t\t.then((resp) => resp.currencies);\n\t}\n\n\tif (!currencies?.length) {\n\t\tthrow new Error('No currencies returned');\n\t}\n\tconst currency = currencies.find(\n\t\t(currency) =>\n\t\t\tcurrency.contractAddress.toLowerCase() === currencyAddress.toLowerCase(),\n\t);\n\n\tif (!currency) {\n\t\tthrow new Error('Currency not found');\n\t}\n\n\treturn currency;\n}\n\nexport type CurrencyQueryOptions = ValuesOptional<FetchCurrencyParams> & {\n\tquery?: StandardQueryOptions;\n};\n\nexport function currencyQueryOptions(params: CurrencyQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.currencyAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...currencyKeys.details, params],\n\t\tqueryFn:\n\t\t\tparams.chainId && params.currencyAddress\n\t\t\t\t? () =>\n\t\t\t\t\t\tfetchCurrency({\n\t\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\t\t\tchainId: params.chainId!,\n\t\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\t\t\tcurrencyAddress: params.currencyAddress!,\n\t\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\t\t\tconfig: params.config!,\n\t\t\t\t\t\t})\n\t\t\t\t: skipToken,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport {\n\tcollectableKeys,\n\ttype GetFloorOrderArgs,\n\tgetMarketplaceClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchFloorOrderParams\n\textends Omit<GetFloorOrderArgs, 'contractAddress' | 'chainId'> {\n\tcollectionAddress: string;\n\tchainId: number;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches the floor order for a collection from the marketplace API\n */\nexport async function fetchFloorOrder(params: FetchFloorOrderParams) {\n\tconst { collectionAddress, chainId, config, ...additionalApiParams } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst apiArgs: GetFloorOrderArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainId: String(chainId),\n\t\t...additionalApiParams,\n\t};\n\n\tconst result = await marketplaceClient.getFloorOrder(apiArgs);\n\treturn result.collectible;\n}\n\nexport type FloorOrderQueryOptions = ValuesOptional<FetchFloorOrderParams> & {\n\tquery?: StandardQueryOptions;\n};\n\nexport function floorOrderQueryOptions(params: FloorOrderQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectableKeys.floorOrders, params],\n\t\tqueryFn: () =>\n\t\t\tfetchFloorOrder({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t\t...((params.filter && { filter: params.filter }) || {}),\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport {\n\tcollectableKeys,\n\ttype GetCollectibleHighestOfferArgs,\n\tgetMarketplaceClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchHighestOfferParams\n\textends Omit<GetCollectibleHighestOfferArgs, 'contractAddress' | 'chainId'> {\n\tcollectionAddress: string;\n\tchainId: number;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches the highest offer for a collectible from the marketplace API\n */\nexport async function fetchHighestOffer(params: FetchHighestOfferParams) {\n\tconst { collectionAddress, chainId, config, ...additionalApiParams } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst apiArgs: GetCollectibleHighestOfferArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainId: String(chainId),\n\t\t...additionalApiParams,\n\t};\n\n\tconst result = await marketplaceClient.getCollectibleHighestOffer(apiArgs);\n\treturn result.order ?? null;\n}\n\nexport type HighestOfferQueryOptions =\n\tValuesOptional<FetchHighestOfferParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function highestOfferQueryOptions(params: HighestOfferQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.tokenId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectableKeys.highestOffers, params],\n\t\tqueryFn: () =>\n\t\t\tfetchHighestOffer({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\ttokenId: params.tokenId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { GetTokenBalancesReturn, Page } from '@0xsequence/indexer';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address, Hex } from 'viem';\nimport type { SdkConfig } from '../../types';\nimport { balanceQueries, getIndexerClient, LaosAPI } from '../_internal';\n\nexport type UseListBalancesArgs = {\n\tchainId: number;\n\taccountAddress?: Address;\n\tcontractAddress?: Address;\n\ttokenId?: string;\n\tincludeMetadata?: boolean;\n\tmetadataOptions?: {\n\t\tverifiedOnly?: boolean;\n\t\tunverifiedOnly?: boolean;\n\t\tincludeContracts?: Hex[];\n\t};\n\tincludeCollectionTokens?: boolean;\n\tpage?: Page;\n\tisLaos721?: boolean;\n\t//TODO: More options\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n};\n\nexport async function fetchBalances(\n\targs: UseListBalancesArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<GetTokenBalancesReturn> {\n\tif (args.isLaos721 && args.accountAddress) {\n\t\tconst laosClient = new LaosAPI();\n\t\treturn laosClient.getTokenBalances({\n\t\t\tchainId: args.chainId.toString(),\n\t\t\taccountAddress: args.accountAddress,\n\t\t\tcontractAddress: args.contractAddress as Address,\n\t\t\tincludeMetadata: args.includeMetadata,\n\t\t\tpage: {\n\t\t\t\tsort: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn: 'CREATED_AT',\n\t\t\t\t\t\torder: 'DESC',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t}\n\n\tconst indexerClient = getIndexerClient(args.chainId, config);\n\treturn indexerClient.getTokenBalances({\n\t\t...args,\n\t\ttokenID: args.tokenId,\n\t\tpage: page,\n\t});\n}\n\n/**\n * Creates a tanstack infinite query options object for the balances query\n *\n * @param args - The query arguments\n * @param config - SDK configuration\n * @returns Query options configuration\n */\nexport function listBalancesOptions(\n\targs: UseListBalancesArgs,\n\tconfig: SdkConfig,\n) {\n\treturn infiniteQueryOptions({\n\t\t...args.query,\n\t\tqueryKey: [...balanceQueries.lists, args, config],\n\t\tqueryFn: ({ pageParam }) => fetchBalances(args, config, pageParam),\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) => lastPage.page.after,\n\t});\n}\n","import { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport type { MarketplaceConfig, Page, SdkConfig } from '../../types';\nimport type { MarketplaceType } from '../../types/types';\nimport { compareAddress } from '../../utils';\nimport type {\n\tListCollectiblesArgs,\n\tListCollectiblesReturn,\n\tValuesOptional,\n} from '../_internal';\nimport {\n\ttype CollectibleOrder,\n\tcollectableKeys,\n\tgetMarketplaceClient,\n\tOrderSide,\n} from '../_internal';\nimport { fetchMarketplaceConfig } from '../queries/marketplaceConfig';\nimport type { StandardInfiniteQueryOptions } from '../types/query';\nimport { fetchBalances, type UseListBalancesArgs } from './listBalances';\n\nexport interface FetchListCollectiblesParams\n\textends Omit<ListCollectiblesArgs, 'chainId' | 'contractAddress'> {\n\tchainId: number;\n\tcollectionAddress: Address;\n\tisLaos721?: boolean;\n\tmarketplaceType?: MarketplaceType;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches a list of collectibles with pagination support from the Marketplace API\n */\nexport async function fetchListCollectibles(\n\tparams: FetchListCollectiblesParams,\n\tmarketplaceConfig: MarketplaceConfig,\n\tpage: Page,\n): Promise<ListCollectiblesReturn> {\n\tconst { collectionAddress, chainId, config, ...additionalApiParams } = params;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst apiArgs: ListCollectiblesArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainId: String(chainId),\n\t\tpage: page,\n\t\t...additionalApiParams,\n\t};\n\n\tif (params.marketplaceType === 'shop') {\n\t\tconst shopCollection = marketplaceConfig.shop.collections.find(\n\t\t\t(collection) =>\n\t\t\t\tcompareAddress(collection.itemsAddress, params.collectionAddress),\n\t\t);\n\n\t\tif (!shopCollection) {\n\t\t\treturn { collectibles: [] };\n\t\t}\n\n\t\tconst primarySaleItemsList = await marketplaceClient.listPrimarySaleItems(\n\t\t\t{\n\t\t\t\tchainId: params.chainId.toString(),\n\t\t\t\tprimarySaleContractAddress: shopCollection.saleAddress as Address,\n\t\t\t},\n\t\t\tmarketplaceConfig,\n\t\t);\n\n\t\treturn {\n\t\t\tcollectibles: primarySaleItemsList.primarySaleItems.map((item) => ({\n\t\t\t\tmetadata: item.metadata,\n\t\t\t\tprimarySale: {\n\t\t\t\t\tprice: {\n\t\t\t\t\t\tamount: item.primarySaleItem.priceAmount,\n\t\t\t\t\t\tformatted: item.primarySaleItem.priceAmountFormatted,\n\t\t\t\t\t\tdecimals: item.primarySaleItem.priceDecimals,\n\t\t\t\t\t\tcurrencyAddress: item.primarySaleItem.currencyAddress,\n\t\t\t\t\t},\n\t\t\t\t\tstartDate: item.primarySaleItem.startDate,\n\t\t\t\t\tendDate: item.primarySaleItem.endDate,\n\t\t\t\t\tsupplyCap: item.primarySaleItem.supply,\n\t\t\t\t\titemType: item.primarySaleItem.itemType,\n\t\t\t\t},\n\t\t\t})),\n\t\t};\n\t}\n\n\tif (params.isLaos721 && params.side === OrderSide.listing) {\n\t\ttry {\n\t\t\tconst fetchBalancesArgs = {\n\t\t\t\tchainId: params.chainId,\n\t\t\t\taccountAddress: params.filter?.inAccounts?.[0] as Address,\n\t\t\t\tcontractAddress: params.collectionAddress,\n\t\t\t\tpage: page,\n\t\t\t\tincludeMetadata: true,\n\t\t\t\tisLaos721: true,\n\t\t\t} satisfies UseListBalancesArgs;\n\n\t\t\tconst balances = await fetchBalances(fetchBalancesArgs, config, page);\n\t\t\tconst collectibles: CollectibleOrder[] = balances.balances.map(\n\t\t\t\t(balance) => {\n\t\t\t\t\tif (!balance.tokenMetadata)\n\t\t\t\t\t\tthrow new Error('Token metadata not found');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\ttokenId: balance.tokenID ?? '',\n\t\t\t\t\t\t\tattributes: balance.tokenMetadata.attributes,\n\t\t\t\t\t\t\timage: balance.tokenMetadata.image,\n\t\t\t\t\t\t\tname: balance.tokenMetadata.name,\n\t\t\t\t\t\t\tdescription: balance.tokenMetadata.description,\n\t\t\t\t\t\t\tvideo: balance.tokenMetadata.video,\n\t\t\t\t\t\t\taudio: balance.tokenMetadata.audio,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcollectibles: collectibles,\n\t\t\t\t//@ts-expect-error\n\t\t\t\tpage: balances.page,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t// If the request fails, ignore the error and return the collectibles from our indexer\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n\n\treturn await marketplaceClient.listCollectibles(apiArgs);\n}\n\nexport type ListCollectiblesQueryOptions =\n\tValuesOptional<FetchListCollectiblesParams> & {\n\t\tquery?: StandardInfiniteQueryOptions;\n\t};\n\nexport function listCollectiblesQueryOptions(\n\tparams: ListCollectiblesQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.side &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: [...collectableKeys.lists, params],\n\t\tqueryFn: async ({ pageParam }) => {\n\t\t\tconst marketplaceConfig = await fetchMarketplaceConfig({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t});\n\t\t\treturn fetchListCollectibles(\n\t\t\t\t{\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\tchainId: params.chainId!,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\tconfig: params.config!,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\tside: params.side!,\n\t\t\t\t\tfilter: params.filter,\n\t\t\t\t\tisLaos721: params.isLaos721,\n\t\t\t\t\tmarketplaceType: params.marketplaceType,\n\t\t\t\t},\n\t\t\t\tmarketplaceConfig,\n\t\t\t\tpageParam,\n\t\t\t);\n\t\t},\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type {\n\tContractInfo,\n\tPage as IndexerPage,\n\tTokenBalance,\n} from '@0xsequence/indexer';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport { OrderSide, type Page, type SdkConfig } from '../../types';\nimport {\n\ttype CollectibleOrder,\n\ttype ContractType,\n\tgetIndexerClient,\n\tLaosAPI,\n} from '../_internal';\nimport { fetchListCollectibles } from './listCollectibles';\nimport { fetchMarketplaceConfig } from './marketplaceConfig';\n\nexport interface UseInventoryArgs {\n\taccountAddress: Address;\n\tcollectionAddress: Address;\n\tchainId: number;\n\tisLaos721?: boolean;\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n}\n\n// Maintain collection state across calls\ninterface InventoryState {\n\tseenTokenIds: Set<string>;\n\tmarketplaceFinished: boolean;\n\t// Track if we've already fetched all indexer tokens\n\tindexerTokensFetched: boolean;\n\t// Store the token balances from the indexer\n\tindexerTokenBalances: Map<string, CollectibleWithBalance>;\n}\n\n// Store state per collection\nconst stateByCollection = new Map<string, InventoryState>();\n\n// Test helper to clear state between tests\nexport const clearInventoryState = () => {\n\tstateByCollection.clear();\n};\n\nconst getCollectionKey = (args: UseInventoryArgs) =>\n\t`${args.chainId}-${args.collectionAddress}-${args.accountAddress}`;\n\ninterface GetInventoryArgs extends Omit<UseInventoryArgs, 'query'> {\n\tisLaos721: boolean;\n}\n\ninterface CollectibleWithBalance extends CollectibleOrder {\n\tbalance: string;\n\tcontractInfo?: ContractInfo;\n\tcontractType: ContractType.ERC1155 | ContractType.ERC721;\n}\n\nexport interface CollectiblesResponse {\n\tcollectibles: CollectibleWithBalance[];\n\tpage: Page;\n}\n\nfunction getOrInitState(collectionKey: string): InventoryState {\n\tif (!stateByCollection.has(collectionKey)) {\n\t\tstateByCollection.set(collectionKey, {\n\t\t\tseenTokenIds: new Set<string>(),\n\t\t\tmarketplaceFinished: false,\n\t\t\tindexerTokensFetched: false,\n\t\t\tindexerTokenBalances: new Map(),\n\t\t});\n\t}\n\n\t// biome-ignore lint/style/noNonNullAssertion: guaranteed to exist, by the above init\n\treturn stateByCollection.get(collectionKey)!;\n}\n\nfunction collectibleFromTokenBalance(\n\ttoken: TokenBalance,\n): CollectibleWithBalance {\n\treturn {\n\t\tmetadata: {\n\t\t\ttokenId: token.tokenID ?? '',\n\t\t\tattributes: token.tokenMetadata?.attributes ?? [],\n\t\t\timage: token.tokenMetadata?.image,\n\t\t\tname: token.tokenMetadata?.name ?? '',\n\t\t\tdescription: token.tokenMetadata?.description,\n\t\t\tvideo: token.tokenMetadata?.video,\n\t\t\taudio: token.tokenMetadata?.audio,\n\t\t},\n\t\tcontractInfo: token.contractInfo,\n\t\tcontractType: token.contractType as unknown as\n\t\t\t| ContractType.ERC1155\n\t\t\t| ContractType.ERC721,\n\t\tbalance: token.balance,\n\t};\n}\n\nasync function fetchAllIndexerTokens(\n\tchainId: number,\n\taccountAddress: Address,\n\tcollectionAddress: Address,\n\tconfig: SdkConfig,\n\tstate: InventoryState,\n\tisLaos721: boolean,\n): Promise<void> {\n\tif (isLaos721) {\n\t\tconst laosClient = new LaosAPI();\n\t\tconst { balances } = await laosClient.getTokenBalances({\n\t\t\tchainId: chainId.toString(),\n\t\t\taccountAddress,\n\t\t\tincludeMetadata: true,\n\t\t\tcontractAddress: collectionAddress,\n\t\t\tpage: {\n\t\t\t\tsort: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn: 'CREATED_AT',\n\t\t\t\t\t\torder: 'DESC',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\tfor (const balance of balances) {\n\t\t\tif (balance.tokenID) {\n\t\t\t\tstate.indexerTokenBalances.set(\n\t\t\t\t\tbalance.tokenID,\n\t\t\t\t\tcollectibleFromTokenBalance(balance),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tstate.indexerTokensFetched = true;\n\t\treturn;\n\t}\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tlet page: IndexerPage = {\n\t\tpageSize: 50,\n\t};\n\n\twhile (true) {\n\t\tconst { balances, page: nextPage } = await indexerClient.getTokenBalances({\n\t\t\taccountAddress,\n\t\t\tcontractAddress: collectionAddress,\n\t\t\tincludeMetadata: true,\n\t\t\tpage: page,\n\t\t});\n\n\t\tfor (const balance of balances) {\n\t\t\tif (balance.tokenID) {\n\t\t\t\tstate.indexerTokenBalances.set(\n\t\t\t\t\tbalance.tokenID,\n\t\t\t\t\tcollectibleFromTokenBalance(balance),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!nextPage.more) {\n\t\t\tbreak;\n\t\t}\n\t\tpage = nextPage;\n\t}\n\n\tstate.indexerTokensFetched = true;\n}\n\n// Process indexer tokens that we haven't seen yet\nfunction processRemainingIndexerTokens(\n\tstate: InventoryState,\n\tpage: Page,\n): CollectiblesResponse {\n\tconst allTokens = Array.from(state.indexerTokenBalances.values());\n\n\t// Filter out tokens that we've already seen\n\tconst newTokens = allTokens.filter(\n\t\t(token) => !state.seenTokenIds.has(token.metadata.tokenId),\n\t);\n\n\t// Calculate pagination\n\tconst startIndex = (page.page - 1) * page.pageSize;\n\tconst endIndex = startIndex + page.pageSize;\n\tconst paginatedTokens = newTokens.slice(startIndex, endIndex);\n\n\t// Add new token IDs to the set\n\tfor (const token of paginatedTokens) {\n\t\tstate.seenTokenIds.add(token.metadata.tokenId);\n\t}\n\n\treturn {\n\t\tcollectibles: paginatedTokens,\n\t\tpage: {\n\t\t\tpage: page.page,\n\t\t\tpageSize: page.pageSize,\n\t\t\tmore: endIndex < newTokens.length,\n\t\t},\n\t};\n}\n\nfunction processMarketplaceCollectibles(\n\tcollectibles: CollectibleOrder[],\n\tstate: InventoryState,\n\tpage: Page,\n): {\n\tenrichedCollectibles: CollectibleWithBalance[];\n\tmissingTokens: CollectibleWithBalance[];\n} {\n\t// Add new token IDs to the set\n\tfor (const c of collectibles) {\n\t\tstate.seenTokenIds.add(c.metadata.tokenId);\n\t}\n\n\t// Enrich marketplace collectibles with balance data from indexer\n\tconst enrichedCollectibles = collectibles.map((c: CollectibleOrder) => {\n\t\tconst tokenId = c.metadata.tokenId;\n\t\tconst indexerData = state.indexerTokenBalances.get(tokenId);\n\n\t\treturn {\n\t\t\t...c,\n\t\t\tbalance: indexerData?.balance,\n\t\t\tcontractInfo: indexerData?.contractInfo,\n\t\t\tcontractType: indexerData?.contractType,\n\t\t} as CollectibleWithBalance;\n\t});\n\n\t// Check for missing tokens in the marketplace data\n\tconst marketplaceTokenIds = new Set(\n\t\tenrichedCollectibles.map((c) => c.metadata.tokenId),\n\t);\n\n\tconst missingTokens = Array.from(state.indexerTokenBalances.entries())\n\t\t.filter(([tokenId]) => !marketplaceTokenIds.has(tokenId))\n\t\t.map(([_, balance]) => balance)\n\t\t.slice(0, page.pageSize);\n\n\treturn { enrichedCollectibles, missingTokens };\n}\n\nexport async function fetchInventory(\n\targs: GetInventoryArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<CollectiblesResponse> {\n\tconst { accountAddress, collectionAddress, chainId, isLaos721 } = args;\n\tconst collectionKey = getCollectionKey(args);\n\tconst state = getOrInitState(collectionKey);\n\n\t// On first run, fetch all pages from the indexer\n\tif (!state.indexerTokensFetched) {\n\t\tawait fetchAllIndexerTokens(\n\t\t\tchainId,\n\t\t\taccountAddress,\n\t\t\tcollectionAddress,\n\t\t\tconfig,\n\t\t\tstate,\n\t\t\tisLaos721,\n\t\t);\n\t}\n\n\t// If marketplace API has no more results, use the indexer data\n\tif (state.marketplaceFinished) {\n\t\treturn processRemainingIndexerTokens(state, page);\n\t}\n\n\t// Fetch collectibles from marketplace API\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\tconst collectibles = await fetchListCollectibles(\n\t\t{\n\t\t\tchainId,\n\t\t\tcollectionAddress,\n\t\t\tfilter: {\n\t\t\t\tinAccounts: [accountAddress],\n\t\t\t\tincludeEmpty: true,\n\t\t\t},\n\t\t\tside: OrderSide.listing,\n\t\t\tconfig,\n\t\t},\n\t\tmarketplaceConfig,\n\t\tpage,\n\t);\n\n\t// Process the collectibles and find missing tokens\n\tconst { enrichedCollectibles, missingTokens } =\n\t\tprocessMarketplaceCollectibles(collectibles.collectibles, state, page);\n\n\t// If there are no more results from the marketplace API\n\tif (!collectibles.page?.more) {\n\t\t// Mark marketplace as finished and start using indexer data on next call\n\t\tstate.marketplaceFinished = true;\n\t\treturn {\n\t\t\tcollectibles: [...enrichedCollectibles, ...missingTokens],\n\t\t\tpage: {\n\t\t\t\tpage: collectibles.page?.page ?? page.page,\n\t\t\t\tpageSize: collectibles.page?.pageSize ?? page.pageSize,\n\t\t\t\tmore: missingTokens.length > 0,\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {\n\t\tcollectibles: enrichedCollectibles,\n\t\tpage: {\n\t\t\tpage: collectibles.page?.page ?? page.page,\n\t\t\tpageSize: collectibles.page?.pageSize ?? page.pageSize,\n\t\t\tmore: Boolean(collectibles.page?.more),\n\t\t},\n\t};\n}\n\nexport function inventoryOptions(args: UseInventoryArgs, config: SdkConfig) {\n\tconst collectionKey = getCollectionKey(args);\n\tconst enabledQuery = args.query?.enabled ?? true;\n\tconst enabled =\n\t\tenabledQuery && !!args.accountAddress && !!args.collectionAddress;\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: [\n\t\t\t'inventory',\n\t\t\targs.accountAddress,\n\t\t\targs.collectionAddress,\n\t\t\targs.chainId,\n\t\t],\n\t\tqueryFn: ({ pageParam }) =>\n\t\t\tfetchInventory(\n\t\t\t\t{\n\t\t\t\t\t...args,\n\t\t\t\t\tisLaos721: args.isLaos721 ?? false,\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t\tpageParam,\n\t\t\t),\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\tenabled,\n\t\tmeta: {\n\t\t\tonInvalidate: () => {\n\t\t\t\tstateByCollection.delete(collectionKey);\n\t\t\t},\n\t\t},\n\t});\n}\n","import type { ContractInfo } from '@0xsequence/metadata';\nimport { queryOptions, skipToken } from '@tanstack/react-query';\nimport type { MarketplaceType, SdkConfig } from '../../types';\nimport type {\n\tMarketCollection,\n\tMarketplaceConfig,\n\tShopCollection,\n} from '../../types/new-marketplace-types';\nimport { compareAddress } from '../../utils';\nimport {\n\tcollectionKeys,\n\tgetMetadataClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nconst allCollections = (marketplaceConfig: MarketplaceConfig) => {\n\treturn [\n\t\t...marketplaceConfig.market.collections,\n\t\t...marketplaceConfig.shop.collections,\n\t];\n};\n\nexport interface FetchListCollectionsParams {\n\tmarketplaceType?: MarketplaceType;\n\tmarketplaceConfig: MarketplaceConfig;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches collections from the metadata API with marketplace config filtering\n */\nexport async function fetchListCollections(params: FetchListCollectionsParams) {\n\tconst { marketplaceType, marketplaceConfig, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tlet collections = allCollections(marketplaceConfig);\n\n\tif (!collections?.length) {\n\t\treturn [];\n\t}\n\n\tif (marketplaceType) {\n\t\tcollections = collections.filter(\n\t\t\t(collection) => collection.marketplaceType === marketplaceType,\n\t\t);\n\t}\n\n\t// Group collections by chainId\n\tconst collectionsByChain = collections.reduce<Record<string, string[]>>(\n\t\t(acc, curr) => {\n\t\t\tconst { chainId, itemsAddress } = curr;\n\t\t\tif (!acc[chainId]) {\n\t\t\t\tacc[chainId] = [];\n\t\t\t}\n\t\t\tacc[chainId].push(itemsAddress);\n\t\t\treturn acc;\n\t\t},\n\t\t{},\n\t);\n\n\t// Fetch collections for each chain\n\tconst promises = Object.entries(collectionsByChain).map(\n\t\t([chainId, addresses]) =>\n\t\t\tmetadataClient\n\t\t\t\t.getContractInfoBatch({\n\t\t\t\t\tchainID: chainId,\n\t\t\t\t\tcontractAddresses: addresses,\n\t\t\t\t})\n\t\t\t\t.then((resp) => Object.values(resp.contractInfoMap)),\n\t);\n\n\tconst settled = await Promise.allSettled(promises);\n\n\t// If all promises failed, throw the first error\n\tif (settled.every((result) => result.status === 'rejected')) {\n\t\tconst firstError = settled[0] as PromiseRejectedResult;\n\t\tthrow firstError.reason;\n\t}\n\n\tconst results = settled\n\t\t.filter(\n\t\t\t(r): r is PromiseFulfilledResult<ContractInfo[]> =>\n\t\t\t\tr.status === 'fulfilled',\n\t\t)\n\t\t.flatMap((r) => r.value);\n\n\tconst collectionsWithMetadata = collections\n\t\t.map((collection) => {\n\t\t\tconst metadata = results.find((result) =>\n\t\t\t\tcompareAddress(result.address, collection.itemsAddress),\n\t\t\t);\n\t\t\treturn { collection, metadata };\n\t\t})\n\t\t.filter(\n\t\t\t(\n\t\t\t\titem,\n\t\t\t): item is {\n\t\t\t\tcollection: MarketCollection | ShopCollection;\n\t\t\t\tmetadata: ContractInfo;\n\t\t\t} => item.metadata !== undefined,\n\t\t)\n\t\t.map(({ collection, metadata }) => ({\n\t\t\t...collection,\n\t\t\t...metadata,\n\t\t}));\n\n\treturn collectionsWithMetadata;\n}\n\nexport type ListCollectionsQueryOptions =\n\tValuesOptional<FetchListCollectionsParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function listCollectionsQueryOptions(\n\tparams: ListCollectionsQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.marketplaceConfig &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectionKeys.list, params],\n\t\tqueryFn: enabled\n\t\t\t? () =>\n\t\t\t\t\tfetchListCollections({\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\t\tmarketplaceConfig: params.marketplaceConfig!,\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\t\t\tconfig: params.config!,\n\t\t\t\t\t\tmarketplaceType: params.marketplaceType,\n\t\t\t\t\t})\n\t\t\t: skipToken,\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n\n// Keep old function for backward compatibility during migration\nexport const listCollectionsOptions = ({\n\tmarketplaceType,\n\tmarketplaceConfig,\n\tconfig,\n}: {\n\tmarketplaceType?: MarketplaceType;\n\tmarketplaceConfig: MarketplaceConfig | undefined;\n\tconfig: SdkConfig;\n}) => {\n\treturn queryOptions({\n\t\tqueryKey: [\n\t\t\t...collectionKeys.list,\n\t\t\t{ marketplaceType, marketplaceConfig, config },\n\t\t],\n\t\tqueryFn: marketplaceConfig\n\t\t\t? () =>\n\t\t\t\t\tfetchListCollections({\n\t\t\t\t\t\tmarketplaceConfig,\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tmarketplaceType,\n\t\t\t\t\t})\n\t\t\t: skipToken,\n\t\tenabled: Boolean(marketplaceConfig),\n\t});\n};\n","import { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport {\n\tgetMetadataClient,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchListTokenMetadataParams {\n\tchainId: number;\n\tcontractAddress: string;\n\ttokenIds: string[];\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches token metadata from the metadata API\n */\nexport async function fetchListTokenMetadata(\n\tparams: FetchListTokenMetadataParams,\n) {\n\tconst { chainId, contractAddress, tokenIds, config } = params;\n\tconst metadataClient = getMetadataClient(config);\n\n\tconst response = await metadataClient.getTokenMetadata({\n\t\tchainID: chainId.toString(),\n\t\tcontractAddress: contractAddress,\n\t\ttokenIDs: tokenIds,\n\t});\n\n\treturn response.tokenMetadata;\n}\n\nexport type ListTokenMetadataQueryOptions =\n\tValuesOptional<FetchListTokenMetadataParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function listTokenMetadataQueryOptions(\n\tparams: ListTokenMetadataQueryOptions,\n) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.contractAddress &&\n\t\t\tparams.tokenIds?.length &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...tokenKeys.metadata, params],\n\t\tqueryFn: () =>\n\t\t\tfetchListTokenMetadata({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcontractAddress: params.contractAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\ttokenIds: params.tokenIds!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport {\n\tcollectableKeys,\n\ttype GetCollectibleLowestListingArgs,\n\ttype GetCollectibleLowestListingReturn,\n\tgetMarketplaceClient,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchLowestListingParams\n\textends Omit<GetCollectibleLowestListingArgs, 'contractAddress' | 'chainId'> {\n\tcollectionAddress: string;\n\tchainId: number;\n\tconfig: SdkConfig;\n}\n\n/**\n * Fetches the lowest listing for a collectible from the marketplace API\n */\nexport async function fetchLowestListing(\n\tparams: FetchLowestListingParams,\n): Promise<GetCollectibleLowestListingReturn['order'] | null> {\n\tconst { collectionAddress, chainId, config, ...additionalApiParams } = params;\n\n\tconst marketplaceClient = getMarketplaceClient(config);\n\n\tconst apiArgs: GetCollectibleLowestListingArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\tchainId: String(chainId),\n\t\t...additionalApiParams,\n\t};\n\n\tconst result = await marketplaceClient.getCollectibleLowestListing(apiArgs);\n\treturn result.order || null;\n}\n\nexport type LowestListingQueryOptions =\n\tValuesOptional<FetchLowestListingParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function lowestListingQueryOptions(params: LowestListingQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.collectionAddress &&\n\t\t\tparams.chainId &&\n\t\t\tparams.tokenId &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...collectableKeys.lowestListings, params],\n\t\tqueryFn: () =>\n\t\t\tfetchLowestListing({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\ttokenId: params.tokenId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n","import type { GetTokenSuppliesArgs } from '@0xsequence/indexer';\nimport { queryOptions } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../types';\nimport {\n\tgetIndexerClient,\n\tLaosAPI,\n\ttokenKeys,\n\ttype ValuesOptional,\n} from '../_internal';\nimport type { StandardQueryOptions } from '../types/query';\n\nexport interface FetchTokenSuppliesParams\n\textends Omit<GetTokenSuppliesArgs, 'contractAddress'> {\n\tchainId: number;\n\tcollectionAddress: string;\n\tconfig: SdkConfig;\n\tisLaos721?: boolean;\n}\n\n/**\n * Fetches token supplies with support for both indexer and LAOS APIs\n * Uses the more efficient single-contract APIs from both services\n */\nexport async function fetchTokenSupplies(params: FetchTokenSuppliesParams) {\n\tconst { chainId, collectionAddress, config, isLaos721, ...rest } = params;\n\n\tif (isLaos721) {\n\t\tconst laosApi = new LaosAPI();\n\n\t\t// Convert indexer Page format to LAOS PaginationOptions format\n\t\tconst laosPage = rest.page\n\t\t\t? {\n\t\t\t\t\tsort:\n\t\t\t\t\t\trest.page.sort?.map((sortBy) => ({\n\t\t\t\t\t\t\tcolumn: sortBy.column,\n\t\t\t\t\t\t\torder: sortBy.order,\n\t\t\t\t\t\t})) || [],\n\t\t\t\t}\n\t\t\t: undefined;\n\n\t\tconst result = await laosApi.getTokenSupplies({\n\t\t\tchainId: chainId.toString(),\n\t\t\tcontractAddress: collectionAddress,\n\t\t\tincludeMetadata: rest.includeMetadata,\n\t\t\tpage: laosPage,\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tconst apiArgs: GetTokenSuppliesArgs = {\n\t\tcontractAddress: collectionAddress,\n\t\t...rest,\n\t};\n\n\tconst result = await indexerClient.getTokenSupplies(apiArgs);\n\treturn result;\n}\n\nexport type TokenSuppliesQueryOptions =\n\tValuesOptional<FetchTokenSuppliesParams> & {\n\t\tquery?: StandardQueryOptions;\n\t};\n\nexport function tokenSuppliesQueryOptions(params: TokenSuppliesQueryOptions) {\n\tconst enabled = Boolean(\n\t\tparams.chainId &&\n\t\t\tparams.collectionAddress &&\n\t\t\tparams.config &&\n\t\t\t(params.query?.enabled ?? true),\n\t);\n\n\treturn queryOptions({\n\t\tqueryKey: [...tokenKeys.supplies, params],\n\t\tqueryFn: () =>\n\t\t\tfetchTokenSupplies({\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tchainId: params.chainId!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tcollectionAddress: params.collectionAddress!,\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: The enabled check above ensures these are not undefined\n\t\t\t\tconfig: params.config!,\n\t\t\t\tisLaos721: params.isLaos721,\n\t\t\t\tincludeMetadata: params.includeMetadata,\n\t\t\t\tmetadataOptions: params.metadataOptions,\n\t\t\t\tpage: params.page,\n\t\t\t}),\n\t\t...params.query,\n\t\tenabled,\n\t});\n}\n"],"mappings":"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"}