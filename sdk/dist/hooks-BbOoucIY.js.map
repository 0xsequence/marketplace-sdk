{"version":3,"file":"hooks-BbOoucIY.js","names":["context: string","enabled: boolean","data: unknown","level: 'debug' | 'error' | 'info'","message: string","data?: unknown","error: unknown","from: string","to: string","connector: Connector","wallet","chainId: number","stepItem: SignatureStep","ViemUserRejectedRequestError","stepItem: TransactionStep","chain","txHash: Hex","oldData: GetCountOfOffersForCollectibleReturn | undefined","oldData: ListOffersForCollectibleReturn | undefined","oldData: GetCountOfListingsForCollectibleReturn | undefined","oldData: ListListingsForCollectibleReturn | undefined","args: GenerateCancelTransactionArgsWithNumberChainId","config: types.SdkConfig","params: UseGenerateCancelTransactionArgs","wallet","hash: Hex | undefined","reservoirOrderId: string | undefined","params: {\n\t\torderId: string;\n\t\tmarketplace: types.MarketplaceKind;\n\t}","date: Date","params: GenerateListingTransactionArgsWithNumberChainId","config: types.SdkConfig","params: UseGenerateListingTransactionArgs","args: Omit<GenerateListingTransactionArgsWithNumberChainId, 'chainId'>","params: GenerateOfferTransactionArgsWithNumberChainId","config: SdkConfig","walletKind?: WalletKind","params: UseGenerateOfferTransactionArgs","args: Omit<GenerateOfferTransactionArgsWithNumberChainId, 'chainId'>","wallet","args: GenerateSellTransactionArgsWithNumberChainId","config: SdkConfig","params: UseGenerateSellTransactionArgs","args: Omit<GenerateSellTransactionArgsWithNumberChainId, 'chainId'>","chainId: number","stepItem: SignatureStep","ViemUserRejectedRequestError","stepItem: TransactionStep","result: Hex | undefined","_exhaustiveCheck: never","params: TransferTokensParams","accountAddress: Address"],"sources":["../src/react/_internal/logger.ts","../src/react/_internal/wallet/wallet.ts","../src/react/_internal/wallet/useWallet.ts","../src/react/hooks/util/optimisticCancelUpdates.ts","../src/react/hooks/transactions/useGenerateCancelTransaction.tsx","../src/react/hooks/transactions/useCancelTransactionSteps.tsx","../src/react/hooks/transactions/useCancelOrder.tsx","../src/utils/date.ts","../src/react/hooks/transactions/useGenerateListingTransaction.tsx","../src/react/hooks/transactions/useGenerateOfferTransaction.tsx","../src/react/hooks/transactions/useGenerateSellTransaction.tsx","../src/react/hooks/transactions/useOrderSteps.tsx","../src/react/hooks/transactions/useTransferTokens.tsx"],"sourcesContent":["export class TransactionLogger {\n\tconstructor(\n\t\tprivate readonly context: string,\n\t\tprivate readonly enabled: boolean = true,\n\t) {}\n\n\tprivate formatData(data: unknown): unknown {\n\t\tif (data instanceof Error) {\n\t\t\treturn {\n\t\t\t\tname: data.name,\n\t\t\t\tmessage: data.message,\n\t\t\t\tcause:\n\t\t\t\t\tdata.cause instanceof Error\n\t\t\t\t\t\t? this.formatData(data.cause)\n\t\t\t\t\t\t: data.cause,\n\t\t\t\tstack: data.stack?.split('\\n').slice(0, 3),\n\t\t\t};\n\t\t}\n\n\t\tif (Array.isArray(data)) {\n\t\t\treturn data.map((item) => this.formatData(item));\n\t\t}\n\n\t\tif (typeof data === 'object' && data !== null) {\n\t\t\treturn Object.fromEntries(\n\t\t\t\tObject.entries(data).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tthis.formatData(value),\n\t\t\t\t]),\n\t\t\t);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprivate log(\n\t\tlevel: 'debug' | 'error' | 'info',\n\t\tmessage: string,\n\t\tdata?: unknown,\n\t) {\n\t\tif (!this.enabled) return;\n\t\tconsole[level](\n\t\t\t`[${this.context}] ${message}`,\n\t\t\tdata ? this.formatData(data) : '',\n\t\t);\n\t}\n\n\tdebug(message: string, data?: unknown) {\n\t\tthis.log('debug', message, data);\n\t}\n\n\terror(message: string, error: unknown) {\n\t\tthis.log('error', message, error);\n\t}\n\n\tinfo(message: string, data?: unknown) {\n\t\tthis.log('info', message, data);\n\t}\n\n\tstate(from: string, to: string) {\n\t\tthis.info(`State transition: ${from} -> ${to}`);\n\t}\n}\n\nexport const createLogger = (context: string, enabled = true) =>\n\tnew TransactionLogger(context, enabled);\n","import type { TransactionReceipt } from '@0xsequence/indexer';\nimport {\n\ttype Account,\n\ttype Address,\n\tBaseError,\n\ttype Chain,\n\tcustom,\n\terc20Abi,\n\terc721Abi,\n\ttype Hex,\n\thexToBigInt,\n\tisHex,\n\ttype PublicClient,\n\tTransactionReceiptNotFoundError,\n\ttype TypedDataDomain,\n\tUserRejectedRequestError as ViemUserRejectedRequestError,\n\ttype WalletClient as ViemWalletClient,\n\tWaitForTransactionReceiptTimeoutError,\n} from 'viem';\nimport type { Connector } from 'wagmi';\nimport type { SwitchChainErrorType } from 'wagmi/actions';\nimport {\n\tSEQUENCE_MARKET_V1_ADDRESS,\n\tSEQUENCE_MARKET_V2_ADDRESS,\n} from '../../../consts';\nimport type { SdkConfig } from '../../../types/index';\nimport { ERC1155_ABI } from '../../../utils';\nimport {\n\tChainSwitchError,\n\tTransactionConfirmationError,\n\tTransactionExecutionError,\n\tTransactionSignatureError,\n\tUserRejectedRequestError,\n} from '../../../utils/_internal/error/transaction';\nimport { getIndexerClient, StepType, WalletKind } from '../api';\nimport { createLogger } from '../logger';\nimport type { SignatureStep, TransactionStep } from '../utils';\n\ninterface WalletClient extends Omit<ViemWalletClient, 'account'> {\n\taccount: Account;\n}\n\nexport interface WalletInstance {\n\ttransport: ReturnType<typeof custom>;\n\tisWaaS: boolean;\n\twalletKind: WalletKind;\n\tgetChainId: () => Promise<number>;\n\tswitchChain: (chainId: number) => Promise<void>;\n\taddress: () => Promise<Address>;\n\thandleSignMessageStep: (stepItem: SignatureStep) => Promise<Hex | undefined>;\n\thandleSendTransactionStep: (\n\t\tchainId: number,\n\t\tstepItem: TransactionStep,\n\t) => Promise<Hex>;\n\thandleConfirmTransactionStep: (\n\t\ttxHash: Hex,\n\t\tchainId: number,\n\t) => Promise<TransactionReceipt>;\n\thasTokenApproval: (args: {\n\t\ttokenType: 'ERC20' | 'ERC721' | 'ERC1155';\n\t\tcontractAddress: Address;\n\t\tspender: Address | 'sequenceMarketV1' | 'sequenceMarketV2';\n\t}) => Promise<bigint | boolean>;\n\tpublicClient: PublicClient;\n}\n\nconst isSequenceWallet = (connector: Connector) =>\n\tconnector.id === 'sequence' || connector.id === 'sequence-waas';\n\nexport const wallet = ({\n\twallet,\n\tchains,\n\tconnector,\n\tsdkConfig,\n\tpublicClient,\n}: {\n\twallet: WalletClient;\n\tchains: readonly [Chain, ...Chain[]];\n\tconnector: Connector;\n\tsdkConfig: SdkConfig;\n\tpublicClient: PublicClient;\n}): WalletInstance => {\n\tconst logger = createLogger('Wallet');\n\n\tconst walletInstance = {\n\t\ttransport: custom(wallet.transport),\n\t\tisWaaS: connector.id.endsWith('waas'),\n\t\twalletKind: isSequenceWallet(connector)\n\t\t\t? WalletKind.sequence\n\t\t\t: WalletKind.unknown,\n\t\tgetChainId: wallet.getChainId,\n\t\taddress: async () => {\n\t\t\tlet address = wallet.account?.address;\n\t\t\tif (!address) {\n\t\t\t\t[address] = await wallet.getAddresses();\n\t\t\t}\n\t\t\treturn address;\n\t\t},\n\t\tswitchChain: async (chainId: number) => {\n\t\t\tlogger.debug('Switching chain', { targetChainId: chainId });\n\n\t\t\ttry {\n\t\t\t\tawait wallet.switchChain({\n\t\t\t\t\tid: chainId,\n\t\t\t\t});\n\t\t\t\tlogger.info('Chain switch successful', { chainId });\n\t\t\t\treturn;\n\t\t\t} catch (e) {\n\t\t\t\tconst error = e as SwitchChainErrorType;\n\t\t\t\tlogger.error('Chain switch failed', error);\n\n\t\t\t\tswitch (error.name) {\n\t\t\t\t\tcase 'SwitchChainNotSupportedError':\n\t\t\t\t\t\tthrow new ChainSwitchError(await wallet.getChainId(), chainId);\n\t\t\t\t\tcase 'UserRejectedRequestError':\n\t\t\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t\t\tcase 'ChainNotConfiguredError':\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new ChainSwitchError(await wallet.getChainId(), chainId);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thandleSignMessageStep: async (stepItem: SignatureStep) => {\n\t\t\ttry {\n\t\t\t\tif (stepItem.id === StepType.signEIP191) {\n\t\t\t\t\tlogger.debug('Signing with EIP-191', { data: stepItem.data });\n\t\t\t\t\tconst message = isHex(stepItem.data)\n\t\t\t\t\t\t? { raw: stepItem.data }\n\t\t\t\t\t\t: stepItem.data;\n\t\t\t\t\treturn await wallet.signMessage({\n\t\t\t\t\t\taccount: wallet.account,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (stepItem.id === StepType.signEIP712) {\n\t\t\t\t\tlogger.debug('Signing with EIP-712', {\n\t\t\t\t\t\tdomain: stepItem.domain,\n\t\t\t\t\t\ttypes: stepItem.signature?.types,\n\t\t\t\t\t});\n\t\t\t\t\treturn await wallet.signTypedData({\n\t\t\t\t\t\taccount: wallet.account,\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\t\tdomain: stepItem.signature!.domain as TypedDataDomain,\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\t\ttypes: stepItem.signature!.types,\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\t\tprimaryType: stepItem.signature!.primaryType,\n\t\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\t\tmessage: stepItem.signature!.value,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconst error = e as TransactionSignatureError;\n\t\t\t\tlogger.error('Signature failed', error);\n\n\t\t\t\tif (error.cause instanceof BaseError) {\n\t\t\t\t\tconst viemError = error.cause as BaseError;\n\t\t\t\t\tif (viemError instanceof ViemUserRejectedRequestError) {\n\t\t\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new TransactionSignatureError(stepItem.id, error as Error);\n\t\t\t}\n\t\t},\n\t\thandleSendTransactionStep: async (\n\t\t\tchainId: number,\n\t\t\tstepItem: TransactionStep,\n\t\t) => {\n\t\t\tlogger.debug('Sending transaction', {\n\t\t\t\tchainId,\n\t\t\t\tto: stepItem.to,\n\t\t\t\tvalue: stepItem.value,\n\t\t\t});\n\n\t\t\tconst chain = chains.find((chain) => chain.id === chainId);\n\t\t\ttry {\n\t\t\t\treturn await wallet.sendTransaction({\n\t\t\t\t\tchain,\n\t\t\t\t\tdata: stepItem.data,\n\t\t\t\t\taccount: wallet.account,\n\t\t\t\t\tto: stepItem.to,\n\t\t\t\t\tvalue: hexToBigInt(stepItem.value || '0x0'),\n\t\t\t\t\t...(stepItem.maxFeePerGas && {\n\t\t\t\t\t\tmaxFeePerGas: hexToBigInt(stepItem.maxFeePerGas),\n\t\t\t\t\t}),\n\t\t\t\t\t...(stepItem.maxPriorityFeePerGas && {\n\t\t\t\t\t\tmaxPriorityFeePerGas: hexToBigInt(stepItem.maxPriorityFeePerGas),\n\t\t\t\t\t}),\n\t\t\t\t\t...(stepItem.gas && {\n\t\t\t\t\t\tgas: hexToBigInt(stepItem.gas),\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tconst error = e as TransactionExecutionError;\n\t\t\t\tlogger.error('Transaction failed', error);\n\n\t\t\t\tif (error.cause instanceof BaseError) {\n\t\t\t\t\tconst viemError = error.cause as BaseError;\n\t\t\t\t\tif (viemError instanceof ViemUserRejectedRequestError) {\n\t\t\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new TransactionExecutionError(stepItem.id, error as Error);\n\t\t\t}\n\t\t},\n\t\thandleConfirmTransactionStep: async (txHash: Hex, chainId: number) => {\n\t\t\tlogger.debug('Confirming transaction', { txHash, chainId });\n\t\t\ttry {\n\t\t\t\tconst receipt = await awaitTransactionReceipt({\n\t\t\t\t\ttxHash,\n\t\t\t\t\tchainId,\n\t\t\t\t\tsdkConfig,\n\t\t\t\t});\n\t\t\t\tlogger.info('Transaction confirmed', { txHash, receipt });\n\t\t\t\treturn receipt;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Transaction confirmation failed', error);\n\n\t\t\t\tthrow new TransactionConfirmationError(txHash, error as Error);\n\t\t\t}\n\t\t},\n\t\thasTokenApproval: async ({\n\t\t\ttokenType,\n\t\t\tcontractAddress,\n\t\t\tspender,\n\t\t}: {\n\t\t\ttokenType: 'ERC20' | 'ERC721' | 'ERC1155';\n\t\t\tcontractAddress: Address;\n\t\t\tspender: Address | 'sequenceMarketV1' | 'sequenceMarketV2';\n\t\t}) => {\n\t\t\tconst walletAddress = await walletInstance.address();\n\t\t\tconst spenderAddress =\n\t\t\t\tspender === 'sequenceMarketV1'\n\t\t\t\t\t? SEQUENCE_MARKET_V1_ADDRESS\n\t\t\t\t\t: spender === 'sequenceMarketV2'\n\t\t\t\t\t\t? SEQUENCE_MARKET_V2_ADDRESS\n\t\t\t\t\t\t: spender;\n\n\t\t\tswitch (tokenType) {\n\t\t\t\tcase 'ERC20':\n\t\t\t\t\treturn (await publicClient.readContract({\n\t\t\t\t\t\taddress: contractAddress as Address,\n\t\t\t\t\t\tabi: erc20Abi,\n\t\t\t\t\t\tfunctionName: 'allowance',\n\t\t\t\t\t\targs: [walletAddress, spenderAddress],\n\t\t\t\t\t})) as bigint;\n\t\t\t\tcase 'ERC721':\n\t\t\t\t\treturn (await publicClient.readContract({\n\t\t\t\t\t\taddress: contractAddress as Address,\n\t\t\t\t\t\tabi: erc721Abi,\n\t\t\t\t\t\tfunctionName: 'isApprovedForAll',\n\t\t\t\t\t\targs: [walletAddress, spenderAddress],\n\t\t\t\t\t})) as boolean;\n\t\t\t\tcase 'ERC1155':\n\t\t\t\t\treturn (await publicClient.readContract({\n\t\t\t\t\t\taddress: contractAddress as Address,\n\t\t\t\t\t\tabi: ERC1155_ABI,\n\t\t\t\t\t\tfunctionName: 'isApprovedForAll',\n\t\t\t\t\t\targs: [walletAddress, spenderAddress],\n\t\t\t\t\t})) as boolean;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unsupported contract type for approval checking');\n\t\t\t}\n\t\t},\n\t\tpublicClient,\n\t};\n\n\treturn walletInstance;\n};\n\nconst ONE_MIN = 60 * 1000;\nconst THREE_MIN = 3 * ONE_MIN;\n\nconst awaitTransactionReceipt = async ({\n\ttxHash,\n\tchainId,\n\tsdkConfig,\n\ttimeout = THREE_MIN,\n}: {\n\ttxHash: Hex;\n\tchainId: number;\n\tsdkConfig: SdkConfig;\n\ttimeout?: number;\n}) => {\n\tconst indexer = getIndexerClient(chainId, sdkConfig);\n\treturn Promise.race([\n\t\tnew Promise<TransactionReceipt>((resolve, reject) => {\n\t\t\tindexer.subscribeReceipts(\n\t\t\t\t{\n\t\t\t\t\tfilter: {\n\t\t\t\t\t\ttxnHash: txHash,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonMessage: ({ receipt }) => {\n\t\t\t\t\t\tresolve(receipt);\n\t\t\t\t\t},\n\t\t\t\t\tonError: () => {\n\t\t\t\t\t\treject(TransactionReceiptNotFoundError);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t}),\n\t\tnew Promise<TransactionReceipt>((_, reject) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\treject(WaitForTransactionReceiptTimeoutError);\n\t\t\t}, timeout);\n\t\t}),\n\t]);\n};\n","import { skipToken, useQuery } from '@tanstack/react-query';\nimport {\n\tuseAccount,\n\tuseChainId,\n\tusePublicClient,\n\tuseSwitchChain,\n\tuseWalletClient,\n} from 'wagmi';\nimport { useConfig } from '../../hooks';\nimport { type WalletInstance, wallet } from './wallet';\n\ntype UseWalletReturn = {\n\twallet: WalletInstance | null | undefined;\n\tisLoading: boolean;\n\tisError: boolean;\n};\n\nexport const useWallet = (): UseWalletReturn => {\n\tconst { chains } = useSwitchChain();\n\tconst {\n\t\tdata: walletClient,\n\t\tisLoading: wagmiWalletIsLoading,\n\t\tisError: wagmiWalletIsError,\n\t} = useWalletClient();\n\tconst { connector, isConnected, isConnecting } = useAccount();\n\tconst sdkConfig = useConfig();\n\tconst chainId = useChainId();\n\tconst publicClient = usePublicClient();\n\n\tconst canCreateWallet =\n\t\twalletClient && connector && isConnected && publicClient;\n\n\tconst { data, isLoading, isError } = useQuery({\n\t\tqueryKey: ['wallet', chainId, connector?.uid],\n\t\tqueryFn: canCreateWallet\n\t\t\t? () => {\n\t\t\t\t\treturn wallet({\n\t\t\t\t\t\twallet: walletClient,\n\t\t\t\t\t\tchains,\n\t\t\t\t\t\tconnector,\n\t\t\t\t\t\tsdkConfig,\n\t\t\t\t\t\tpublicClient,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t: skipToken,\n\t\tstaleTime: Number.POSITIVE_INFINITY,\n\t});\n\n\treturn {\n\t\twallet: data,\n\t\tisLoading: isLoading || isConnecting || wagmiWalletIsLoading,\n\t\tisError: isError || wagmiWalletIsError,\n\t};\n};\n","import type { QueryClient } from '@tanstack/react-query';\nimport {\n\tcollectableKeys,\n\ttype GetCountOfListingsForCollectibleReturn,\n\ttype GetCountOfOffersForCollectibleReturn,\n\ttype ListListingsForCollectibleReturn,\n\ttype ListOffersForCollectibleReturn,\n} from '../../_internal';\n\nconst SECOND = 1000;\n\ninterface OptimisticCancelUpdatesParams {\n\torderId: string;\n\tqueryClient: QueryClient;\n}\n\nexport const updateQueriesOnCancel = ({\n\torderId,\n\tqueryClient,\n}: OptimisticCancelUpdatesParams) => {\n\tqueryClient.setQueriesData(\n\t\t{ queryKey: collectableKeys.offersCount, exact: false },\n\t\t(oldData: GetCountOfOffersForCollectibleReturn | undefined) => {\n\t\t\tif (!oldData) return 0;\n\t\t\treturn Math.max(0, oldData.count - 1);\n\t\t},\n\t);\n\n\t// remove the offer with matching orderId\n\tqueryClient.setQueriesData(\n\t\t{ queryKey: collectableKeys.offers, exact: false },\n\t\t(oldData: ListOffersForCollectibleReturn | undefined) => {\n\t\t\tif (!oldData || !oldData.offers) return oldData;\n\t\t\treturn {\n\t\t\t\t...oldData,\n\t\t\t\toffers: oldData.offers.filter((offer) => offer.orderId !== orderId),\n\t\t\t};\n\t\t},\n\t);\n\n\t// 2 seconds is enough time for new data to be fetched\n\tsetTimeout(() => {\n\t\tqueryClient.invalidateQueries({\n\t\t\tqueryKey: collectableKeys.highestOffers,\n\t\t\texact: false,\n\t\t});\n\t}, 2 * SECOND);\n\n\tqueryClient.setQueriesData(\n\t\t{ queryKey: collectableKeys.listingsCount, exact: false },\n\t\t(oldData: GetCountOfListingsForCollectibleReturn | undefined) => {\n\t\t\tif (!oldData) return 0;\n\t\t\treturn Math.max(0, oldData.count - 1);\n\t\t},\n\t);\n\n\tqueryClient.setQueriesData(\n\t\t{ queryKey: collectableKeys.listings, exact: false },\n\t\t(oldData: ListListingsForCollectibleReturn | undefined) => {\n\t\t\tif (!oldData || !oldData.listings) return oldData;\n\t\t\treturn {\n\t\t\t\t...oldData,\n\t\t\t\tlistings: oldData.listings.filter(\n\t\t\t\t\t(listing) => listing.orderId !== orderId,\n\t\t\t\t),\n\t\t\t};\n\t\t},\n\t);\n\n\t// 2 seconds is enough time for new data to be fetched\n\tsetTimeout(() => {\n\t\tqueryClient.invalidateQueries({\n\t\t\tqueryKey: collectableKeys.lowestListings,\n\t\t\texact: false,\n\t\t});\n\t}, 2 * SECOND);\n};\n\nexport const invalidateQueriesOnCancel = ({\n\tqueryClient,\n}: {\n\tqueryClient: QueryClient;\n}) => {\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.offers,\n\t\texact: false,\n\t});\n\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.offersCount,\n\t\texact: false,\n\t});\n\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.listings,\n\t\texact: false,\n\t});\n\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.listingsCount,\n\t\texact: false,\n\t});\n\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.highestOffers,\n\t\texact: false,\n\t});\n\n\tqueryClient.invalidateQueries({\n\t\tqueryKey: collectableKeys.lowestListings,\n\t\texact: false,\n\t});\n};\n","import { useMutation } from '@tanstack/react-query';\nimport type * as types from '../../../types';\nimport {\n\ttype GenerateCancelTransactionArgs,\n\tgetMarketplaceClient,\n} from '../../_internal';\nimport type { Step } from '../../_internal/api/marketplace.gen';\nimport { useConfig } from '../config/useConfig';\n\n// Create a type that uses number for chainId\ntype GenerateCancelTransactionArgsWithNumberChainId = Omit<\n\tGenerateCancelTransactionArgs,\n\t'chainId'\n> & {\n\tchainId: number;\n};\n\ninterface UseGenerateCancelTransactionArgs {\n\tchainId: number;\n\tonSuccess?: (steps?: Step[]) => void;\n}\n\nexport const generateCancelTransaction = async (\n\targs: GenerateCancelTransactionArgsWithNumberChainId,\n\tconfig: types.SdkConfig,\n) => {\n\tconst marketplaceClient = getMarketplaceClient(config);\n\treturn marketplaceClient\n\t\t.generateCancelTransaction({ ...args, chainId: String(args.chainId) })\n\t\t.then((data) => data.steps);\n};\n\nexport const useGenerateCancelTransaction = (\n\tparams: UseGenerateCancelTransactionArgs,\n) => {\n\tconst config = useConfig();\n\n\tconst { mutate, mutateAsync, ...result } = useMutation({\n\t\tonSuccess: params.onSuccess,\n\t\tmutationFn: (args: GenerateCancelTransactionArgsWithNumberChainId) =>\n\t\t\tgenerateCancelTransaction(args, config),\n\t});\n\n\treturn {\n\t\t...result,\n\t\tgenerateCancelTransaction: mutate,\n\t\tgenerateCancelTransactionAsync: mutateAsync,\n\t};\n};\n","import type { Hex } from 'viem';\nimport {\n\tChainSwitchUserRejectedError,\n\tWalletInstanceNotFoundError,\n} from '../../../utils/_internal/error/transaction';\nimport {\n\tExecuteType,\n\tgetMarketplaceClient,\n\tgetQueryClient,\n\ttype MarketplaceKind,\n\ttype Step,\n\tStepType,\n} from '../../_internal';\nimport type {\n\tSignatureStep,\n\tTransactionStep as walletTransactionStep,\n} from '../../_internal/utils';\nimport { useWallet } from '../../_internal/wallet/useWallet';\nimport { useSwitchChainModal } from '../../ui/modals/_internal/components/switchChainModal';\nimport type { ModalCallbacks } from '../../ui/modals/_internal/types';\nimport { useConfig } from '../config/useConfig';\nimport {\n\tinvalidateQueriesOnCancel,\n\tupdateQueriesOnCancel,\n} from '../util/optimisticCancelUpdates';\nimport type { TransactionStep } from './useCancelOrder';\nimport { useGenerateCancelTransaction } from './useGenerateCancelTransaction';\n\ninterface UseCancelTransactionStepsArgs {\n\tcollectionAddress: string;\n\tchainId: number;\n\tcallbacks?: ModalCallbacks;\n\tsetSteps: React.Dispatch<React.SetStateAction<TransactionStep>>;\n\tonSuccess?: ({ hash, orderId }: { hash?: string; orderId?: string }) => void;\n\tonError?: (error: Error) => void;\n}\n\nexport const useCancelTransactionSteps = ({\n\tcollectionAddress,\n\tchainId,\n\tcallbacks,\n\tsetSteps,\n\tonSuccess,\n\tonError,\n}: UseCancelTransactionStepsArgs) => {\n\tconst { show: showSwitchChainModal } = useSwitchChainModal();\n\tconst { wallet, isLoading, isError } = useWallet();\n\tconst walletIsInitialized = wallet && !isLoading && !isError;\n\tconst sdkConfig = useConfig();\n\tconst marketplaceClient = getMarketplaceClient(sdkConfig);\n\tconst { generateCancelTransactionAsync } = useGenerateCancelTransaction({\n\t\tchainId,\n\t});\n\n\tconst getWalletChainId = async () => {\n\t\treturn await wallet?.getChainId();\n\t};\n\tconst switchChain = async () => {\n\t\tawait wallet?.switchChain(Number(chainId));\n\t};\n\tconst checkAndSwitchChain = async () => {\n\t\tconst walletChainId = await getWalletChainId();\n\t\tconst isWaaS = wallet?.isWaaS;\n\t\tconst chainIdMismatch = walletChainId !== Number(chainId);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (chainIdMismatch) {\n\t\t\t\tif (isWaaS) {\n\t\t\t\t\tswitchChain().then(resolve).catch(reject);\n\t\t\t\t} else {\n\t\t\t\t\tshowSwitchChainModal({\n\t\t\t\t\t\tchainIdToSwitchTo: chainId,\n\t\t\t\t\t\tonSuccess: () => resolve({ chainId: chainId }),\n\t\t\t\t\t\tonError: (error) => reject(error),\n\t\t\t\t\t\tonClose: () => reject(new ChainSwitchUserRejectedError()),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve({ chainId: chainId });\n\t\t\t}\n\t\t});\n\t};\n\n\tconst getCancelSteps = async ({\n\t\torderId,\n\t\tmarketplace,\n\t}: {\n\t\torderId: string;\n\t\tmarketplace: MarketplaceKind;\n\t}) => {\n\t\ttry {\n\t\t\tconst address = await wallet?.address();\n\n\t\t\tif (!address) {\n\t\t\t\tthrow new Error('Wallet address not found');\n\t\t\t}\n\n\t\t\tconst steps = await generateCancelTransactionAsync({\n\t\t\t\tchainId,\n\t\t\t\tcollectionAddress,\n\t\t\t\tmaker: address,\n\t\t\t\tmarketplace,\n\t\t\t\torderId,\n\t\t\t});\n\n\t\t\treturn steps;\n\t\t} catch (error) {\n\t\t\tif (callbacks?.onError) {\n\t\t\t\tcallbacks.onError(error as Error);\n\t\t\t} else {\n\t\t\t\tconsole.debug('onError callback not provided:', error);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst cancelOrder = async ({\n\t\torderId,\n\t\tmarketplace,\n\t}: {\n\t\torderId: string;\n\t\tmarketplace: MarketplaceKind;\n\t}) => {\n\t\tconst queryClient = getQueryClient();\n\t\tif (!walletIsInitialized) {\n\t\t\tthrow new WalletInstanceNotFoundError();\n\t\t}\n\n\t\ttry {\n\t\t\tawait checkAndSwitchChain();\n\n\t\t\tsetSteps((prev) => ({\n\t\t\t\t...prev,\n\t\t\t\tisExecuting: true,\n\t\t\t}));\n\n\t\t\tconst cancelSteps = await getCancelSteps({\n\t\t\t\torderId,\n\t\t\t\tmarketplace,\n\t\t\t});\n\t\t\tconst transactionStep = cancelSteps?.find(\n\t\t\t\t(step) => step.id === StepType.cancel,\n\t\t\t);\n\t\t\tconst signatureStep = cancelSteps?.find(\n\t\t\t\t(step) => step.id === StepType.signEIP712,\n\t\t\t);\n\n\t\t\tconsole.debug('transactionStep', transactionStep);\n\t\t\tconsole.debug('signatureStep', signatureStep);\n\n\t\t\tif (!transactionStep && !signatureStep) {\n\t\t\t\tthrow new Error('No transaction or signature step found');\n\t\t\t}\n\n\t\t\tlet hash: Hex | undefined;\n\t\t\tlet reservoirOrderId: string | undefined;\n\n\t\t\tif (transactionStep && wallet) {\n\t\t\t\thash = await executeTransaction({ transactionStep });\n\n\t\t\t\tif (hash) {\n\t\t\t\t\tawait wallet.handleConfirmTransactionStep(hash, Number(chainId));\n\n\t\t\t\t\tif (onSuccess && typeof onSuccess === 'function') {\n\t\t\t\t\t\tonSuccess({ hash });\n\n\t\t\t\t\t\tupdateQueriesOnCancel({\n\t\t\t\t\t\t\torderId,\n\t\t\t\t\t\t\tqueryClient,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSteps((prev) => ({\n\t\t\t\t\t\t...prev,\n\t\t\t\t\t\tisExecuting: false,\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (signatureStep) {\n\t\t\t\treservoirOrderId = await executeSignature({ signatureStep });\n\n\t\t\t\tif (onSuccess && typeof onSuccess === 'function') {\n\t\t\t\t\tonSuccess({ orderId: reservoirOrderId });\n\n\t\t\t\t\tupdateQueriesOnCancel({\n\t\t\t\t\t\torderId: reservoirOrderId,\n\t\t\t\t\t\tqueryClient,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tsetSteps((prev) => ({\n\t\t\t\t\t...prev,\n\t\t\t\t\tisExecuting: false,\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tinvalidateQueriesOnCancel({\n\t\t\t\tqueryClient,\n\t\t\t});\n\n\t\t\tsetSteps((prev) => ({\n\t\t\t\t...prev,\n\t\t\t\tisExecuting: false,\n\t\t\t}));\n\n\t\t\tif (onError && typeof onError === 'function') {\n\t\t\t\tonError(error as Error);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst executeTransaction = async ({\n\t\ttransactionStep,\n\t}: {\n\t\ttransactionStep: Step;\n\t}): Promise<Hex | undefined> => {\n\t\tconst hash = await wallet?.handleSendTransactionStep(\n\t\t\tNumber(chainId),\n\t\t\ttransactionStep as walletTransactionStep,\n\t\t);\n\n\t\treturn hash;\n\t};\n\n\tconst executeSignature = async ({\n\t\tsignatureStep,\n\t}: {\n\t\tsignatureStep: Step;\n\t}) => {\n\t\tconst signature = await wallet?.handleSignMessageStep(\n\t\t\tsignatureStep as SignatureStep,\n\t\t);\n\n\t\tconst result = await marketplaceClient.execute({\n\t\t\tchainId: String(chainId),\n\t\t\tsignature: signature as string,\n\t\t\tmethod: signatureStep.post?.method as string,\n\t\t\tendpoint: signatureStep.post?.endpoint as string,\n\t\t\tbody: signatureStep.post?.body,\n\t\t\texecuteType: ExecuteType.order,\n\t\t});\n\n\t\treturn result.orderId;\n\t};\n\n\treturn {\n\t\tcancelOrder,\n\t};\n};\n","'use client';\nimport { useWaasFeeOptions } from '@0xsequence/connect';\nimport { useEffect, useState } from 'react';\nimport type * as types from '../../_internal';\nimport { useAutoSelectFeeOption } from '../utils/useAutoSelectFeeOption';\nimport { useCancelTransactionSteps } from './useCancelTransactionSteps';\n\ninterface UseCancelOrderArgs {\n\tcollectionAddress: string;\n\tchainId: number;\n\tonSuccess?: ({ hash, orderId }: { hash?: string; orderId?: string }) => void;\n\tonError?: (error: Error) => void;\n}\n\nexport type TransactionStep = {\n\texist: boolean;\n\tisExecuting: boolean;\n\texecute: () => Promise<void>;\n};\n\nexport const useCancelOrder = ({\n\tcollectionAddress,\n\tchainId,\n\tonSuccess,\n\tonError,\n}: UseCancelOrderArgs) => {\n\tconst [steps, setSteps] = useState<TransactionStep>({\n\t\texist: false,\n\t\tisExecuting: false,\n\t\texecute: () => Promise.resolve(),\n\t});\n\tconst [cancellingOrderId, setCancellingOrderId] = useState<string | null>(\n\t\tnull,\n\t);\n\tconst [pendingFeeOptionConfirmation, confirmPendingFeeOption] =\n\t\tuseWaasFeeOptions();\n\tconst autoSelectOptionPromise = useAutoSelectFeeOption({\n\t\tpendingFeeOptionConfirmation: pendingFeeOptionConfirmation\n\t\t\t? {\n\t\t\t\t\tid: pendingFeeOptionConfirmation.id,\n\t\t\t\t\toptions: pendingFeeOptionConfirmation.options?.map((opt) => ({\n\t\t\t\t\t\t...opt,\n\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t...opt.token,\n\t\t\t\t\t\t\tcontractAddress: opt.token.contractAddress || null,\n\t\t\t\t\t\t\tdecimals: opt.token.decimals || 0,\n\t\t\t\t\t\t\ttokenID: opt.token.tokenID || null,\n\t\t\t\t\t\t},\n\t\t\t\t\t})),\n\t\t\t\t\tchainId,\n\t\t\t\t}\n\t\t\t: {\n\t\t\t\t\tid: '',\n\t\t\t\t\toptions: undefined,\n\t\t\t\t\tchainId,\n\t\t\t\t},\n\t\tenabled: !!pendingFeeOptionConfirmation,\n\t});\n\n\tuseEffect(() => {\n\t\tautoSelectOptionPromise.then((res) => {\n\t\t\tif (pendingFeeOptionConfirmation?.id && res.selectedOption) {\n\t\t\t\tconfirmPendingFeeOption(\n\t\t\t\t\tpendingFeeOptionConfirmation.id,\n\t\t\t\t\tres.selectedOption.token.contractAddress,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}, [\n\t\tautoSelectOptionPromise,\n\t\tconfirmPendingFeeOption,\n\t\tpendingFeeOptionConfirmation,\n\t]);\n\n\tconst { cancelOrder: cancelOrderBase } = useCancelTransactionSteps({\n\t\tcollectionAddress,\n\t\tchainId,\n\t\tonSuccess: (result) => {\n\t\t\tsetCancellingOrderId(null);\n\t\t\tonSuccess?.(result);\n\t\t},\n\t\tonError: (error) => {\n\t\t\tsetCancellingOrderId(null);\n\t\t\tonError?.(error);\n\t\t},\n\t\tsetSteps,\n\t});\n\n\tconst cancelOrder = async (params: {\n\t\torderId: string;\n\t\tmarketplace: types.MarketplaceKind;\n\t}) => {\n\t\tsetCancellingOrderId(params.orderId);\n\t\treturn cancelOrderBase(params);\n\t};\n\n\treturn {\n\t\tcancelOrder,\n\t\tisExecuting: steps.isExecuting,\n\t\tcancellingOrderId,\n\t};\n};\n","export const dateToUnixTime = (date: Date) =>\n\tMath.floor(date.getTime() / 1000).toString();\n","import { useMutation } from '@tanstack/react-query';\nimport { useConfig } from '../config/useConfig';\n\nexport type UseGenerateListingTransactionArgs = {\n\tchainId: number;\n\tonSuccess?: (data?: Step[]) => void;\n};\n\nimport type * as types from '../../../types';\nimport { dateToUnixTime } from '../../../utils/date';\nimport {\n\ttype CreateReq,\n\ttype GenerateListingTransactionArgs,\n\tgetMarketplaceClient,\n\ttype Step,\n} from '../../_internal';\n\nexport type CreateReqWithDateExpiry = Omit<CreateReq, 'expiry'> & {\n\texpiry: Date;\n};\n\nexport type GenerateListingTransactionProps = Omit<\n\tGenerateListingTransactionArgs,\n\t'listing'\n> & {\n\tlisting: CreateReqWithDateExpiry;\n};\n\ntype GenerateListingTransactionArgsWithNumberChainId = Omit<\n\tGenerateListingTransactionArgs,\n\t'chainId' | 'listing'\n> & {\n\tchainId: number;\n\tlisting: CreateReqWithDateExpiry;\n};\n\nexport const generateListingTransaction = async (\n\tparams: GenerateListingTransactionArgsWithNumberChainId,\n\tconfig: types.SdkConfig,\n) => {\n\tconst args = {\n\t\t...params,\n\t\tchainId: String(params.chainId),\n\t\tlisting: {\n\t\t\t...params.listing,\n\t\t\texpiry: dateToUnixTime(params.listing.expiry),\n\t\t},\n\t} satisfies GenerateListingTransactionArgs;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\treturn (await marketplaceClient.generateListingTransaction(args)).steps;\n};\n\nexport const useGenerateListingTransaction = (\n\tparams: UseGenerateListingTransactionArgs,\n) => {\n\tconst config = useConfig();\n\n\tconst { mutate, mutateAsync, ...result } = useMutation({\n\t\tonSuccess: params.onSuccess,\n\t\tmutationFn: (\n\t\t\targs: Omit<GenerateListingTransactionArgsWithNumberChainId, 'chainId'>,\n\t\t) =>\n\t\t\tgenerateListingTransaction({ ...args, chainId: params.chainId }, config),\n\t});\n\n\treturn {\n\t\t...result,\n\t\tgenerateListingTransaction: mutate,\n\t\tgenerateListingTransactionAsync: mutateAsync,\n\t};\n};\n","import { useMutation } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../../types';\nimport { dateToUnixTime } from '../../../utils/date';\nimport {\n\ttype CreateReq,\n\ttype GenerateOfferTransactionArgs,\n\tgetMarketplaceClient,\n\ttype Step,\n\ttype WalletKind,\n} from '../../_internal';\nimport { useWallet } from '../../_internal/wallet/useWallet';\nimport { useConfig } from '../config/useConfig';\n\nexport type UseGenerateOfferTransactionArgs = {\n\tchainId: number;\n\tonSuccess?: (data?: Step[]) => void;\n};\n\ntype CreateReqWithDateExpiry = Omit<CreateReq, 'expiry'> & {\n\texpiry: Date;\n};\n\nexport type GenerateOfferTransactionProps = Omit<\n\tGenerateOfferTransactionArgs,\n\t'offer'\n> & {\n\toffer: CreateReqWithDateExpiry;\n};\n\ntype GenerateOfferTransactionArgsWithNumberChainId = Omit<\n\tGenerateOfferTransactionArgs,\n\t'chainId' | 'offer'\n> & {\n\tchainId: number;\n\toffer: CreateReqWithDateExpiry;\n};\n\nexport const generateOfferTransaction = async (\n\tparams: GenerateOfferTransactionArgsWithNumberChainId,\n\tconfig: SdkConfig,\n\twalletKind?: WalletKind,\n) => {\n\tconst args = {\n\t\t...params,\n\t\tchainId: String(params.chainId),\n\t\toffer: { ...params.offer, expiry: dateToUnixTime(params.offer.expiry) },\n\t\twalletType: walletKind,\n\t} satisfies GenerateOfferTransactionArgs;\n\tconst marketplaceClient = getMarketplaceClient(config);\n\treturn (await marketplaceClient.generateOfferTransaction(args)).steps;\n};\n\nexport const useGenerateOfferTransaction = (\n\tparams: UseGenerateOfferTransactionArgs,\n) => {\n\tconst config = useConfig();\n\tconst { wallet } = useWallet();\n\n\tconst { mutate, mutateAsync, ...result } = useMutation({\n\t\tonSuccess: params.onSuccess,\n\t\tmutationFn: (\n\t\t\targs: Omit<GenerateOfferTransactionArgsWithNumberChainId, 'chainId'>,\n\t\t) =>\n\t\t\tgenerateOfferTransaction(\n\t\t\t\t{ ...args, chainId: params.chainId },\n\t\t\t\tconfig,\n\t\t\t\twallet?.walletKind,\n\t\t\t),\n\t});\n\n\treturn {\n\t\t...result,\n\t\tgenerateOfferTransaction: mutate,\n\t\tgenerateOfferTransactionAsync: mutateAsync,\n\t};\n};\n","import { useMutation } from '@tanstack/react-query';\nimport type { SdkConfig } from '../../../types/index';\nimport {\n\ttype GenerateSellTransactionArgs,\n\tgetMarketplaceClient,\n} from '../../_internal';\nimport type { Step } from '../../_internal/api/marketplace.gen';\nimport { useConfig } from '../config/useConfig';\n\ninterface UseGenerateSellTransactionArgs {\n\tchainId: number;\n\tonSuccess?: (steps?: Step[]) => void;\n}\n\ntype GenerateSellTransactionArgsWithNumberChainId = Omit<\n\tGenerateSellTransactionArgs,\n\t'chainId'\n> & { chainId: number };\n\nexport const generateSellTransaction = async (\n\targs: GenerateSellTransactionArgsWithNumberChainId,\n\tconfig: SdkConfig,\n) => {\n\tconst marketplaceClient = getMarketplaceClient(config);\n\tconst argsWithStringChainId = {\n\t\t...args,\n\t\tchainId: String(args.chainId),\n\t} satisfies GenerateSellTransactionArgs;\n\treturn marketplaceClient\n\t\t.generateSellTransaction(argsWithStringChainId)\n\t\t.then((data) => data.steps);\n};\n\nexport const useGenerateSellTransaction = (\n\tparams: UseGenerateSellTransactionArgs,\n) => {\n\tconst config = useConfig();\n\n\tconst { mutate, mutateAsync, ...result } = useMutation({\n\t\tonSuccess: params.onSuccess,\n\t\tmutationFn: (\n\t\t\targs: Omit<GenerateSellTransactionArgsWithNumberChainId, 'chainId'>,\n\t\t) => generateSellTransaction({ ...args, chainId: params.chainId }, config),\n\t});\n\n\treturn {\n\t\t...result,\n\t\tgenerateSellTransaction: mutate,\n\t\tgenerateSellTransactionAsync: mutateAsync,\n\t};\n};\n","import {\n\tBaseError,\n\ttype Hex,\n\thexToBigInt,\n\tisHex,\n\ttype TypedDataDomain,\n\tUserRejectedRequestError as ViemUserRejectedRequestError,\n} from 'viem';\nimport {\n\tuseChainId,\n\tuseSendTransaction,\n\tuseSignMessage,\n\tuseSignTypedData,\n\tuseSwitchChain,\n} from 'wagmi';\nimport {\n\tChainSwitchError,\n\tTransactionExecutionError,\n\tTransactionSignatureError,\n\tUserRejectedRequestError,\n} from '../../../utils/_internal/error/transaction';\nimport { type Step, StepType } from '../../_internal/api';\nimport { createLogger } from '../../_internal/logger';\nimport type { SignatureStep, TransactionStep } from '../../_internal/utils';\n\nconst useTransactionOperations = () => {\n\tconst { sendTransactionAsync } = useSendTransaction();\n\tconst { signMessageAsync } = useSignMessage();\n\tconst { signTypedDataAsync } = useSignTypedData();\n\tconst { switchChainAsync } = useSwitchChain();\n\tconst logger = createLogger('TransactionOperations');\n\n\tconst switchChain = async (chainId: number) => {\n\t\tlogger.debug('Switching chain', { targetChainId: chainId });\n\n\t\ttry {\n\t\t\tawait switchChainAsync({ chainId });\n\t\t\tlogger.info('Chain switch successful', { chainId });\n\t\t} catch (e) {\n\t\t\tconst error = e as Error;\n\t\t\tlogger.error('Chain switch failed', error);\n\n\t\t\tif (error.name === 'UserRejectedRequestError') {\n\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t}\n\t\t\tthrow new ChainSwitchError(0, chainId);\n\t\t}\n\t};\n\n\tconst signMessage = async (stepItem: SignatureStep) => {\n\t\ttry {\n\t\t\tif (stepItem.id === StepType.signEIP191) {\n\t\t\t\tlogger.debug('Signing with EIP-191', { data: stepItem.data });\n\t\t\t\tconst message = isHex(stepItem.data)\n\t\t\t\t\t? { raw: stepItem.data }\n\t\t\t\t\t: stepItem.data;\n\t\t\t\treturn await signMessageAsync({ message });\n\t\t\t}\n\t\t\tif (stepItem.id === StepType.signEIP712) {\n\t\t\t\tlogger.debug('Signing with EIP-712', {\n\t\t\t\t\tdomain: stepItem.domain,\n\t\t\t\t\ttypes: stepItem.signature?.types,\n\t\t\t\t});\n\t\t\t\treturn await signTypedDataAsync({\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\tdomain: stepItem.signature!.domain as TypedDataDomain,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\ttypes: stepItem.signature!.types,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\tprimaryType: stepItem.signature!.primaryType,\n\t\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: signature is guaranteed to exist for EIP712 step type\n\t\t\t\t\tmessage: stepItem.signature!.value,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst error = e as TransactionSignatureError;\n\t\t\tlogger.error('Signature failed', error);\n\n\t\t\tif (error.cause instanceof BaseError) {\n\t\t\t\tconst viemError = error.cause as BaseError;\n\t\t\t\tif (viemError instanceof ViemUserRejectedRequestError) {\n\t\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TransactionSignatureError(stepItem.id, error as Error);\n\t\t}\n\t};\n\n\tconst sendTransaction = async (\n\t\tchainId: number,\n\t\tstepItem: TransactionStep,\n\t): Promise<Hex> => {\n\t\tlogger.debug('Sending transaction', {\n\t\t\tchainId,\n\t\t\tto: stepItem.to,\n\t\t\tvalue: stepItem.value,\n\t\t});\n\n\t\ttry {\n\t\t\treturn await sendTransactionAsync({\n\t\t\t\tchainId,\n\t\t\t\tto: stepItem.to,\n\t\t\t\tdata: stepItem.data,\n\t\t\t\tvalue: hexToBigInt(stepItem.value || '0x0'),\n\t\t\t\t...(stepItem.maxFeePerGas && {\n\t\t\t\t\tmaxFeePerGas: hexToBigInt(stepItem.maxFeePerGas),\n\t\t\t\t}),\n\t\t\t\t...(stepItem.maxPriorityFeePerGas && {\n\t\t\t\t\tmaxPriorityFeePerGas: hexToBigInt(stepItem.maxPriorityFeePerGas),\n\t\t\t\t}),\n\t\t\t\t...(stepItem.gas && {\n\t\t\t\t\tgas: hexToBigInt(stepItem.gas),\n\t\t\t\t}),\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconst error = e as TransactionExecutionError;\n\t\t\tlogger.error('Transaction failed', error);\n\n\t\t\tif (error.cause instanceof BaseError) {\n\t\t\t\tconst viemError = error.cause as BaseError;\n\t\t\t\tif (viemError instanceof ViemUserRejectedRequestError) {\n\t\t\t\t\tthrow new UserRejectedRequestError();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TransactionExecutionError(\n\t\t\t\tstepItem.id || 'unknown',\n\t\t\t\terror as Error,\n\t\t\t);\n\t\t}\n\t};\n\n\treturn {\n\t\tswitchChain,\n\t\tsignMessage,\n\t\tsendTransaction,\n\t};\n};\n\nexport const useOrderSteps = () => {\n\tconst { switchChain, signMessage, sendTransaction } =\n\t\tuseTransactionOperations();\n\n\tconst currentChainId = useChainId();\n\n\tconst executeStep = async ({\n\t\tstep,\n\t\tchainId,\n\t}: {\n\t\tstep: Step;\n\t\tchainId: number;\n\t}) => {\n\t\tif (chainId !== currentChainId) {\n\t\t\tawait switchChain(chainId);\n\t\t}\n\n\t\tlet result: Hex | undefined;\n\n\t\tswitch (step.id) {\n\t\t\tcase StepType.signEIP191:\n\t\t\t\tresult = await signMessage(step as SignatureStep);\n\t\t\t\tbreak;\n\t\t\tcase StepType.signEIP712:\n\t\t\t\tresult = await signMessage(step as SignatureStep);\n\t\t\t\tbreak;\n\t\t\tcase StepType.buy:\n\t\t\tcase StepType.sell:\n\t\t\tcase StepType.tokenApproval:\n\t\t\tcase StepType.createListing:\n\t\t\tcase StepType.createOffer:\n\t\t\tcase StepType.cancel:\n\t\t\t\tresult = await sendTransaction(chainId, step as TransactionStep);\n\t\t\t\tbreak;\n\t\t\tcase StepType.unknown:\n\t\t\t\tthrow new Error('Unknown step type');\n\t\t\tdefault: {\n\t\t\t\tconst _exhaustiveCheck: never = step.id;\n\t\t\t\tconsole.error(_exhaustiveCheck);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn {\n\t\texecuteStep,\n\t};\n};\n","import { type Abi, type Address, erc721Abi } from 'viem';\nimport { useAccount, useWriteContract } from 'wagmi';\nimport { ERC1155_ABI } from '../../../utils';\nimport { NoWalletConnectedError } from '../../../utils/_internal/error/transaction';\nimport type { ContractType } from '../../_internal';\n\ninterface BaseTransferParams {\n\tchainId: number;\n\tcollectionAddress: Address;\n\ttokenId: string;\n\treceiverAddress: Address;\n}\n\ninterface ERC721TransferParams extends BaseTransferParams {\n\tcontractType: ContractType.ERC721;\n}\n\ninterface ERC1155TransferParams extends BaseTransferParams {\n\tcontractType: ContractType.ERC1155;\n\tquantity: string;\n}\n\nexport type TransferTokensParams = ERC721TransferParams | ERC1155TransferParams;\n\nconst prepareTransferConfig = (\n\tparams: TransferTokensParams,\n\taccountAddress: Address,\n) => {\n\tif (params.contractType === 'ERC721') {\n\t\treturn {\n\t\t\tabi: erc721Abi as Abi,\n\t\t\taddress: params.collectionAddress,\n\t\t\tfunctionName: 'safeTransferFrom',\n\t\t\targs: [\n\t\t\t\taccountAddress,\n\t\t\t\tparams.receiverAddress,\n\t\t\t\tBigInt(params.tokenId),\n\t\t\t] as const,\n\t\t} as const;\n\t}\n\n\treturn {\n\t\tabi: ERC1155_ABI as Abi,\n\t\taddress: params.collectionAddress,\n\t\tfunctionName: 'safeTransferFrom',\n\t\targs: [\n\t\t\taccountAddress,\n\t\t\tparams.receiverAddress,\n\t\t\tBigInt(params.tokenId),\n\t\t\tparams.quantity,\n\t\t\t'0x', // data\n\t\t] as const,\n\t};\n};\n\nexport const useTransferTokens = () => {\n\tconst { address: accountAddress } = useAccount();\n\tconst {\n\t\twriteContractAsync,\n\t\tdata: hash,\n\t\tisPending,\n\t\tisError,\n\t\tisSuccess,\n\t} = useWriteContract();\n\n\tconst transferTokensAsync = async (params: TransferTokensParams) => {\n\t\tif (!accountAddress) {\n\t\t\tthrow new NoWalletConnectedError();\n\t\t}\n\n\t\tconst config = prepareTransferConfig(params, accountAddress);\n\t\treturn await writeContractAsync(config);\n\t};\n\n\treturn {\n\t\ttransferTokensAsync,\n\t\thash,\n\t\ttransferring: isPending,\n\t\ttransferFailed: isError,\n\t\ttransferSuccess: isSuccess,\n\t};\n};\n"],"mappings":"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"}