{"version":3,"file":"inventory-DWlv8o4I.js","names":["args: UseInventoryArgs","collectionKey: string","token: TokenBalance","chainId: number","accountAddress: Address","collectionAddress: Address","config: SdkConfig","state: InventoryState","isLaos721: boolean","page: IndexerPage","page: Page","collectibles: CollectibleOrder[]","c: CollectibleOrder","args: GetInventoryArgs"],"sources":["../src/react/queries/inventory.ts"],"sourcesContent":["import type {\n\tContractInfo,\n\tPage as IndexerPage,\n\tTokenBalance,\n} from '@0xsequence/indexer';\nimport { infiniteQueryOptions } from '@tanstack/react-query';\nimport type { Address } from 'viem';\nimport { OrderSide, type Page, type SdkConfig } from '../../types';\nimport {\n\ttype CollectibleOrder,\n\ttype ContractType,\n\tgetIndexerClient,\n\tLaosAPI,\n} from '../_internal';\nimport { fetchListCollectibles } from './listCollectibles';\nimport { fetchMarketplaceConfig } from './marketplaceConfig';\n\nexport interface UseInventoryArgs {\n\taccountAddress: Address;\n\tcollectionAddress: Address;\n\tchainId: number;\n\tisLaos721?: boolean;\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n}\n\n// Maintain collection state across calls\ninterface InventoryState {\n\tseenTokenIds: Set<string>;\n\tmarketplaceFinished: boolean;\n\t// Track if we've already fetched all indexer tokens\n\tindexerTokensFetched: boolean;\n\t// Store the token balances from the indexer\n\tindexerTokenBalances: Map<string, CollectibleWithBalance>;\n}\n\n// Store state per collection\nconst stateByCollection = new Map<string, InventoryState>();\n\n// Test helper to clear state between tests\nexport const clearInventoryState = () => {\n\tstateByCollection.clear();\n};\n\nconst getCollectionKey = (args: UseInventoryArgs) =>\n\t`${args.chainId}-${args.collectionAddress}-${args.accountAddress}`;\n\ninterface GetInventoryArgs extends Omit<UseInventoryArgs, 'query'> {\n\tisLaos721: boolean;\n}\n\ninterface CollectibleWithBalance extends CollectibleOrder {\n\tbalance: string;\n\tcontractInfo?: ContractInfo;\n\tcontractType: ContractType.ERC1155 | ContractType.ERC721;\n}\n\nexport interface CollectiblesResponse {\n\tcollectibles: CollectibleWithBalance[];\n\tpage: Page;\n}\n\nfunction getOrInitState(collectionKey: string): InventoryState {\n\tif (!stateByCollection.has(collectionKey)) {\n\t\tstateByCollection.set(collectionKey, {\n\t\t\tseenTokenIds: new Set<string>(),\n\t\t\tmarketplaceFinished: false,\n\t\t\tindexerTokensFetched: false,\n\t\t\tindexerTokenBalances: new Map(),\n\t\t});\n\t}\n\n\t// biome-ignore lint/style/noNonNullAssertion: guaranteed to exist, by the above init\n\treturn stateByCollection.get(collectionKey)!;\n}\n\nfunction collectibleFromTokenBalance(\n\ttoken: TokenBalance,\n): CollectibleWithBalance {\n\treturn {\n\t\tmetadata: {\n\t\t\ttokenId: token.tokenID ?? '',\n\t\t\tattributes: token.tokenMetadata?.attributes ?? [],\n\t\t\timage: token.tokenMetadata?.image,\n\t\t\tname: token.tokenMetadata?.name ?? '',\n\t\t\tdescription: token.tokenMetadata?.description,\n\t\t\tvideo: token.tokenMetadata?.video,\n\t\t\taudio: token.tokenMetadata?.audio,\n\t\t},\n\t\tcontractInfo: token.contractInfo,\n\t\tcontractType: token.contractType as unknown as\n\t\t\t| ContractType.ERC1155\n\t\t\t| ContractType.ERC721,\n\t\tbalance: token.balance,\n\t};\n}\n\nasync function fetchAllIndexerTokens(\n\tchainId: number,\n\taccountAddress: Address,\n\tcollectionAddress: Address,\n\tconfig: SdkConfig,\n\tstate: InventoryState,\n\tisLaos721: boolean,\n): Promise<void> {\n\tif (isLaos721) {\n\t\tconst laosClient = new LaosAPI();\n\t\tconst { balances } = await laosClient.getTokenBalances({\n\t\t\tchainId: chainId.toString(),\n\t\t\taccountAddress,\n\t\t\tincludeMetadata: true,\n\t\t\tcontractAddress: collectionAddress,\n\t\t\tpage: {\n\t\t\t\tsort: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn: 'CREATED_AT',\n\t\t\t\t\t\torder: 'DESC',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\tfor (const balance of balances) {\n\t\t\tif (balance.tokenID) {\n\t\t\t\tstate.indexerTokenBalances.set(\n\t\t\t\t\tbalance.tokenID,\n\t\t\t\t\tcollectibleFromTokenBalance(balance),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tstate.indexerTokensFetched = true;\n\t\treturn;\n\t}\n\n\tconst indexerClient = getIndexerClient(chainId, config);\n\n\tlet page: IndexerPage = {\n\t\tpageSize: 50,\n\t};\n\n\twhile (true) {\n\t\tconst { balances, page: nextPage } = await indexerClient.getTokenBalances({\n\t\t\taccountAddress,\n\t\t\tcontractAddress: collectionAddress,\n\t\t\tincludeMetadata: true,\n\t\t\tpage: page,\n\t\t});\n\n\t\tfor (const balance of balances) {\n\t\t\tif (balance.tokenID) {\n\t\t\t\tstate.indexerTokenBalances.set(\n\t\t\t\t\tbalance.tokenID,\n\t\t\t\t\tcollectibleFromTokenBalance(balance),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!nextPage.more) {\n\t\t\tbreak;\n\t\t}\n\t\tpage = nextPage;\n\t}\n\n\tstate.indexerTokensFetched = true;\n}\n\n// Process indexer tokens that we haven't seen yet\nfunction processRemainingIndexerTokens(\n\tstate: InventoryState,\n\tpage: Page,\n): CollectiblesResponse {\n\tconst allTokens = Array.from(state.indexerTokenBalances.values());\n\n\t// Filter out tokens that we've already seen\n\tconst newTokens = allTokens.filter(\n\t\t(token) => !state.seenTokenIds.has(token.metadata.tokenId),\n\t);\n\n\t// Calculate pagination\n\tconst startIndex = (page.page - 1) * page.pageSize;\n\tconst endIndex = startIndex + page.pageSize;\n\tconst paginatedTokens = newTokens.slice(startIndex, endIndex);\n\n\t// Add new token IDs to the set\n\tfor (const token of paginatedTokens) {\n\t\tstate.seenTokenIds.add(token.metadata.tokenId);\n\t}\n\n\treturn {\n\t\tcollectibles: paginatedTokens,\n\t\tpage: {\n\t\t\tpage: page.page,\n\t\t\tpageSize: page.pageSize,\n\t\t\tmore: endIndex < newTokens.length,\n\t\t},\n\t};\n}\n\nfunction processMarketplaceCollectibles(\n\tcollectibles: CollectibleOrder[],\n\tstate: InventoryState,\n\tpage: Page,\n): {\n\tenrichedCollectibles: CollectibleWithBalance[];\n\tmissingTokens: CollectibleWithBalance[];\n} {\n\t// Add new token IDs to the set\n\tfor (const c of collectibles) {\n\t\tstate.seenTokenIds.add(c.metadata.tokenId);\n\t}\n\n\t// Enrich marketplace collectibles with balance data from indexer\n\tconst enrichedCollectibles = collectibles.map((c: CollectibleOrder) => {\n\t\tconst tokenId = c.metadata.tokenId;\n\t\tconst indexerData = state.indexerTokenBalances.get(tokenId);\n\n\t\treturn {\n\t\t\t...c,\n\t\t\tbalance: indexerData?.balance,\n\t\t\tcontractInfo: indexerData?.contractInfo,\n\t\t\tcontractType: indexerData?.contractType,\n\t\t} as CollectibleWithBalance;\n\t});\n\n\t// Check for missing tokens in the marketplace data\n\tconst marketplaceTokenIds = new Set(\n\t\tenrichedCollectibles.map((c) => c.metadata.tokenId),\n\t);\n\n\tconst missingTokens = Array.from(state.indexerTokenBalances.entries())\n\t\t.filter(([tokenId]) => !marketplaceTokenIds.has(tokenId))\n\t\t.map(([_, balance]) => balance)\n\t\t.slice(0, page.pageSize);\n\n\treturn { enrichedCollectibles, missingTokens };\n}\n\nexport async function fetchInventory(\n\targs: GetInventoryArgs,\n\tconfig: SdkConfig,\n\tpage: Page,\n): Promise<CollectiblesResponse> {\n\tconst { accountAddress, collectionAddress, chainId, isLaos721 } = args;\n\tconst collectionKey = getCollectionKey(args);\n\tconst state = getOrInitState(collectionKey);\n\n\t// On first run, fetch all pages from the indexer\n\tif (!state.indexerTokensFetched) {\n\t\tawait fetchAllIndexerTokens(\n\t\t\tchainId,\n\t\t\taccountAddress,\n\t\t\tcollectionAddress,\n\t\t\tconfig,\n\t\t\tstate,\n\t\t\tisLaos721,\n\t\t);\n\t}\n\n\t// If marketplace API has no more results, use the indexer data\n\tif (state.marketplaceFinished) {\n\t\treturn processRemainingIndexerTokens(state, page);\n\t}\n\n\t// Fetch collectibles from marketplace API\n\tconst marketplaceConfig = await fetchMarketplaceConfig({ config });\n\tconst collectibles = await fetchListCollectibles(\n\t\t{\n\t\t\tchainId,\n\t\t\tcollectionAddress,\n\t\t\tfilter: {\n\t\t\t\tinAccounts: [accountAddress],\n\t\t\t\tincludeEmpty: true,\n\t\t\t},\n\t\t\tside: OrderSide.listing,\n\t\t\tconfig,\n\t\t},\n\t\tmarketplaceConfig,\n\t\tpage,\n\t);\n\n\t// Process the collectibles and find missing tokens\n\tconst { enrichedCollectibles, missingTokens } =\n\t\tprocessMarketplaceCollectibles(collectibles.collectibles, state, page);\n\n\t// If there are no more results from the marketplace API\n\tif (!collectibles.page?.more) {\n\t\t// Mark marketplace as finished and start using indexer data on next call\n\t\tstate.marketplaceFinished = true;\n\t\treturn {\n\t\t\tcollectibles: [...enrichedCollectibles, ...missingTokens],\n\t\t\tpage: {\n\t\t\t\tpage: collectibles.page?.page ?? page.page,\n\t\t\t\tpageSize: collectibles.page?.pageSize ?? page.pageSize,\n\t\t\t\tmore: missingTokens.length > 0,\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {\n\t\tcollectibles: enrichedCollectibles,\n\t\tpage: {\n\t\t\tpage: collectibles.page?.page ?? page.page,\n\t\t\tpageSize: collectibles.page?.pageSize ?? page.pageSize,\n\t\t\tmore: Boolean(collectibles.page?.more),\n\t\t},\n\t};\n}\n\nexport function inventoryOptions(args: UseInventoryArgs, config: SdkConfig) {\n\tconst collectionKey = getCollectionKey(args);\n\tconst enabledQuery = args.query?.enabled ?? true;\n\tconst enabled =\n\t\tenabledQuery && !!args.accountAddress && !!args.collectionAddress;\n\n\treturn infiniteQueryOptions({\n\t\tqueryKey: [\n\t\t\t'inventory',\n\t\t\targs.accountAddress,\n\t\t\targs.collectionAddress,\n\t\t\targs.chainId,\n\t\t],\n\t\tqueryFn: ({ pageParam }) =>\n\t\t\tfetchInventory(\n\t\t\t\t{\n\t\t\t\t\t...args,\n\t\t\t\t\tisLaos721: args.isLaos721 ?? false,\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t\tpageParam,\n\t\t\t),\n\t\tinitialPageParam: { page: 1, pageSize: 30 } as Page,\n\t\tgetNextPageParam: (lastPage) =>\n\t\t\tlastPage.page?.more ? lastPage.page : undefined,\n\t\tenabled,\n\t\tmeta: {\n\t\t\tonInvalidate: () => {\n\t\t\t\tstateByCollection.delete(collectionKey);\n\t\t\t},\n\t\t},\n\t});\n}\n"],"mappings":"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"}