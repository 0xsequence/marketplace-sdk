{"version":3,"file":"ui-N0YEd2S2.js","names":["params: UseFiltersParams","queryOptions"],"sources":["../src/react/hooks/ui/useFilters.tsx","../src/react/hooks/ui/useOpenConnectModal.tsx"],"sourcesContent":["'use client';\n\nimport type { PropertyFilter } from '@0xsequence/metadata';\nimport { useQuery } from '@tanstack/react-query';\nimport type { Optional } from '../../_internal';\nimport {\n\ttype FetchFiltersParams,\n\ttype FiltersQueryOptions,\n\tfiltersQueryOptions,\n} from '../../queries/filters';\nimport { useConfig } from '../config/useConfig';\n\nexport type UseFiltersParams = Optional<FiltersQueryOptions, 'config'>;\n\n/**\n * Hook to fetch metadata filters for a collection\n *\n * Retrieves property filters for a collection from the metadata service,\n * with support for marketplace-specific filter configuration including\n * exclusion rules and custom ordering.\n *\n * @param params - Configuration parameters\n * @param params.chainId - The chain ID (must be number, e.g., 1 for Ethereum, 137 for Polygon)\n * @param params.collectionAddress - The collection contract address to fetch filters for\n * @param params.showAllFilters - Whether to show all filters or apply marketplace filtering\n * @param params.excludePropertyValues - Whether to exclude property values from the response\n * @param params.query - Optional React Query configuration\n *\n * @returns Query result containing property filters for the collection\n *\n * @example\n * Basic usage:\n * ```typescript\n * const { data: filters, isLoading } = useFilters({\n *   chainId: 137,\n *   collectionAddress: '0x1234...'\n * })\n *\n * if (data) {\n *   console.log(`Found ${data.length} filters`);\n *   data.forEach(filter => {\n *     console.log(`${filter.name}: ${filter.values?.join(', ')}`);\n *   });\n * }\n * ```\n *\n * @example\n * With marketplace filtering disabled:\n * ```typescript\n * const { data: allFilters } = useFilters({\n *   chainId: 1,\n *   collectionAddress: '0x5678...',\n *   showAllFilters: true, // Bypass marketplace filter rules\n *   query: {\n *     enabled: Boolean(selectedCollection),\n *     staleTime: 300000 // Cache for 5 minutes\n *   }\n * })\n * ```\n *\n * @example\n * Exclude property values for faster loading:\n * ```typescript\n * const { data: filterNames } = useFilters({\n *   chainId: 137,\n *   collectionAddress: collectionAddress,\n *   excludePropertyValues: true, // Only get filter names, not values\n *   query: {\n *     enabled: Boolean(collectionAddress)\n *   }\n * })\n * ```\n */\nexport function useFilters(params: UseFiltersParams) {\n\tconst defaultConfig = useConfig();\n\n\tconst { config = defaultConfig, ...rest } = params;\n\n\tconst queryOptions = filtersQueryOptions({\n\t\tconfig,\n\t\t...rest,\n\t});\n\n\treturn useQuery({\n\t\t...queryOptions,\n\t});\n}\n\n/**\n * Hook to progressively load collection filters\n *\n * First loads filter names only for fast initial display, then loads full filter\n * data with values. Uses placeholder data to provide immediate feedback while\n * full data loads in the background.\n *\n * @param params - Configuration parameters (same as useFilters)\n *\n * @returns Query result with additional loading states\n * @returns result.isLoadingNames - Whether filter names are still loading\n * @returns result.isFetchingValues - Whether filter values are being fetched\n *\n * @example\n * Progressive filter loading:\n * ```typescript\n * const {\n *   data: filters,\n *   isLoadingNames,\n *   isFetchingValues,\n *   isLoading\n * } = useFiltersProgressive({\n *   chainId: 137,\n *   collectionAddress: '0x1234...'\n * })\n *\n * if (isLoadingNames) {\n *   return <div>Loading filters...</div>;\n * }\n *\n * return (\n *   <div>\n *     {filters?.map(filter => (\n *       <FilterComponent\n *         key={filter.name}\n *         filter={filter}\n *         isLoadingValues={isFetchingValues}\n *       />\n *     ))}\n *   </div>\n * );\n * ```\n */\nexport function useFiltersProgressive(params: UseFiltersParams) {\n\tconst defaultConfig = useConfig();\n\n\tconst { config = defaultConfig, ...rest } = params;\n\n\tconst namesQuery = useQuery(\n\t\tfiltersQueryOptions({\n\t\t\tconfig,\n\t\t\t...rest,\n\t\t\texcludePropertyValues: true,\n\t\t}),\n\t);\n\n\tconst fullQuery = useQuery({\n\t\t...filtersQueryOptions({\n\t\t\tconfig,\n\t\t\t...rest,\n\t\t}),\n\t\tplaceholderData: namesQuery.data,\n\t});\n\n\tconst isLoadingNames = namesQuery.isLoading;\n\tconst isFetchingValues = fullQuery.isPlaceholderData && fullQuery.isFetching;\n\n\treturn {\n\t\t...fullQuery,\n\t\tisFetchingValues,\n\t\tisLoadingNames,\n\t};\n}\n\nexport { filtersQueryOptions };\n\nexport type { FetchFiltersParams, FiltersQueryOptions };\n\n// Legacy exports for backward compatibility\nexport type UseFiltersArgs = {\n\tchainId: number;\n\tcollectionAddress: string;\n\tshowAllFilters?: boolean;\n\texcludePropertyValues?: boolean;\n\tquery?: {\n\t\tenabled?: boolean;\n\t};\n};\n\nexport type UseFilterReturn = PropertyFilter[];\n","import { useConfig } from '../config/useConfig';\n\nexport const useOpenConnectModal = () => {\n\tconst context = useConfig();\n\n\treturn {\n\t\topenConnectModal: context.openConnectModal,\n\t};\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA,SAAgB,WAAWA,QAA0B;CACpD,MAAM,gBAAgB,WAAW;CAEjC,MAAM,EAAE,SAAS,cAAe,GAAG,MAAM,GAAG;CAE5C,MAAMC,iBAAe,oBAAoB;EACxC;EACA,GAAG;CACH,EAAC;AAEF,QAAO,SAAS,EACf,GAAGA,eACH,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CD,SAAgB,sBAAsBD,QAA0B;CAC/D,MAAM,gBAAgB,WAAW;CAEjC,MAAM,EAAE,SAAS,cAAe,GAAG,MAAM,GAAG;CAE5C,MAAM,aAAa,SAClB,oBAAoB;EACnB;EACA,GAAG;EACH,uBAAuB;CACvB,EAAC,CACF;CAED,MAAM,YAAY,SAAS;EAC1B,GAAG,oBAAoB;GACtB;GACA,GAAG;EACH,EAAC;EACF,iBAAiB,WAAW;CAC5B,EAAC;CAEF,MAAM,iBAAiB,WAAW;CAClC,MAAM,mBAAmB,UAAU,qBAAqB,UAAU;AAElE,QAAO;EACN,GAAG;EACH;EACA;CACA;AACD;;;;AC9JD,MAAa,sBAAsB,MAAM;CACxC,MAAM,UAAU,WAAW;AAE3B,QAAO,EACN,kBAAkB,QAAQ,iBAC1B;AACD"}